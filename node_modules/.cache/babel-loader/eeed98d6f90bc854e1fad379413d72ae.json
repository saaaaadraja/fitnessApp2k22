{"ast":null,"code":"/*!\nFullCalendar v5.6.0\nDocs & License: https://fullcalendar.io/\n(c) 2020 Adam Shaw\n*/\nimport './main.css';\nimport { hasBgRendering, Splitter, createFormatter, createElement, ViewContextType, RenderHook, BaseComponent, createRef, diffDays, buildNavLinkData, WeekNumberRoot, getStickyHeaderDates, ViewRoot, SimpleScrollGrid, getStickyFooterScrollbar, NowTimer, NowIndicatorRoot, DateComponent, renderScrollShim, rangeContainsMarker, startOfDay, asRoughMs, createDuration, RefMap, PositionCache, sortEventSegs, compareByFieldSpecs, buildSegCompareObj, StandardEvent, DayCellContent, config, DayCellRoot, getSegMeta, buildEventRangeKey, BgEvent, renderFill, Fragment, memoize, addDurations, multiplyDuration, wholeDivideDurations, intersectRanges, Slicer, formatIsoTimeString, DayHeader, DaySeriesModel, DayTableModel, createPlugin } from '@fullcalendar/common';\nimport { __extends, __assign } from 'tslib';\nimport { DayTable } from '@fullcalendar/daygrid';\n\nvar AllDaySplitter =\n/** @class */\nfunction (_super) {\n  __extends(AllDaySplitter, _super);\n\n  function AllDaySplitter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AllDaySplitter.prototype.getKeyInfo = function () {\n    return {\n      allDay: {},\n      timed: {}\n    };\n  };\n\n  AllDaySplitter.prototype.getKeysForDateSpan = function (dateSpan) {\n    if (dateSpan.allDay) {\n      return ['allDay'];\n    }\n\n    return ['timed'];\n  };\n\n  AllDaySplitter.prototype.getKeysForEventDef = function (eventDef) {\n    if (!eventDef.allDay) {\n      return ['timed'];\n    }\n\n    if (hasBgRendering(eventDef)) {\n      return ['timed', 'allDay'];\n    }\n\n    return ['allDay'];\n  };\n\n  return AllDaySplitter;\n}(Splitter);\n\nvar DEFAULT_SLAT_LABEL_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'short'\n});\n\nfunction TimeColsAxisCell(props) {\n  var classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-label', props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor'];\n  return createElement(ViewContextType.Consumer, null, function (context) {\n    if (!props.isLabeled) {\n      return createElement(\"td\", {\n        className: classNames.join(' '),\n        \"data-time\": props.isoTimeStr\n      });\n    }\n\n    var dateEnv = context.dateEnv,\n        options = context.options,\n        viewApi = context.viewApi;\n    var labelFormat = // TODO: fully pre-parse\n    options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) : createFormatter(options.slotLabelFormat);\n    var hookProps = {\n      level: 0,\n      time: props.time,\n      date: dateEnv.toDate(props.date),\n      view: viewApi,\n      text: dateEnv.format(props.date, labelFormat)\n    };\n    return createElement(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.slotLabelClassNames,\n      content: options.slotLabelContent,\n      defaultContent: renderInnerContent,\n      didMount: options.slotLabelDidMount,\n      willUnmount: options.slotLabelWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return createElement(\"td\", {\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        \"data-time\": props.isoTimeStr\n      }, createElement(\"div\", {\n        className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\"\n      }, createElement(\"div\", {\n        className: \"fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion\",\n        ref: innerElRef\n      }, innerContent)));\n    });\n  });\n}\n\nfunction renderInnerContent(props) {\n  return props.text;\n}\n\nvar TimeBodyAxis =\n/** @class */\nfunction (_super) {\n  __extends(TimeBodyAxis, _super);\n\n  function TimeBodyAxis() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeBodyAxis.prototype.render = function () {\n    return this.props.slatMetas.map(function (slatMeta) {\n      return createElement(\"tr\", {\n        key: slatMeta.key\n      }, createElement(TimeColsAxisCell, __assign({}, slatMeta)));\n    });\n  };\n\n  return TimeBodyAxis;\n}(BaseComponent);\n\nvar DEFAULT_WEEK_NUM_FORMAT = createFormatter({\n  week: 'short'\n});\nvar AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\n\nvar TimeColsView =\n/** @class */\nfunction (_super) {\n  __extends(TimeColsView, _super);\n\n  function TimeColsView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n\n    _this.headerElRef = createRef();\n    _this.rootElRef = createRef();\n    _this.scrollerElRef = createRef();\n    _this.state = {\n      slatCoords: null\n    };\n\n    _this.handleScrollTopRequest = function (scrollTop) {\n      var scrollerEl = _this.scrollerElRef.current;\n\n      if (scrollerEl) {\n        // TODO: not sure how this could ever be null. weirdness with the reducer\n        scrollerEl.scrollTop = scrollTop;\n      }\n    };\n    /* Header Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n\n\n    _this.renderHeadAxis = function (rowKey, frameHeight) {\n      if (frameHeight === void 0) {\n        frameHeight = '';\n      }\n\n      var options = _this.context.options;\n      var dateProfile = _this.props.dateProfile;\n      var range = dateProfile.renderRange;\n      var dayCnt = diffDays(range.start, range.end);\n      var navLinkAttrs = options.navLinks && dayCnt === 1 // only do in day views (to avoid doing in week views that dont need it)\n      ? {\n        'data-navlink': buildNavLinkData(range.start, 'week'),\n        tabIndex: 0\n      } : {};\n\n      if (options.weekNumbers && rowKey === 'day') {\n        return createElement(WeekNumberRoot, {\n          date: range.start,\n          defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n        }, function (rootElRef, classNames, innerElRef, innerContent) {\n          return createElement(\"th\", {\n            ref: rootElRef,\n            className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(classNames).join(' ')\n          }, createElement(\"div\", {\n            className: \"fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid\",\n            style: {\n              height: frameHeight\n            }\n          }, createElement(\"a\", __assign({\n            ref: innerElRef,\n            className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\"\n          }, navLinkAttrs), innerContent)));\n        });\n      }\n\n      return createElement(\"th\", {\n        className: \"fc-timegrid-axis\"\n      }, createElement(\"div\", {\n        className: \"fc-timegrid-axis-frame\",\n        style: {\n          height: frameHeight\n        }\n      }));\n    };\n    /* Table Component Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n    // but DayGrid still needs to have classNames on inner elements in order to measure.\n\n\n    _this.renderTableRowAxis = function (rowHeight) {\n      var _a = _this.context,\n          options = _a.options,\n          viewApi = _a.viewApi;\n      var hookProps = {\n        text: options.allDayText,\n        view: viewApi\n      };\n      return (// TODO: make reusable hook. used in list view too\n        createElement(RenderHook, {\n          hookProps: hookProps,\n          classNames: options.allDayClassNames,\n          content: options.allDayContent,\n          defaultContent: renderAllDayInner,\n          didMount: options.allDayDidMount,\n          willUnmount: options.allDayWillUnmount\n        }, function (rootElRef, classNames, innerElRef, innerContent) {\n          return createElement(\"td\", {\n            ref: rootElRef,\n            className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(classNames).join(' ')\n          }, createElement(\"div\", {\n            className: 'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame' + (rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : ''),\n            style: {\n              height: rowHeight\n            }\n          }, createElement(\"span\", {\n            className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\",\n            ref: innerElRef\n          }, innerContent)));\n        })\n      );\n    };\n\n    _this.handleSlatCoords = function (slatCoords) {\n      _this.setState({\n        slatCoords: slatCoords\n      });\n    };\n\n    return _this;\n  } // rendering\n  // ----------------------------------------------------------------------------------------------------\n\n\n  TimeColsView.prototype.renderSimpleLayout = function (headerRowContent, allDayContent, timeContent) {\n    var _a = this,\n        context = _a.context,\n        props = _a.props;\n\n    var sections = [];\n    var stickyHeaderDates = getStickyHeaderDates(context.options);\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }\n      });\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        chunk: {\n          content: allDayContent\n        }\n      });\n      sections.push({\n        type: 'body',\n        key: 'all-day-divider',\n        outerContent: // TODO: rename to cellContent so don't need to define <tr>?\n        createElement(\"tr\", {\n          className: \"fc-scrollgrid-section\"\n        }, createElement(\"td\", {\n          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n        }))\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunk: {\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }\n    });\n    return createElement(ViewRoot, {\n      viewSpec: context.viewSpec,\n      elRef: this.rootElRef\n    }, function (rootElRef, classNames) {\n      return createElement(\"div\", {\n        className: ['fc-timegrid'].concat(classNames).join(' '),\n        ref: rootElRef\n      }, createElement(SimpleScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        cols: [{\n          width: 'shrink'\n        }],\n        sections: sections\n      }));\n    });\n  };\n\n  TimeColsView.prototype.renderHScrollLayout = function (headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n    var _this = this;\n\n    var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation');\n    }\n\n    var _a = this,\n        context = _a.context,\n        props = _a.props;\n\n    var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);\n    var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);\n    var sections = [];\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        syncRowHeights: true,\n        chunks: [{\n          key: 'axis',\n          rowContent: function rowContent(arg) {\n            return createElement(\"tr\", null, _this.renderHeadAxis('day', arg.rowSyncHeights[0]));\n          }\n        }, {\n          key: 'cols',\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }]\n      });\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        syncRowHeights: true,\n        chunks: [{\n          key: 'axis',\n          rowContent: function rowContent(contentArg) {\n            return createElement(\"tr\", null, _this.renderTableRowAxis(contentArg.rowSyncHeights[0]));\n          }\n        }, {\n          key: 'cols',\n          content: allDayContent\n        }]\n      });\n      sections.push({\n        key: 'all-day-divider',\n        type: 'body',\n        outerContent: // TODO: rename to cellContent so don't need to define <tr>?\n        createElement(\"tr\", {\n          className: \"fc-scrollgrid-section\"\n        }, createElement(\"td\", {\n          colSpan: 2,\n          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n        }))\n      });\n    }\n\n    var isNowIndicator = context.options.nowIndicator;\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunks: [{\n        key: 'axis',\n        content: function content(arg) {\n          return (// TODO: make this now-indicator arrow more DRY with TimeColsContent\n            createElement(\"div\", {\n              className: \"fc-timegrid-axis-chunk\"\n            }, createElement(\"table\", {\n              style: {\n                height: arg.expandRows ? arg.clientHeight : ''\n              }\n            }, arg.tableColGroupNode, createElement(\"tbody\", null, createElement(TimeBodyAxis, {\n              slatMetas: slatMetas\n            }))), createElement(\"div\", {\n              className: \"fc-timegrid-now-indicator-container\"\n            }, createElement(NowTimer, {\n              unit: isNowIndicator ? 'minute' : 'day'\n              /* hacky */\n\n            }, function (nowDate) {\n              var nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void\n\n              if (typeof nowIndicatorTop === 'number') {\n                return createElement(NowIndicatorRoot, {\n                  isAxis: true,\n                  date: nowDate\n                }, function (rootElRef, classNames, innerElRef, innerContent) {\n                  return createElement(\"div\", {\n                    ref: rootElRef,\n                    className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '),\n                    style: {\n                      top: nowIndicatorTop\n                    }\n                  }, innerContent);\n                });\n              }\n\n              return null;\n            })))\n          );\n        }\n      }, {\n        key: 'cols',\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }]\n    });\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        key: 'footer',\n        type: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'axis',\n          content: renderScrollShim\n        }, {\n          key: 'cols',\n          content: renderScrollShim\n        }]\n      });\n    }\n\n    return createElement(ViewRoot, {\n      viewSpec: context.viewSpec,\n      elRef: this.rootElRef\n    }, function (rootElRef, classNames) {\n      return createElement(\"div\", {\n        className: ['fc-timegrid'].concat(classNames).join(' '),\n        ref: rootElRef\n      }, createElement(ScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: false,\n        colGroups: [{\n          width: 'shrink',\n          cols: [{\n            width: 'shrink'\n          }]\n        }, {\n          cols: [{\n            span: colCnt,\n            minWidth: dayMinWidth\n          }]\n        }],\n        sections: sections\n      }));\n    });\n  };\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  TimeColsView.prototype.getAllDayMaxEventProps = function () {\n    var _a = this.context.options,\n        dayMaxEvents = _a.dayMaxEvents,\n        dayMaxEventRows = _a.dayMaxEventRows;\n\n    if (dayMaxEvents === true || dayMaxEventRows === true) {\n      // is auto?\n      dayMaxEvents = undefined;\n      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n    }\n\n    return {\n      dayMaxEvents: dayMaxEvents,\n      dayMaxEventRows: dayMaxEventRows\n    };\n  };\n\n  return TimeColsView;\n}(DateComponent);\n\nfunction renderAllDayInner(hookProps) {\n  return hookProps.text;\n}\n\nvar TimeColsSlatsCoords =\n/** @class */\nfunction () {\n  function TimeColsSlatsCoords(positions, dateProfile, slotDuration) {\n    this.positions = positions;\n    this.dateProfile = dateProfile;\n    this.slotDuration = slotDuration;\n  }\n\n  TimeColsSlatsCoords.prototype.safeComputeTop = function (date) {\n    var dateProfile = this.dateProfile;\n\n    if (rangeContainsMarker(dateProfile.currentRange, date)) {\n      var startOfDayDate = startOfDay(date);\n      var timeMs = date.valueOf() - startOfDayDate.valueOf();\n\n      if (timeMs >= asRoughMs(dateProfile.slotMinTime) && timeMs < asRoughMs(dateProfile.slotMaxTime)) {\n        return this.computeTimeTop(createDuration(timeMs));\n      }\n    }\n\n    return null;\n  }; // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n\n\n  TimeColsSlatsCoords.prototype.computeDateTop = function (when, startOfDayDate) {\n    if (!startOfDayDate) {\n      startOfDayDate = startOfDay(when);\n    }\n\n    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));\n  }; // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n  // Eventually allow computation with arbirary slat dates.\n\n\n  TimeColsSlatsCoords.prototype.computeTimeTop = function (duration) {\n    var _a = this,\n        positions = _a.positions,\n        dateProfile = _a.dateProfile;\n\n    var len = positions.els.length; // floating-point value of # of slots covered\n\n    var slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);\n    var slatIndex;\n    var slatRemainder; // compute a floating-point number for how many slats should be progressed through.\n    // from 0 to number of slats (inclusive)\n    // constrained because slotMinTime/slotMaxTime might be customized.\n\n    slatCoverage = Math.max(0, slatCoverage);\n    slatCoverage = Math.min(len, slatCoverage); // an integer index of the furthest whole slat\n    // from 0 to number slats (*exclusive*, so len-1)\n\n    slatIndex = Math.floor(slatCoverage);\n    slatIndex = Math.min(slatIndex, len - 1); // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n    // could be 1.0 if slatCoverage is covering *all* the slots\n\n    slatRemainder = slatCoverage - slatIndex;\n    return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;\n  };\n\n  return TimeColsSlatsCoords;\n}();\n\nvar TimeColsSlatsBody =\n/** @class */\nfunction (_super) {\n  __extends(TimeColsSlatsBody, _super);\n\n  function TimeColsSlatsBody() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeColsSlatsBody.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var slatElRefs = props.slatElRefs;\n    return createElement(\"tbody\", null, props.slatMetas.map(function (slatMeta, i) {\n      var hookProps = {\n        time: slatMeta.time,\n        date: context.dateEnv.toDate(slatMeta.date),\n        view: context.viewApi\n      };\n      var classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-lane', slatMeta.isLabeled ? '' : 'fc-timegrid-slot-minor'];\n      return createElement(\"tr\", {\n        key: slatMeta.key,\n        ref: slatElRefs.createRef(slatMeta.key)\n      }, props.axis && createElement(TimeColsAxisCell, __assign({}, slatMeta)), createElement(RenderHook, {\n        hookProps: hookProps,\n        classNames: options.slotLaneClassNames,\n        content: options.slotLaneContent,\n        didMount: options.slotLaneDidMount,\n        willUnmount: options.slotLaneWillUnmount\n      }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n        return createElement(\"td\", {\n          ref: rootElRef,\n          className: classNames.concat(customClassNames).join(' '),\n          \"data-time\": slatMeta.isoTimeStr\n        }, innerContent);\n      }));\n    }));\n  };\n\n  return TimeColsSlatsBody;\n}(BaseComponent);\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/\n\n\nvar TimeColsSlats =\n/** @class */\nfunction (_super) {\n  __extends(TimeColsSlats, _super);\n\n  function TimeColsSlats() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = createRef();\n    _this.slatElRefs = new RefMap();\n    return _this;\n  }\n\n  TimeColsSlats.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    return createElement(\"div\", {\n      className: \"fc-timegrid-slots\",\n      ref: this.rootElRef\n    }, createElement(\"table\", {\n      className: context.theme.getClass('table'),\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth,\n        height: props.minHeight\n      }\n    }, props.tableColGroupNode\n    /* relies on there only being a single <col> for the axis */\n    , createElement(TimeColsSlatsBody, {\n      slatElRefs: this.slatElRefs,\n      axis: props.axis,\n      slatMetas: props.slatMetas\n    })));\n  };\n\n  TimeColsSlats.prototype.componentDidMount = function () {\n    this.updateSizing();\n  };\n\n  TimeColsSlats.prototype.componentDidUpdate = function () {\n    this.updateSizing();\n  };\n\n  TimeColsSlats.prototype.componentWillUnmount = function () {\n    if (this.props.onCoords) {\n      this.props.onCoords(null);\n    }\n  };\n\n  TimeColsSlats.prototype.updateSizing = function () {\n    var _a = this,\n        context = _a.context,\n        props = _a.props;\n\n    if (props.onCoords && props.clientWidth !== null // means sizing has stabilized\n    ) {\n      var rootEl = this.rootElRef.current;\n\n      if (rootEl.offsetHeight) {\n        // not hidden by css\n        props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));\n      }\n    }\n  };\n\n  return TimeColsSlats;\n}(BaseComponent);\n\nfunction collectSlatEls(elMap, slatMetas) {\n  return slatMetas.map(function (slatMeta) {\n    return elMap[slatMeta.key];\n  });\n}\n\nfunction splitSegsByCol(segs, colCnt) {\n  var segsByCol = [];\n  var i;\n\n  for (i = 0; i < colCnt; i += 1) {\n    segsByCol.push([]);\n  }\n\n  if (segs) {\n    for (i = 0; i < segs.length; i += 1) {\n      segsByCol[segs[i].col].push(segs[i]);\n    }\n  }\n\n  return segsByCol;\n}\n\nfunction splitInteractionByCol(ui, colCnt) {\n  var byRow = [];\n\n  if (!ui) {\n    for (var i = 0; i < colCnt; i += 1) {\n      byRow[i] = null;\n    }\n  } else {\n    for (var i = 0; i < colCnt; i += 1) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n\n    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {\n      var seg = _a[_i];\n      byRow[seg.col].segs.push(seg);\n    }\n  }\n\n  return byRow;\n} // UNFORTUNATELY, assigns results to the top/bottom/level/forwardCoord/backwardCoord props of the actual segs.\n// TODO: return hash (by instanceId) of results\n\n\nfunction computeSegCoords(segs, dayDate, slatCoords, eventMinHeight, eventOrderSpecs) {\n  computeSegVerticals(segs, dayDate, slatCoords, eventMinHeight);\n  return computeSegHorizontals(segs, eventOrderSpecs); // requires top/bottom from computeSegVerticals\n} // For each segment in an array, computes and assigns its top and bottom properties\n\n\nfunction computeSegVerticals(segs, dayDate, slatCoords, eventMinHeight) {\n  for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n    var seg = segs_1[_i];\n    seg.top = slatCoords.computeDateTop(seg.start, dayDate);\n    seg.bottom = Math.max(seg.top + (eventMinHeight || 0), // yuck\n    slatCoords.computeDateTop(seg.end, dayDate));\n  }\n} // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\n// Assumed the segs are already ordered.\n// NOTE: Also reorders the given array by date!\n\n\nfunction computeSegHorizontals(segs, eventOrderSpecs) {\n  // IMPORTANT TO CLEAR OLD RESULTS :(\n  for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n    var seg = segs_2[_i];\n    seg.level = null;\n    seg.forwardCoord = null;\n    seg.backwardCoord = null;\n    seg.forwardPressure = null;\n  }\n\n  segs = sortEventSegs(segs, eventOrderSpecs);\n  var level0;\n  var levels = buildSlotSegLevels(segs);\n  computeForwardSlotSegs(levels);\n\n  if (level0 = levels[0]) {\n    for (var _a = 0, level0_1 = level0; _a < level0_1.length; _a++) {\n      var seg = level0_1[_a];\n      computeSlotSegPressures(seg);\n    }\n\n    for (var _b = 0, level0_2 = level0; _b < level0_2.length; _b++) {\n      var seg = level0_2[_b];\n      computeSegForwardBack(seg, 0, 0, eventOrderSpecs);\n    }\n  }\n\n  return segs;\n} // Builds an array of segments \"levels\". The first level will be the leftmost tier of segments if the calendar is\n// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\n\n\nfunction buildSlotSegLevels(segs) {\n  var levels = [];\n  var i;\n  var seg;\n  var j;\n\n  for (i = 0; i < segs.length; i += 1) {\n    seg = segs[i]; // go through all the levels and stop on the first level where there are no collisions\n\n    for (j = 0; j < levels.length; j += 1) {\n      if (!computeSlotSegCollisions(seg, levels[j]).length) {\n        break;\n      }\n    }\n\n    seg.level = j;\n    (levels[j] || (levels[j] = [])).push(seg);\n  }\n\n  return levels;\n} // Find all the segments in `otherSegs` that vertically collide with `seg`.\n// Append into an optionally-supplied `results` array and return.\n\n\nfunction computeSlotSegCollisions(seg, otherSegs, results) {\n  if (results === void 0) {\n    results = [];\n  }\n\n  for (var i = 0; i < otherSegs.length; i += 1) {\n    if (isSlotSegCollision(seg, otherSegs[i])) {\n      results.push(otherSegs[i]);\n    }\n  }\n\n  return results;\n} // Do these segments occupy the same vertical space?\n\n\nfunction isSlotSegCollision(seg1, seg2) {\n  return seg1.bottom > seg2.top && seg1.top < seg2.bottom;\n} // For every segment, figure out the other segments that are in subsequent\n// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\n\n\nfunction computeForwardSlotSegs(levels) {\n  var i;\n  var level;\n  var j;\n  var seg;\n  var k;\n\n  for (i = 0; i < levels.length; i += 1) {\n    level = levels[i];\n\n    for (j = 0; j < level.length; j += 1) {\n      seg = level[j];\n      seg.forwardSegs = [];\n\n      for (k = i + 1; k < levels.length; k += 1) {\n        computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);\n      }\n    }\n  }\n} // Figure out which path forward (via seg.forwardSegs) results in the longest path until\n// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\n\n\nfunction computeSlotSegPressures(seg) {\n  var forwardSegs = seg.forwardSegs;\n  var forwardPressure = 0;\n  var i;\n  var forwardSeg;\n\n  if (seg.forwardPressure == null) {\n    // not already computed\n    for (i = 0; i < forwardSegs.length; i += 1) {\n      forwardSeg = forwardSegs[i]; // figure out the child's maximum forward path\n\n      computeSlotSegPressures(forwardSeg); // either use the existing maximum, or use the child's forward pressure\n      // plus one (for the forwardSeg itself)\n\n      forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);\n    }\n\n    seg.forwardPressure = forwardPressure;\n  }\n} // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\n// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \"left\" and\n// seg.forwardCoord maps to \"right\" (via percentage). Vice-versa if the calendar is right-to-left.\n//\n// The segment might be part of a \"series\", which means consecutive segments with the same pressure\n// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\n// segments behind this one in the current series, and `seriesBackwardCoord` is the starting\n// coordinate of the first segment in the series.\n\n\nfunction computeSegForwardBack(seg, seriesBackwardPressure, seriesBackwardCoord, eventOrderSpecs) {\n  var forwardSegs = seg.forwardSegs;\n  var i;\n\n  if (seg.forwardCoord == null) {\n    // not already computed\n    if (!forwardSegs.length) {\n      // if there are no forward segments, this segment should butt up against the edge\n      seg.forwardCoord = 1;\n    } else {\n      // sort highest pressure first\n      sortForwardSegs(forwardSegs, eventOrderSpecs); // this segment's forwardCoord will be calculated from the backwardCoord of the\n      // highest-pressure forward segment.\n\n      computeSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord, eventOrderSpecs);\n      seg.forwardCoord = forwardSegs[0].backwardCoord;\n    } // calculate the backwardCoord from the forwardCoord. consider the series\n\n\n    seg.backwardCoord = seg.forwardCoord - (seg.forwardCoord - seriesBackwardCoord) / ( // available width for series\n    seriesBackwardPressure + 1); // # of segments in the series\n    // use this segment's coordinates to computed the coordinates of the less-pressurized\n    // forward segments\n\n    for (i = 0; i < forwardSegs.length; i += 1) {\n      computeSegForwardBack(forwardSegs[i], 0, seg.forwardCoord, eventOrderSpecs);\n    }\n  }\n}\n\nfunction sortForwardSegs(forwardSegs, eventOrderSpecs) {\n  var objs = forwardSegs.map(buildTimeGridSegCompareObj);\n  var specs = [// put higher-pressure first\n  {\n    field: 'forwardPressure',\n    order: -1\n  }, // put segments that are closer to initial edge first (and favor ones with no coords yet)\n  {\n    field: 'backwardCoord',\n    order: 1\n  }].concat(eventOrderSpecs);\n  objs.sort(function (obj0, obj1) {\n    return compareByFieldSpecs(obj0, obj1, specs);\n  });\n  return objs.map(function (c) {\n    return c._seg;\n  });\n}\n\nfunction buildTimeGridSegCompareObj(seg) {\n  var obj = buildSegCompareObj(seg);\n  obj.forwardPressure = seg.forwardPressure;\n  obj.backwardCoord = seg.backwardCoord;\n  return obj;\n}\n\nvar DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  meridiem: false\n});\n\nvar TimeColEvent =\n/** @class */\nfunction (_super) {\n  __extends(TimeColEvent, _super);\n\n  function TimeColEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeColEvent.prototype.render = function () {\n    var classNames = ['fc-timegrid-event', 'fc-v-event'];\n\n    if (this.props.isCondensed) {\n      classNames.push('fc-timegrid-event-condensed');\n    }\n\n    return createElement(StandardEvent, __assign({}, this.props, {\n      defaultTimeFormat: DEFAULT_TIME_FORMAT,\n      extraClassNames: classNames\n    }));\n  };\n\n  return TimeColEvent;\n}(BaseComponent);\n\nvar TimeColMisc =\n/** @class */\nfunction (_super) {\n  __extends(TimeColMisc, _super);\n\n  function TimeColMisc() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeColMisc.prototype.render = function () {\n    var props = this.props;\n    return createElement(DayCellContent, {\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraHookProps: props.extraHookProps\n    }, function (innerElRef, innerContent) {\n      return innerContent && createElement(\"div\", {\n        className: \"fc-timegrid-col-misc\",\n        ref: innerElRef\n      }, innerContent);\n    });\n  };\n\n  return TimeColMisc;\n}(BaseComponent);\n\nconfig.timeGridEventCondensedHeight = 30;\n\nvar TimeCol =\n/** @class */\nfunction (_super) {\n  __extends(TimeCol, _super);\n\n  function TimeCol() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeCol.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var isSelectMirror = context.options.selectMirror;\n    var mirrorSegs = props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];\n    var interactionAffectedInstances = // TODO: messy way to compute this\n    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n    return createElement(DayCellRoot, {\n      elRef: props.elRef,\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraHookProps: props.extraHookProps\n    }, function (rootElRef, classNames, dataAttrs) {\n      return createElement(\"td\", __assign({\n        ref: rootElRef,\n        className: ['fc-timegrid-col'].concat(classNames, props.extraClassNames || []).join(' ')\n      }, dataAttrs, props.extraDataAttrs), createElement(\"div\", {\n        className: \"fc-timegrid-col-frame\"\n      }, createElement(\"div\", {\n        className: \"fc-timegrid-col-bg\"\n      }, _this.renderFillSegs(props.businessHourSegs, 'non-business'), _this.renderFillSegs(props.bgEventSegs, 'bg-event'), _this.renderFillSegs(props.dateSelectionSegs, 'highlight')), createElement(\"div\", {\n        className: \"fc-timegrid-col-events\"\n      }, _this.renderFgSegs(props.fgEventSegs, interactionAffectedInstances)), createElement(\"div\", {\n        className: \"fc-timegrid-col-events\"\n      }, _this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror))), createElement(\"div\", {\n        className: \"fc-timegrid-now-indicator-container\"\n      }, _this.renderNowIndicator(props.nowIndicatorSegs)), createElement(TimeColMisc, {\n        date: props.date,\n        dateProfile: props.dateProfile,\n        todayRange: props.todayRange,\n        extraHookProps: props.extraHookProps\n      })));\n    });\n  };\n\n  TimeCol.prototype.renderFgSegs = function (segs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n    var props = this.props;\n\n    if (props.forPrint) {\n      return this.renderPrintFgSegs(segs);\n    }\n\n    if (props.slatCoords) {\n      return this.renderPositionedFgSegs(segs, segIsInvisible, isDragging, isResizing, isDateSelecting);\n    }\n\n    return null;\n  };\n\n  TimeCol.prototype.renderPrintFgSegs = function (segs) {\n    var _a = this,\n        props = _a.props,\n        context = _a.context; // not DRY\n\n\n    segs = sortEventSegs(segs, context.options.eventOrder);\n    return segs.map(function (seg) {\n      return createElement(\"div\", {\n        className: \"fc-timegrid-event-harness\",\n        key: seg.eventRange.instance.instanceId\n      }, createElement(TimeColEvent, __assign({\n        seg: seg,\n        isDragging: false,\n        isResizing: false,\n        isDateSelecting: false,\n        isSelected: false,\n        isCondensed: false\n      }, getSegMeta(seg, props.todayRange, props.nowDate))));\n    });\n  };\n\n  TimeCol.prototype.renderPositionedFgSegs = function (segs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n    var _this = this;\n\n    var _a = this,\n        context = _a.context,\n        props = _a.props; // assigns TO THE SEGS THEMSELVES\n    // also, receives resorted array\n\n\n    segs = computeSegCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight, context.options.eventOrder);\n    return segs.map(function (seg) {\n      var instanceId = seg.eventRange.instance.instanceId;\n      var isMirror = isDragging || isResizing || isDateSelecting;\n      var positionCss = isMirror // will span entire column width\n      // also, won't assign z-index, which is good, fc-event-mirror will overpower other harnesses\n      ? __assign({\n        left: 0,\n        right: 0\n      }, _this.computeSegTopBottomCss(seg)) : _this.computeFgSegPositionCss(seg);\n      return createElement(\"div\", {\n        className: 'fc-timegrid-event-harness' + (seg.level > 0 ? ' fc-timegrid-event-harness-inset' : ''),\n        key: instanceId,\n        style: __assign({\n          visibility: segIsInvisible[instanceId] ? 'hidden' : ''\n        }, positionCss)\n      }, createElement(TimeColEvent, __assign({\n        seg: seg,\n        isDragging: isDragging,\n        isResizing: isResizing,\n        isDateSelecting: isDateSelecting,\n        isSelected: instanceId === props.eventSelection,\n        isCondensed: seg.bottom - seg.top < config.timeGridEventCondensedHeight\n      }, getSegMeta(seg, props.todayRange, props.nowDate))));\n    });\n  };\n\n  TimeCol.prototype.renderFillSegs = function (segs, fillType) {\n    var _this = this;\n\n    var _a = this,\n        context = _a.context,\n        props = _a.props;\n\n    if (!props.slatCoords) {\n      return null;\n    } // BAD: assigns TO THE SEGS THEMSELVES\n\n\n    computeSegVerticals(segs, props.date, props.slatCoords, context.options.eventMinHeight);\n    var children = segs.map(function (seg) {\n      return createElement(\"div\", {\n        key: buildEventRangeKey(seg.eventRange),\n        className: \"fc-timegrid-bg-harness\",\n        style: _this.computeSegTopBottomCss(seg)\n      }, fillType === 'bg-event' ? createElement(BgEvent, __assign({\n        seg: seg\n      }, getSegMeta(seg, props.todayRange, props.nowDate))) : renderFill(fillType));\n    });\n    return createElement(Fragment, null, children);\n  };\n\n  TimeCol.prototype.renderNowIndicator = function (segs) {\n    var _a = this.props,\n        slatCoords = _a.slatCoords,\n        date = _a.date;\n\n    if (!slatCoords) {\n      return null;\n    }\n\n    return segs.map(function (seg, i) {\n      return createElement(NowIndicatorRoot, {\n        isAxis: false,\n        date: date,\n        // key doesn't matter. will only ever be one\n        key: i\n      }, function (rootElRef, classNames, innerElRef, innerContent) {\n        return createElement(\"div\", {\n          ref: rootElRef,\n          className: ['fc-timegrid-now-indicator-line'].concat(classNames).join(' '),\n          style: {\n            top: slatCoords.computeDateTop(seg.start, date)\n          }\n        }, innerContent);\n      });\n    });\n  };\n\n  TimeCol.prototype.computeFgSegPositionCss = function (seg) {\n    var _a = this.context,\n        isRtl = _a.isRtl,\n        options = _a.options;\n    var shouldOverlap = options.slotEventOverlap;\n    var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point\n\n    var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point\n\n    var left; // amount of space from left edge, a fraction of the total width\n\n    var right; // amount of space from right edge, a fraction of the total width\n\n    if (shouldOverlap) {\n      // double the width, but don't go beyond the maximum forward coordinate (1.0)\n      forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);\n    }\n\n    if (isRtl) {\n      left = 1 - forwardCoord;\n      right = backwardCoord;\n    } else {\n      left = backwardCoord;\n      right = 1 - forwardCoord;\n    }\n\n    var props = {\n      zIndex: seg.level + 1,\n      left: left * 100 + '%',\n      right: right * 100 + '%'\n    };\n\n    if (shouldOverlap && seg.forwardPressure) {\n      // add padding to the edge so that forward stacked events don't cover the resizer's icon\n      props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n    }\n\n    return __assign(__assign({}, props), this.computeSegTopBottomCss(seg));\n  };\n\n  TimeCol.prototype.computeSegTopBottomCss = function (seg) {\n    return {\n      top: seg.top,\n      bottom: -seg.bottom\n    };\n  };\n\n  return TimeCol;\n}(BaseComponent);\n\nvar TimeColsContent =\n/** @class */\nfunction (_super) {\n  __extends(TimeColsContent, _super);\n\n  function TimeColsContent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.splitFgEventSegs = memoize(splitSegsByCol);\n    _this.splitBgEventSegs = memoize(splitSegsByCol);\n    _this.splitBusinessHourSegs = memoize(splitSegsByCol);\n    _this.splitNowIndicatorSegs = memoize(splitSegsByCol);\n    _this.splitDateSelectionSegs = memoize(splitSegsByCol);\n    _this.splitEventDrag = memoize(splitInteractionByCol);\n    _this.splitEventResize = memoize(splitInteractionByCol);\n    _this.rootElRef = createRef();\n    _this.cellElRefs = new RefMap();\n    return _this;\n  }\n\n  TimeColsContent.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void\n\n    var colCnt = props.cells.length;\n    var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n    var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n    var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n    var nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n    var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n    var eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n    var eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n    return createElement(\"div\", {\n      className: \"fc-timegrid-cols\",\n      ref: this.rootElRef\n    }, createElement(\"table\", {\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth\n      }\n    }, props.tableColGroupNode, createElement(\"tbody\", null, createElement(\"tr\", null, props.axis && createElement(\"td\", {\n      className: \"fc-timegrid-col fc-timegrid-axis\"\n    }, createElement(\"div\", {\n      className: \"fc-timegrid-col-frame\"\n    }, createElement(\"div\", {\n      className: \"fc-timegrid-now-indicator-container\"\n    }, typeof nowIndicatorTop === 'number' && createElement(NowIndicatorRoot, {\n      isAxis: true,\n      date: props.nowDate\n    }, function (rootElRef, classNames, innerElRef, innerContent) {\n      return createElement(\"div\", {\n        ref: rootElRef,\n        className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '),\n        style: {\n          top: nowIndicatorTop\n        }\n      }, innerContent);\n    })))), props.cells.map(function (cell, i) {\n      return createElement(TimeCol, {\n        key: cell.key,\n        elRef: _this.cellElRefs.createRef(cell.key),\n        dateProfile: props.dateProfile,\n        date: cell.date,\n        nowDate: props.nowDate,\n        todayRange: props.todayRange,\n        extraHookProps: cell.extraHookProps,\n        extraDataAttrs: cell.extraDataAttrs,\n        extraClassNames: cell.extraClassNames,\n        fgEventSegs: fgEventSegsByRow[i],\n        bgEventSegs: bgEventSegsByRow[i],\n        businessHourSegs: businessHourSegsByRow[i],\n        nowIndicatorSegs: nowIndicatorSegsByRow[i],\n        dateSelectionSegs: dateSelectionSegsByRow[i],\n        eventDrag: eventDragByRow[i],\n        eventResize: eventResizeByRow[i],\n        slatCoords: props.slatCoords,\n        eventSelection: props.eventSelection,\n        forPrint: props.forPrint\n      });\n    })))));\n  };\n\n  TimeColsContent.prototype.componentDidMount = function () {\n    this.updateCoords();\n  };\n\n  TimeColsContent.prototype.componentDidUpdate = function () {\n    this.updateCoords();\n  };\n\n  TimeColsContent.prototype.updateCoords = function () {\n    var props = this.props;\n\n    if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized\n    ) {\n      props.onColCoords(new PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, // horizontal\n      false));\n    }\n  };\n\n  return TimeColsContent;\n}(BaseComponent);\n\nfunction collectCellEls(elMap, cells) {\n  return cells.map(function (cell) {\n    return elMap[cell.key];\n  });\n}\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nvar TimeCols =\n/** @class */\nfunction (_super) {\n  __extends(TimeCols, _super);\n\n  function TimeCols() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.processSlotOptions = memoize(processSlotOptions);\n    _this.state = {\n      slatCoords: null\n    };\n\n    _this.handleScrollRequest = function (request) {\n      var onScrollTopRequest = _this.props.onScrollTopRequest;\n      var slatCoords = _this.state.slatCoords;\n\n      if (onScrollTopRequest && slatCoords) {\n        if (request.time) {\n          var top_1 = slatCoords.computeTimeTop(request.time);\n          top_1 = Math.ceil(top_1); // zoom can give weird floating-point values. rather scroll a little bit further\n\n          if (top_1) {\n            top_1 += 1; // to overcome top border that slots beyond the first have. looks better\n          }\n\n          onScrollTopRequest(top_1);\n        }\n\n        return true;\n      }\n\n      return false;\n    };\n\n    _this.handleColCoords = function (colCoords) {\n      _this.colCoords = colCoords;\n    };\n\n    _this.handleSlatCoords = function (slatCoords) {\n      _this.setState({\n        slatCoords: slatCoords\n      });\n\n      if (_this.props.onSlatCoords) {\n        _this.props.onSlatCoords(slatCoords);\n      }\n    };\n\n    return _this;\n  }\n\n  TimeCols.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    return createElement(\"div\", {\n      className: \"fc-timegrid-body\",\n      ref: props.rootElRef,\n      style: {\n        // these props are important to give this wrapper correct dimensions for interactions\n        // TODO: if we set it here, can we avoid giving to inner tables?\n        width: props.clientWidth,\n        minWidth: props.tableMinWidth\n      }\n    }, createElement(TimeColsSlats, {\n      axis: props.axis,\n      dateProfile: props.dateProfile,\n      slatMetas: props.slatMetas,\n      clientWidth: props.clientWidth,\n      minHeight: props.expandRows ? props.clientHeight : '',\n      tableMinWidth: props.tableMinWidth,\n      tableColGroupNode: props.axis ? props.tableColGroupNode : null\n      /* axis depends on the colgroup's shrinking */\n      ,\n      onCoords: this.handleSlatCoords\n    }), createElement(TimeColsContent, {\n      cells: props.cells,\n      axis: props.axis,\n      dateProfile: props.dateProfile,\n      businessHourSegs: props.businessHourSegs,\n      bgEventSegs: props.bgEventSegs,\n      fgEventSegs: props.fgEventSegs,\n      dateSelectionSegs: props.dateSelectionSegs,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      todayRange: props.todayRange,\n      nowDate: props.nowDate,\n      nowIndicatorSegs: props.nowIndicatorSegs,\n      clientWidth: props.clientWidth,\n      tableMinWidth: props.tableMinWidth,\n      tableColGroupNode: props.tableColGroupNode,\n      slatCoords: state.slatCoords,\n      onColCoords: this.handleColCoords,\n      forPrint: props.forPrint\n    }));\n  };\n\n  TimeCols.prototype.componentDidMount = function () {\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n  };\n\n  TimeCols.prototype.componentDidUpdate = function (prevProps) {\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n  };\n\n  TimeCols.prototype.componentWillUnmount = function () {\n    this.scrollResponder.detach();\n  };\n\n  TimeCols.prototype.positionToHit = function (positionLeft, positionTop) {\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        options = _a.options;\n    var colCoords = this.colCoords;\n    var dateProfile = this.props.dateProfile;\n    var slatCoords = this.state.slatCoords;\n\n    var _b = this.processSlotOptions(this.props.slotDuration, options.snapDuration),\n        snapDuration = _b.snapDuration,\n        snapsPerSlot = _b.snapsPerSlot;\n\n    var colIndex = colCoords.leftToIndex(positionLeft);\n    var slatIndex = slatCoords.positions.topToIndex(positionTop);\n\n    if (colIndex != null && slatIndex != null) {\n      var slatTop = slatCoords.positions.tops[slatIndex];\n      var slatHeight = slatCoords.positions.getHeight(slatIndex);\n      var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n\n      var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n\n      var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n      var dayDate = this.props.cells[colIndex].date;\n      var time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));\n      var start = dateEnv.add(dayDate, time);\n      var end = dateEnv.add(start, snapDuration);\n      return {\n        col: colIndex,\n        dateSpan: {\n          range: {\n            start: start,\n            end: end\n          },\n          allDay: false\n        },\n        dayEl: colCoords.els[colIndex],\n        relativeRect: {\n          left: colCoords.lefts[colIndex],\n          right: colCoords.rights[colIndex],\n          top: slatTop,\n          bottom: slatTop + slatHeight\n        }\n      };\n    }\n\n    return null;\n  };\n\n  return TimeCols;\n}(BaseComponent);\n\nfunction processSlotOptions(slotDuration, snapDurationOverride) {\n  var snapDuration = snapDurationOverride || slotDuration;\n  var snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);\n\n  if (snapsPerSlot === null) {\n    snapDuration = slotDuration;\n    snapsPerSlot = 1; // TODO: say warning?\n  }\n\n  return {\n    snapDuration: snapDuration,\n    snapsPerSlot: snapsPerSlot\n  };\n}\n\nvar DayTimeColsSlicer =\n/** @class */\nfunction (_super) {\n  __extends(DayTimeColsSlicer, _super);\n\n  function DayTimeColsSlicer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DayTimeColsSlicer.prototype.sliceRange = function (range, dayRanges) {\n    var segs = [];\n\n    for (var col = 0; col < dayRanges.length; col += 1) {\n      var segRange = intersectRanges(range, dayRanges[col]);\n\n      if (segRange) {\n        segs.push({\n          start: segRange.start,\n          end: segRange.end,\n          isStart: segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: segRange.end.valueOf() === range.end.valueOf(),\n          col: col\n        });\n      }\n    }\n\n    return segs;\n  };\n\n  return DayTimeColsSlicer;\n}(Slicer);\n\nvar DayTimeCols =\n/** @class */\nfunction (_super) {\n  __extends(DayTimeCols, _super);\n\n  function DayTimeCols() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildDayRanges = memoize(buildDayRanges);\n    _this.slicer = new DayTimeColsSlicer();\n    _this.timeColsRef = createRef();\n\n    _this.handleRootEl = function (rootEl) {\n      if (rootEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: rootEl\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    return _this;\n  }\n\n  DayTimeCols.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var dateProfile = props.dateProfile,\n        dayTableModel = props.dayTableModel;\n    var isNowIndicator = context.options.nowIndicator;\n    var dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv); // give it the first row of cells\n    // TODO: would move this further down hierarchy, but sliceNowDate needs it\n\n    return createElement(NowTimer, {\n      unit: isNowIndicator ? 'minute' : 'day'\n    }, function (nowDate, todayRange) {\n      return createElement(TimeCols, __assign({\n        ref: _this.timeColsRef,\n        rootElRef: _this.handleRootEl\n      }, _this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {\n        forPrint: props.forPrint,\n        axis: props.axis,\n        dateProfile: dateProfile,\n        slatMetas: props.slatMetas,\n        slotDuration: props.slotDuration,\n        cells: dayTableModel.cells[0],\n        tableColGroupNode: props.tableColGroupNode,\n        tableMinWidth: props.tableMinWidth,\n        clientWidth: props.clientWidth,\n        clientHeight: props.clientHeight,\n        expandRows: props.expandRows,\n        nowDate: nowDate,\n        nowIndicatorSegs: isNowIndicator && _this.slicer.sliceNowDate(nowDate, context, dayRanges),\n        todayRange: todayRange,\n        onScrollTopRequest: props.onScrollTopRequest,\n        onSlatCoords: props.onSlatCoords\n      }));\n    });\n  };\n\n  DayTimeCols.prototype.queryHit = function (positionLeft, positionTop) {\n    var rawHit = this.timeColsRef.current.positionToHit(positionLeft, positionTop);\n\n    if (rawHit) {\n      return {\n        component: this,\n        dateSpan: rawHit.dateSpan,\n        dayEl: rawHit.dayEl,\n        rect: {\n          left: rawHit.relativeRect.left,\n          right: rawHit.relativeRect.right,\n          top: rawHit.relativeRect.top,\n          bottom: rawHit.relativeRect.bottom\n        },\n        layer: 0\n      };\n    }\n\n    return null;\n  };\n\n  return DayTimeCols;\n}(DateComponent);\n\nfunction buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n  var ranges = [];\n\n  for (var _i = 0, _a = dayTableModel.headerDates; _i < _a.length; _i++) {\n    var date = _a[_i];\n    ranges.push({\n      start: dateEnv.add(date, dateProfile.slotMinTime),\n      end: dateEnv.add(date, dateProfile.slotMaxTime)\n    });\n  }\n\n  return ranges;\n} // potential nice values for the slot-duration and interval-duration\n// from largest to smallest\n\n\nvar STOCK_SUB_DURATIONS = [{\n  hours: 1\n}, {\n  minutes: 30\n}, {\n  minutes: 15\n}, {\n  seconds: 30\n}, {\n  seconds: 15\n}];\n\nfunction buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n  var dayStart = new Date(0);\n  var slatTime = slotMinTime;\n  var slatIterator = createDuration(0);\n  var labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n  var metas = [];\n\n  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {\n    var date = dateEnv.add(dayStart, slatTime);\n    var isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;\n    metas.push({\n      date: date,\n      time: slatTime,\n      key: date.toISOString(),\n      isoTimeStr: formatIsoTimeString(date),\n      isLabeled: isLabeled\n    });\n    slatTime = addDurations(slatTime, slotDuration);\n    slatIterator = addDurations(slatIterator, slotDuration);\n  }\n\n  return metas;\n} // Computes an automatic value for slotLabelInterval\n\n\nfunction computeLabelInterval(slotDuration) {\n  var i;\n  var labelInterval;\n  var slotsPerLabel; // find the smallest stock label interval that results in more than one slots-per-label\n\n  for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {\n    labelInterval = createDuration(STOCK_SUB_DURATIONS[i]);\n    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);\n\n    if (slotsPerLabel !== null && slotsPerLabel > 1) {\n      return labelInterval;\n    }\n  }\n\n  return slotDuration; // fall back\n}\n\nvar DayTimeColsView =\n/** @class */\nfunction (_super) {\n  __extends(DayTimeColsView, _super);\n\n  function DayTimeColsView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildTimeColsModel = memoize(buildTimeColsModel);\n    _this.buildSlatMetas = memoize(buildSlatMetas);\n    return _this;\n  }\n\n  DayTimeColsView.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.context,\n        options = _a.options,\n        dateEnv = _a.dateEnv,\n        dateProfileGenerator = _a.dateProfileGenerator;\n    var props = this.props;\n    var dateProfile = props.dateProfile;\n    var dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n    var splitProps = this.allDaySplitter.splitProps(props);\n    var slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n    var dayMinWidth = options.dayMinWidth;\n    var hasAttachedAxis = !dayMinWidth;\n    var hasDetachedAxis = dayMinWidth;\n    var headerContent = options.dayHeaders && createElement(DayHeader, {\n      dates: dayTableModel.headerDates,\n      dateProfile: dateProfile,\n      datesRepDistinctDays: true,\n      renderIntro: hasAttachedAxis ? this.renderHeadAxis : null\n    });\n\n    var allDayContent = options.allDaySlot !== false && function (contentArg) {\n      return createElement(DayTable, __assign({}, splitProps.allDay, {\n        dateProfile: dateProfile,\n        dayTableModel: dayTableModel,\n        nextDayThreshold: options.nextDayThreshold,\n        tableMinWidth: contentArg.tableMinWidth,\n        colGroupNode: contentArg.tableColGroupNode,\n        renderRowIntro: hasAttachedAxis ? _this.renderTableRowAxis : null,\n        showWeekNumbers: false,\n        expandRows: false,\n        headerAlignElRef: _this.headerElRef,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        forPrint: props.forPrint\n      }, _this.getAllDayMaxEventProps()));\n    };\n\n    var timeGridContent = function timeGridContent(contentArg) {\n      return createElement(DayTimeCols, __assign({}, splitProps.timed, {\n        dayTableModel: dayTableModel,\n        dateProfile: dateProfile,\n        axis: hasAttachedAxis,\n        slotDuration: options.slotDuration,\n        slatMetas: slatMetas,\n        forPrint: props.forPrint,\n        tableColGroupNode: contentArg.tableColGroupNode,\n        tableMinWidth: contentArg.tableMinWidth,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        onSlatCoords: _this.handleSlatCoords,\n        expandRows: contentArg.expandRows,\n        onScrollTopRequest: _this.handleScrollTopRequest\n      }));\n    };\n\n    return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n  };\n\n  return DayTimeColsView;\n}(TimeColsView);\n\nfunction buildTimeColsModel(dateProfile, dateProfileGenerator) {\n  var daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n  return new DayTableModel(daySeries, false);\n}\n\nvar OPTION_REFINERS = {\n  allDaySlot: Boolean\n};\nvar main = createPlugin({\n  initialView: 'timeGridWeek',\n  optionRefiners: OPTION_REFINERS,\n  views: {\n    timeGrid: {\n      component: DayTimeColsView,\n      usesMinMaxTime: true,\n      allDaySlot: true,\n      slotDuration: '00:30:00',\n      slotEventOverlap: true\n    },\n    timeGridDay: {\n      type: 'timeGrid',\n      duration: {\n        days: 1\n      }\n    },\n    timeGridWeek: {\n      type: 'timeGrid',\n      duration: {\n        weeks: 1\n      }\n    }\n  }\n});\nexport default main;\nexport { DayTimeCols, DayTimeColsSlicer, DayTimeColsView, TimeCols, TimeColsSlatsCoords, TimeColsView, buildDayRanges, buildSlatMetas, buildTimeColsModel };","map":{"version":3,"mappings":"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","names":["__extends","AllDaySplitter","allDay","timed","dateSpan","eventDef","hasBgRendering","Splitter","DEFAULT_SLAT_LABEL_FORMAT","createFormatter","hour","minute","omitZeroMinute","meridiem","TimeColsAxisCell","props","classNames","isLabeled","createElement","ViewContextType","Consumer","context","className","join","isoTimeStr","options","viewApi","labelFormat","slotLabelFormat","Array","isArray","hookProps","level","time","date","dateEnv","toDate","view","text","format","RenderHook","slotLabelClassNames","content","slotLabelContent","defaultContent","renderInnerContent","didMount","slotLabelDidMount","willUnmount","slotLabelWillUnmount","rootElRef","customClassNames","innerElRef","innerContent","ref","concat","TimeBodyAxis","slatMetas","map","slatMeta","key","__assign","BaseComponent","DEFAULT_WEEK_NUM_FORMAT","week","AUTO_ALL_DAY_MAX_EVENT_ROWS","_this","createRef","slatCoords","scrollTop","scrollerEl","scrollerElRef","current","rowKey","frameHeight","dateProfile","range","renderRange","dayCnt","diffDays","start","end","navLinkAttrs","navLinks","buildNavLinkData","tabIndex","weekNumbers","WeekNumberRoot","defaultFormat","style","height","rowHeight","allDayText","allDayClassNames","allDayContent","renderAllDayInner","allDayDidMount","allDayWillUnmount","setState","TimeColsView","headerRowContent","timeContent","sections","stickyHeaderDates","getStickyHeaderDates","push","type","isSticky","chunk","elRef","headerElRef","tableClassName","rowContent","outerContent","theme","getClass","liquid","expandRows","Boolean","ViewRoot","viewSpec","SimpleScrollGrid","isHeightAuto","forPrint","collapsibleWidth","cols","width","colCnt","dayMinWidth","ScrollGrid","pluginHooks","scrollGridImpl","Error","stickyFooterScrollbar","getStickyFooterScrollbar","syncRowHeights","chunks","arg","renderHeadAxis","rowSyncHeights","contentArg","renderTableRowAxis","colSpan","isNowIndicator","nowIndicator","clientHeight","tableColGroupNode","NowTimer","unit","nowDate","nowIndicatorTop","safeComputeTop","NowIndicatorRoot","isAxis","top","renderScrollShim","colGroups","span","minWidth","dayMaxEvents","dayMaxEventRows","undefined","DateComponent","positions","slotDuration","TimeColsSlatsCoords","rangeContainsMarker","currentRange","startOfDayDate","startOfDay","timeMs","valueOf","asRoughMs","slotMinTime","slotMaxTime","computeTimeTop","createDuration","when","duration","len","els","length","slatCoverage","milliseconds","slatIndex","slatRemainder","Math","max","min","floor","tops","getHeight","TimeColsSlatsBody","i","slatElRefs","axis","slotLaneClassNames","slotLaneContent","slotLaneDidMount","slotLaneWillUnmount","RefMap","TimeColsSlats","tableMinWidth","clientWidth","minHeight","updateSizing","onCoords","rootEl","offsetHeight","PositionCache","collectSlatEls","currentMap","elMap","splitSegsByCol","segs","segsByCol","col","splitInteractionByCol","ui","byRow","affectedInstances","isEvent","_i","seg","computeSegCoords","dayDate","eventMinHeight","eventOrderSpecs","computeSegVerticals","computeSegHorizontals","computeDateTop","bottom","forwardCoord","backwardCoord","forwardPressure","sortEventSegs","level0","levels","buildSlotSegLevels","computeForwardSlotSegs","_a","computeSlotSegPressures","_b","computeSegForwardBack","j","computeSlotSegCollisions","otherSegs","results","isSlotSegCollision","seg1","seg2","k","forwardSegs","forwardSeg","seriesBackwardPressure","seriesBackwardCoord","sortForwardSegs","objs","buildTimeGridSegCompareObj","specs","field","order","sort","obj0","obj1","c","_seg","obj","buildSegCompareObj","DEFAULT_TIME_FORMAT","TimeColEvent","isCondensed","StandardEvent","defaultTimeFormat","extraClassNames","TimeColMisc","DayCellContent","todayRange","extraHookProps","config","timeGridEventCondensedHeight","TimeCol","isSelectMirror","selectMirror","mirrorSegs","eventDrag","eventResize","dateSelectionSegs","interactionAffectedInstances","DayCellRoot","dataAttrs","extraDataAttrs","renderFillSegs","businessHourSegs","bgEventSegs","renderFgSegs","fgEventSegs","renderNowIndicator","nowIndicatorSegs","segIsInvisible","isDragging","isResizing","isDateSelecting","renderPrintFgSegs","renderPositionedFgSegs","eventOrder","eventRange","instance","instanceId","isSelected","getSegMeta","isMirror","positionCss","left","right","computeSegTopBottomCss","computeFgSegPositionCss","visibility","eventSelection","fillType","children","buildEventRangeKey","BgEvent","renderFill","Fragment","isRtl","shouldOverlap","slotEventOverlap","zIndex","memoize","TimeColsContent","cells","fgEventSegsByRow","splitFgEventSegs","bgEventSegsByRow","splitBgEventSegs","businessHourSegsByRow","splitBusinessHourSegs","nowIndicatorSegsByRow","splitNowIndicatorSegs","dateSelectionSegsByRow","splitDateSelectionSegs","eventDragByRow","splitEventDrag","eventResizeByRow","splitEventResize","cell","cellElRefs","updateCoords","onColCoords","collectCellEls","processSlotOptions","request","onScrollTopRequest","state","top_1","ceil","colCoords","onSlatCoords","TimeCols","handleSlatCoords","handleColCoords","scrollResponder","createScrollResponder","handleScrollRequest","prevProps","update","detach","positionLeft","positionTop","snapDuration","snapsPerSlot","colIndex","leftToIndex","topToIndex","slatTop","slatHeight","partial","localSnapIndex","snapIndex","addDurations","multiplyDuration","add","dayEl","relativeRect","lefts","rights","snapDurationOverride","wholeDivideDurations","DayTimeColsSlicer","dayRanges","segRange","intersectRanges","isStart","isEnd","Slicer","buildDayRanges","registerInteractiveComponent","el","unregisterInteractiveComponent","DayTimeCols","dayTableModel","timeColsRef","handleRootEl","slicer","sliceProps","sliceNowDate","rawHit","positionToHit","component","rect","layer","ranges","headerDates","STOCK_SUB_DURATIONS","hours","minutes","seconds","buildSlatMetas","explicitLabelInterval","dayStart","Date","slatTime","slatIterator","labelInterval","computeLabelInterval","metas","toISOString","formatIsoTimeString","slotsPerLabel","buildTimeColsModel","DayTimeColsView","dateProfileGenerator","splitProps","allDaySplitter","slotLabelInterval","hasAttachedAxis","hasDetachedAxis","headerContent","dayHeaders","DayHeader","dates","datesRepDistinctDays","renderIntro","allDaySlot","DayTable","nextDayThreshold","colGroupNode","renderRowIntro","showWeekNumbers","headerAlignElRef","getAllDayMaxEventProps","timeGridContent","handleScrollTopRequest","renderHScrollLayout","renderSimpleLayout","daySeries","DaySeriesModel","DayTableModel","OPTION_REFINERS","createPlugin","initialView","optionRefiners","views","timeGrid","usesMinMaxTime","timeGridDay","days","timeGridWeek","weeks"],"sources":["src/AllDaySplitter.ts","src/TimeColsAxisCell.tsx","src/TimeBodyAxis.tsx","src/TimeColsView.tsx","src/TimeColsSlatsCoords.ts","src/TimeColsSlatsBody.tsx","src/TimeColsSlats.tsx","src/TimeColsSeg.ts","src/event-placement.ts","src/TimeColEvent.tsx","src/TimeColMisc.tsx","src/TimeCol.tsx","src/TimeColsContent.tsx","src/TimeCols.tsx","src/DayTimeColsSlicer.ts","src/DayTimeCols.tsx","src/time-slat-meta.ts","src/DayTimeColsView.tsx","src/options.ts","src/main.ts"],"sourcesContent":["import {\n  Splitter,\n  hasBgRendering,\n  EventDef,\n  DateSpan,\n} from '@fullcalendar/common'\n\nexport class AllDaySplitter extends Splitter {\n  getKeyInfo() {\n    return {\n      allDay: {},\n      timed: {},\n    }\n  }\n\n  getKeysForDateSpan(dateSpan: DateSpan): string[] {\n    if (dateSpan.allDay) {\n      return ['allDay']\n    }\n\n    return ['timed']\n  }\n\n  getKeysForEventDef(eventDef: EventDef): string[] {\n    if (!eventDef.allDay) {\n      return ['timed']\n    }\n\n    if (hasBgRendering(eventDef)) {\n      return ['timed', 'allDay']\n    }\n\n    return ['allDay']\n  }\n}\n","import {\n  createElement,\n  ViewContext,\n  createFormatter,\n  ViewContextType,\n  RenderHook,\n  SlotLabelContentArg,\n} from '@fullcalendar/common'\nimport { TimeSlatMeta } from './time-slat-meta'\n\nconst DEFAULT_SLAT_LABEL_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'short',\n})\n\nexport function TimeColsAxisCell(props: TimeSlatMeta) {\n  let classNames = [\n    'fc-timegrid-slot',\n    'fc-timegrid-slot-label',\n    props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor',\n  ]\n\n  return (\n    <ViewContextType.Consumer>\n      {(context: ViewContext) => {\n        if (!props.isLabeled) {\n          return (\n            <td className={classNames.join(' ')} data-time={props.isoTimeStr} />\n          )\n        }\n\n        let { dateEnv, options, viewApi } = context\n        let labelFormat = // TODO: fully pre-parse\n          options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT :\n            Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) :\n              createFormatter(options.slotLabelFormat)\n\n        let hookProps: SlotLabelContentArg = {\n          level: 0,\n          time: props.time,\n          date: dateEnv.toDate(props.date),\n          view: viewApi,\n          text: dateEnv.format(props.date, labelFormat),\n        }\n\n        return (\n          <RenderHook<SlotLabelContentArg> // needed?\n            hookProps={hookProps}\n            classNames={options.slotLabelClassNames}\n            content={options.slotLabelContent}\n            defaultContent={renderInnerContent}\n            didMount={options.slotLabelDidMount}\n            willUnmount={options.slotLabelWillUnmount}\n          >\n            {(rootElRef, customClassNames, innerElRef, innerContent) => (\n              <td ref={rootElRef} className={classNames.concat(customClassNames).join(' ')} data-time={props.isoTimeStr}>\n                <div className=\"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\">\n                  <div className=\"fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion\" ref={innerElRef}>\n                    {innerContent}\n                  </div>\n                </div>\n              </td>\n            )}\n          </RenderHook>\n        )\n      }}\n    </ViewContextType.Consumer>\n  )\n}\n\nfunction renderInnerContent(props) { // TODO: add types\n  return props.text\n}\n","import { createElement, BaseComponent } from '@fullcalendar/common'\nimport { TimeColsAxisCell } from './TimeColsAxisCell'\nimport { TimeSlatMeta } from './time-slat-meta'\n\n/* Thin Axis\n------------------------------------------------------------------------------------------------------------------*/\n\ninterface TimeBodyAxisProps {\n  slatMetas: TimeSlatMeta[]\n}\n\nexport class TimeBodyAxis extends BaseComponent<TimeBodyAxisProps> { // just <tr> content\n  render() {\n    return this.props.slatMetas.map((slatMeta: TimeSlatMeta) => (\n      <tr key={slatMeta.key}>\n        <TimeColsAxisCell {...slatMeta} />\n      </tr>\n    ))\n  }\n}\n","import {\n  createElement, createRef,\n  diffDays,\n  SimpleScrollGridSection,\n  VNode,\n  SimpleScrollGrid,\n  ChunkContentCallbackArgs,\n  ScrollGridSectionConfig,\n  buildNavLinkData,\n  ViewRoot,\n  WeekNumberRoot,\n  RenderHook,\n  DateComponent,\n  ViewProps,\n  RefObject,\n  renderScrollShim,\n  getStickyHeaderDates,\n  getStickyFooterScrollbar,\n  createFormatter,\n  AllDayContentArg,\n  CssDimValue,\n  NowTimer,\n  DateMarker,\n  NowIndicatorRoot,\n} from '@fullcalendar/common'\nimport { AllDaySplitter } from './AllDaySplitter'\nimport { TimeSlatMeta } from './time-slat-meta'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { TimeBodyAxis } from './TimeBodyAxis'\n\nconst DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: 'short' })\nconst AUTO_ALL_DAY_MAX_EVENT_ROWS = 5\n\n/* An abstract class for all timegrid-related views. Displays one more columns with time slots running vertically.\n----------------------------------------------------------------------------------------------------------------------*/\n// Is a manager for the TimeCols subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).\n// Responsible for managing width/height.\n\ninterface TimeColsViewState {\n  slatCoords: TimeColsSlatsCoords | null\n}\n\nexport abstract class TimeColsView extends DateComponent<ViewProps, TimeColsViewState> {\n  protected allDaySplitter = new AllDaySplitter() // for use by subclasses\n\n  protected headerElRef: RefObject<HTMLTableCellElement> = createRef<HTMLTableCellElement>()\n  private rootElRef: RefObject<HTMLDivElement> = createRef<HTMLDivElement>()\n  private scrollerElRef: RefObject<HTMLDivElement> = createRef<HTMLDivElement>()\n\n  state = {\n    slatCoords: null,\n  }\n\n  // rendering\n  // ----------------------------------------------------------------------------------------------------\n\n  renderSimpleLayout(\n    headerRowContent: VNode | null,\n    allDayContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n    timeContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n  ) {\n    let { context, props } = this\n    let sections: SimpleScrollGridSection[] = []\n    let stickyHeaderDates = getStickyHeaderDates(context.options)\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent,\n        },\n      })\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        chunk: { content: allDayContent },\n      })\n      sections.push({\n        type: 'body',\n        key: 'all-day-divider',\n        outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?\n          <tr className=\"fc-scrollgrid-section\">\n            <td\n              className={'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')}\n            />\n          </tr>\n        ),\n      })\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunk: {\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent,\n      },\n    })\n\n    return (\n      <ViewRoot viewSpec={context.viewSpec} elRef={this.rootElRef}>\n        {(rootElRef, classNames) => (\n          <div className={['fc-timegrid'].concat(classNames).join(' ')} ref={rootElRef}>\n            <SimpleScrollGrid\n              liquid={!props.isHeightAuto && !props.forPrint}\n              collapsibleWidth={props.forPrint}\n              cols={[{ width: 'shrink' }]}\n              sections={sections}\n            />\n          </div>\n        )}\n      </ViewRoot>\n    )\n  }\n\n  renderHScrollLayout(\n    headerRowContent: VNode | null,\n    allDayContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n    timeContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n    colCnt: number,\n    dayMinWidth: number,\n    slatMetas: TimeSlatMeta[],\n    slatCoords: TimeColsSlatsCoords | null, // yuck\n  ) {\n    let ScrollGrid = this.context.pluginHooks.scrollGridImpl\n\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation')\n    }\n\n    let { context, props } = this\n    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options)\n    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options)\n    let sections: ScrollGridSectionConfig[] = []\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        syncRowHeights: true,\n        chunks: [\n          {\n            key: 'axis',\n            rowContent: (arg: ChunkContentCallbackArgs) => (\n              <tr>{this.renderHeadAxis('day', arg.rowSyncHeights[0])}</tr>\n            ),\n          },\n          {\n            key: 'cols',\n            elRef: this.headerElRef,\n            tableClassName: 'fc-col-header',\n            rowContent: headerRowContent,\n          },\n        ],\n      })\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        syncRowHeights: true,\n        chunks: [\n          {\n            key: 'axis',\n            rowContent: (contentArg: ChunkContentCallbackArgs) => (\n              <tr>{this.renderTableRowAxis(contentArg.rowSyncHeights[0])}</tr>\n            ),\n          },\n          {\n            key: 'cols',\n            content: allDayContent,\n          },\n        ],\n      })\n      sections.push({\n        key: 'all-day-divider',\n        type: 'body',\n        outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?\n          <tr className=\"fc-scrollgrid-section\">\n            <td\n              colSpan={2}\n              className={'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')}\n            />\n          </tr>\n        ),\n      })\n    }\n\n    let isNowIndicator = context.options.nowIndicator\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunks: [\n        {\n          key: 'axis',\n          content: (arg) => (\n            // TODO: make this now-indicator arrow more DRY with TimeColsContent\n            <div className=\"fc-timegrid-axis-chunk\">\n              <table style={{ height: arg.expandRows ? arg.clientHeight : '' }}>\n                {arg.tableColGroupNode}\n                <tbody>\n                  <TimeBodyAxis slatMetas={slatMetas} />\n                </tbody>\n              </table>\n              <div className=\"fc-timegrid-now-indicator-container\">\n                <NowTimer unit={isNowIndicator ? 'minute' : 'day' /* hacky */}>\n                  {(nowDate: DateMarker) => {\n                    let nowIndicatorTop =\n                      isNowIndicator &&\n                      slatCoords &&\n                      slatCoords.safeComputeTop(nowDate) // might return void\n\n                    if (typeof nowIndicatorTop === 'number') {\n                      return (\n                        <NowIndicatorRoot isAxis date={nowDate}>\n                          {(rootElRef, classNames, innerElRef, innerContent) => (\n                            <div\n                              ref={rootElRef}\n                              className={['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' ')}\n                              style={{ top: nowIndicatorTop }}\n                            >\n                              {innerContent}\n                            </div>\n                          )}\n                        </NowIndicatorRoot>\n                      )\n                    }\n\n                    return null\n                  }}\n                </NowTimer>\n              </div>\n            </div>\n          ),\n        },\n        {\n          key: 'cols',\n          scrollerElRef: this.scrollerElRef,\n          content: timeContent,\n        },\n      ],\n    })\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        key: 'footer',\n        type: 'footer',\n        isSticky: true,\n        chunks: [\n          {\n            key: 'axis',\n            content: renderScrollShim,\n          },\n          {\n            key: 'cols',\n            content: renderScrollShim,\n          },\n        ],\n      })\n    }\n\n    return (\n      <ViewRoot viewSpec={context.viewSpec} elRef={this.rootElRef}>\n        {(rootElRef, classNames) => (\n          <div className={['fc-timegrid'].concat(classNames).join(' ')} ref={rootElRef}>\n            <ScrollGrid\n              liquid={!props.isHeightAuto && !props.forPrint}\n              collapsibleWidth={false}\n              colGroups={[\n                { width: 'shrink', cols: [{ width: 'shrink' }] }, // TODO: allow no specify cols\n                { cols: [{ span: colCnt, minWidth: dayMinWidth }] },\n              ]}\n              sections={sections}\n            />\n          </div>\n        )}\n      </ViewRoot>\n    )\n  }\n\n  handleScrollTopRequest = (scrollTop: number) => {\n    let scrollerEl = this.scrollerElRef.current\n\n    if (scrollerEl) { // TODO: not sure how this could ever be null. weirdness with the reducer\n      scrollerEl.scrollTop = scrollTop\n    }\n  }\n\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n\n  getAllDayMaxEventProps() {\n    let { dayMaxEvents, dayMaxEventRows } = this.context.options\n\n    if (dayMaxEvents === true || dayMaxEventRows === true) { // is auto?\n      dayMaxEvents = undefined\n      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS // make sure \"auto\" goes to a real number\n    }\n\n    return { dayMaxEvents, dayMaxEventRows }\n  }\n\n  /* Header Render Methods\n  ------------------------------------------------------------------------------------------------------------------*/\n\n  renderHeadAxis = (rowKey: 'day' | string, frameHeight: CssDimValue = '') => {\n    let { options } = this.context\n    let { dateProfile } = this.props\n    let range = dateProfile.renderRange\n    let dayCnt = diffDays(range.start, range.end)\n\n    let navLinkAttrs = (options.navLinks && dayCnt === 1) // only do in day views (to avoid doing in week views that dont need it)\n      ? { 'data-navlink': buildNavLinkData(range.start, 'week'), tabIndex: 0 }\n      : {}\n\n    if (options.weekNumbers && rowKey === 'day') {\n      return (\n        <WeekNumberRoot date={range.start} defaultFormat={DEFAULT_WEEK_NUM_FORMAT}>\n          {(rootElRef, classNames, innerElRef, innerContent) => (\n            <th\n              ref={rootElRef}\n              className={[\n                'fc-timegrid-axis',\n                'fc-scrollgrid-shrink',\n              ].concat(classNames).join(' ')}\n            >\n              <div\n                className=\"fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid\"\n                style={{ height: frameHeight }}\n              >\n                <a\n                  ref={innerElRef}\n                  className=\"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\"\n                  {...navLinkAttrs}\n                >\n                  {innerContent}\n                </a>\n              </div>\n            </th>\n          )}\n        </WeekNumberRoot>\n      )\n    }\n\n    return (\n      <th className=\"fc-timegrid-axis\">\n        <div className=\"fc-timegrid-axis-frame\" style={{ height: frameHeight }} />\n      </th>\n    )\n  }\n\n  /* Table Component Render Methods\n  ------------------------------------------------------------------------------------------------------------------*/\n\n  // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n  // but DayGrid still needs to have classNames on inner elements in order to measure.\n  renderTableRowAxis = (rowHeight?: number) => {\n    let { options, viewApi } = this.context\n    let hookProps: AllDayContentArg = {\n      text: options.allDayText,\n      view: viewApi,\n    }\n\n    return (\n      // TODO: make reusable hook. used in list view too\n      <RenderHook<AllDayContentArg>\n        hookProps={hookProps}\n        classNames={options.allDayClassNames}\n        content={options.allDayContent}\n        defaultContent={renderAllDayInner}\n        didMount={options.allDayDidMount}\n        willUnmount={options.allDayWillUnmount}\n      >\n        {(rootElRef, classNames, innerElRef, innerContent) => (\n          <td\n            ref={rootElRef}\n            className={[\n              'fc-timegrid-axis',\n              'fc-scrollgrid-shrink',\n            ].concat(classNames).join(' ')}\n          >\n            <div\n              className={'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame' + (rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : '')}\n              style={{ height: rowHeight }}\n            >\n              <span className=\"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\" ref={innerElRef}>\n                {innerContent}\n              </span>\n            </div>\n          </td>\n        )}\n      </RenderHook>\n    )\n  }\n\n  handleSlatCoords = (slatCoords: TimeColsSlatsCoords) => {\n    this.setState({ slatCoords })\n  }\n}\n\nfunction renderAllDayInner(hookProps) {\n  return hookProps.text\n}\n","import {\n  PositionCache,\n  DateMarker,\n  startOfDay,\n  createDuration,\n  asRoughMs,\n  DateProfile,\n  Duration,\n  rangeContainsMarker,\n} from '@fullcalendar/common'\n\nexport class TimeColsSlatsCoords {\n  constructor(\n    public positions: PositionCache,\n    private dateProfile: DateProfile,\n    private slotDuration: Duration,\n  ) {\n  }\n\n  safeComputeTop(date: DateMarker) { // TODO: DRY with computeDateTop\n    let { dateProfile } = this\n\n    if (rangeContainsMarker(dateProfile.currentRange, date)) {\n      let startOfDayDate = startOfDay(date)\n      let timeMs = date.valueOf() - startOfDayDate.valueOf()\n\n      if (\n        timeMs >= asRoughMs(dateProfile.slotMinTime) &&\n        timeMs < asRoughMs(dateProfile.slotMaxTime)\n      ) {\n        return this.computeTimeTop(createDuration(timeMs))\n      }\n    }\n\n    return null\n  }\n\n  // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n  computeDateTop(when: DateMarker, startOfDayDate?: DateMarker) {\n    if (!startOfDayDate) {\n      startOfDayDate = startOfDay(when)\n    }\n    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()))\n  }\n\n  // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n  // Eventually allow computation with arbirary slat dates.\n  computeTimeTop(duration: Duration): number {\n    let { positions, dateProfile } = this\n    let len = positions.els.length\n\n    // floating-point value of # of slots covered\n    let slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration)\n    let slatIndex\n    let slatRemainder\n\n    // compute a floating-point number for how many slats should be progressed through.\n    // from 0 to number of slats (inclusive)\n    // constrained because slotMinTime/slotMaxTime might be customized.\n    slatCoverage = Math.max(0, slatCoverage)\n    slatCoverage = Math.min(len, slatCoverage)\n\n    // an integer index of the furthest whole slat\n    // from 0 to number slats (*exclusive*, so len-1)\n    slatIndex = Math.floor(slatCoverage)\n    slatIndex = Math.min(slatIndex, len - 1)\n\n    // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n    // could be 1.0 if slatCoverage is covering *all* the slots\n    slatRemainder = slatCoverage - slatIndex\n\n    return positions.tops[slatIndex] +\n      positions.getHeight(slatIndex) * slatRemainder\n  }\n}\n","import {\n  createElement,\n  BaseComponent,\n  RefMap,\n  RenderHook,\n  SlotLaneContentArg,\n} from '@fullcalendar/common'\nimport { TimeColsAxisCell } from './TimeColsAxisCell'\nimport { TimeSlatMeta } from './time-slat-meta'\n\nexport interface TimeColsSlatsBodyProps {\n  axis: boolean\n  slatMetas: TimeSlatMeta[]\n  slatElRefs: RefMap<HTMLTableRowElement>\n}\n\nexport class TimeColsSlatsBody extends BaseComponent<TimeColsSlatsBodyProps> {\n  render() {\n    let { props, context } = this\n    let { options } = context\n    let { slatElRefs } = props\n\n    return (\n      <tbody>\n        {props.slatMetas.map((slatMeta, i) => {\n          let hookProps: SlotLaneContentArg = {\n            time: slatMeta.time,\n            date: context.dateEnv.toDate(slatMeta.date),\n            view: context.viewApi,\n          }\n\n          let classNames = [\n            'fc-timegrid-slot',\n            'fc-timegrid-slot-lane',\n            slatMeta.isLabeled ? '' : 'fc-timegrid-slot-minor',\n          ]\n\n          return (\n            <tr\n              key={slatMeta.key}\n              ref={slatElRefs.createRef(slatMeta.key)}\n            >\n              {props.axis && (\n                <TimeColsAxisCell {...slatMeta} />\n              )}\n              <RenderHook\n                hookProps={hookProps}\n                classNames={options.slotLaneClassNames}\n                content={options.slotLaneContent}\n                didMount={options.slotLaneDidMount}\n                willUnmount={options.slotLaneWillUnmount}\n              >\n                {(rootElRef, customClassNames, innerElRef, innerContent) => (\n                  <td\n                    ref={rootElRef}\n                    className={classNames.concat(customClassNames).join(' ')}\n                    data-time={slatMeta.isoTimeStr}\n                  >\n                    {innerContent}\n                  </td>\n                )}\n              </RenderHook>\n            </tr>\n          )\n        })}\n      </tbody>\n    )\n  }\n}\n","import {\n  createElement,\n  VNode,\n  BaseComponent,\n  RefMap,\n  CssDimValue,\n  createRef,\n  PositionCache,\n  DateProfile,\n} from '@fullcalendar/common'\nimport { TimeSlatMeta } from './time-slat-meta'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { TimeColsSlatsBody } from './TimeColsSlatsBody'\n\nexport interface TimeColsSlatsProps extends TimeColsSlatsContentProps {\n  dateProfile: DateProfile\n  clientWidth: number | null\n  minHeight: CssDimValue\n  tableMinWidth: CssDimValue\n  tableColGroupNode: VNode\n  onCoords?: (coords: TimeColsSlatsCoords | null) => void\n}\n\ninterface TimeColsSlatsContentProps {\n  axis: boolean\n  slatMetas: TimeSlatMeta[]\n}\n\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/\n\nexport class TimeColsSlats extends BaseComponent<TimeColsSlatsProps> {\n  private rootElRef = createRef<HTMLDivElement>()\n  private slatElRefs = new RefMap<HTMLTableRowElement>()\n\n  render() {\n    let { props, context } = this\n\n    return (\n      <div className=\"fc-timegrid-slots\" ref={this.rootElRef}>\n        <table\n          className={context.theme.getClass('table')}\n          style={{\n            minWidth: props.tableMinWidth,\n            width: props.clientWidth,\n            height: props.minHeight,\n          }}\n        >\n          {props.tableColGroupNode /* relies on there only being a single <col> for the axis */}\n          <TimeColsSlatsBody\n            slatElRefs={this.slatElRefs}\n            axis={props.axis}\n            slatMetas={props.slatMetas}\n          />\n        </table>\n      </div>\n    )\n  }\n\n  componentDidMount() {\n    this.updateSizing()\n  }\n\n  componentDidUpdate() {\n    this.updateSizing()\n  }\n\n  componentWillUnmount() {\n    if (this.props.onCoords) {\n      this.props.onCoords(null)\n    }\n  }\n\n  updateSizing() {\n    let { context, props } = this\n\n    if (\n      props.onCoords &&\n      props.clientWidth !== null // means sizing has stabilized\n    ) {\n      let rootEl = this.rootElRef.current\n\n      if (rootEl.offsetHeight) { // not hidden by css\n        props.onCoords(\n          new TimeColsSlatsCoords(\n            new PositionCache(\n              this.rootElRef.current,\n              collectSlatEls(this.slatElRefs.currentMap, props.slatMetas),\n              false,\n              true, // vertical\n            ),\n            this.props.dateProfile,\n            context.options.slotDuration,\n          ),\n        )\n      }\n    }\n  }\n}\n\nfunction collectSlatEls(elMap: { [key: string]: HTMLElement }, slatMetas: TimeSlatMeta[]) {\n  return slatMetas.map((slatMeta) => elMap[slatMeta.key])\n}\n","import { DateMarker, Seg, EventSegUiInteractionState } from '@fullcalendar/common'\n\n// JUST A DATA STRUCTURE, not a component\n\nexport interface TimeColsSeg extends Seg {\n  col: number\n  start: DateMarker\n  end: DateMarker\n}\n\nexport function splitSegsByCol(segs: TimeColsSeg[] | null, colCnt: number) { // can be given null/undefined!\n  let segsByCol: TimeColsSeg[][] = []\n  let i\n\n  for (i = 0; i < colCnt; i += 1) {\n    segsByCol.push([])\n  }\n\n  if (segs) {\n    for (i = 0; i < segs.length; i += 1) {\n      segsByCol[segs[i].col].push(segs[i])\n    }\n  }\n\n  return segsByCol\n}\n\nexport function splitInteractionByCol(ui: EventSegUiInteractionState | null, colCnt: number) {\n  let byRow: EventSegUiInteractionState[] = []\n\n  if (!ui) {\n    for (let i = 0; i < colCnt; i += 1) {\n      byRow[i] = null\n    }\n  } else {\n    for (let i = 0; i < colCnt; i += 1) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: [],\n      }\n    }\n\n    for (let seg of ui.segs) {\n      byRow[seg.col].segs.push(seg)\n    }\n  }\n\n  return byRow\n}\n","import { Seg, DateMarker, buildSegCompareObj, compareByFieldSpecs, sortEventSegs, OrderSpec, EventApi } from '@fullcalendar/common'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\n\n// UNFORTUNATELY, assigns results to the top/bottom/level/forwardCoord/backwardCoord props of the actual segs.\n// TODO: return hash (by instanceId) of results\n\nexport function computeSegCoords(\n  segs: Seg[],\n  dayDate: DateMarker,\n  slatCoords: TimeColsSlatsCoords,\n  eventMinHeight: number,\n  eventOrderSpecs: OrderSpec<EventApi>[],\n) {\n  computeSegVerticals(segs, dayDate, slatCoords, eventMinHeight)\n  return computeSegHorizontals(segs, eventOrderSpecs) // requires top/bottom from computeSegVerticals\n}\n\n// For each segment in an array, computes and assigns its top and bottom properties\nexport function computeSegVerticals(segs: Seg[], dayDate: DateMarker, slatCoords: TimeColsSlatsCoords, eventMinHeight: number) {\n  for (let seg of segs) {\n    seg.top = slatCoords.computeDateTop(seg.start, dayDate)\n    seg.bottom = Math.max(\n      seg.top + (eventMinHeight || 0), // yuck\n      slatCoords.computeDateTop(seg.end, dayDate),\n    )\n  }\n}\n\n// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\n// Assumed the segs are already ordered.\n// NOTE: Also reorders the given array by date!\nfunction computeSegHorizontals(segs: Seg[], eventOrderSpecs: OrderSpec<EventApi>[]) {\n  // IMPORTANT TO CLEAR OLD RESULTS :(\n  for (let seg of segs) {\n    seg.level = null\n    seg.forwardCoord = null\n    seg.backwardCoord = null\n    seg.forwardPressure = null\n  }\n\n  segs = sortEventSegs(segs, eventOrderSpecs)\n\n  let level0\n  let levels = buildSlotSegLevels(segs)\n  computeForwardSlotSegs(levels)\n\n  if ((level0 = levels[0])) {\n    for (let seg of level0) {\n      computeSlotSegPressures(seg)\n    }\n\n    for (let seg of level0) {\n      computeSegForwardBack(seg, 0, 0, eventOrderSpecs)\n    }\n  }\n\n  return segs\n}\n\n// Builds an array of segments \"levels\". The first level will be the leftmost tier of segments if the calendar is\n// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\nfunction buildSlotSegLevels(segs: Seg[]) {\n  let levels = []\n  let i\n  let seg\n  let j\n\n  for (i = 0; i < segs.length; i += 1) {\n    seg = segs[i]\n\n    // go through all the levels and stop on the first level where there are no collisions\n    for (j = 0; j < levels.length; j += 1) {\n      if (!computeSlotSegCollisions(seg, levels[j]).length) {\n        break\n      }\n    }\n\n    seg.level = j;\n    (levels[j] || (levels[j] = [])).push(seg)\n  }\n\n  return levels\n}\n\n// Find all the segments in `otherSegs` that vertically collide with `seg`.\n// Append into an optionally-supplied `results` array and return.\nfunction computeSlotSegCollisions(seg: Seg, otherSegs: Seg[], results = []) {\n  for (let i = 0; i < otherSegs.length; i += 1) {\n    if (isSlotSegCollision(seg, otherSegs[i])) {\n      results.push(otherSegs[i])\n    }\n  }\n\n  return results\n}\n\n// Do these segments occupy the same vertical space?\nfunction isSlotSegCollision(seg1: Seg, seg2: Seg) {\n  return seg1.bottom > seg2.top && seg1.top < seg2.bottom\n}\n\n// For every segment, figure out the other segments that are in subsequent\n// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\nfunction computeForwardSlotSegs(levels) {\n  let i\n  let level\n  let j\n  let seg\n  let k\n\n  for (i = 0; i < levels.length; i += 1) {\n    level = levels[i]\n\n    for (j = 0; j < level.length; j += 1) {\n      seg = level[j]\n\n      seg.forwardSegs = []\n      for (k = i + 1; k < levels.length; k += 1) {\n        computeSlotSegCollisions(seg, levels[k], seg.forwardSegs)\n      }\n    }\n  }\n}\n\n// Figure out which path forward (via seg.forwardSegs) results in the longest path until\n// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\nfunction computeSlotSegPressures(seg: Seg) {\n  let forwardSegs = seg.forwardSegs\n  let forwardPressure = 0\n  let i\n  let forwardSeg\n\n  if (seg.forwardPressure == null) { // not already computed\n    for (i = 0; i < forwardSegs.length; i += 1) {\n      forwardSeg = forwardSegs[i]\n\n      // figure out the child's maximum forward path\n      computeSlotSegPressures(forwardSeg)\n\n      // either use the existing maximum, or use the child's forward pressure\n      // plus one (for the forwardSeg itself)\n      forwardPressure = Math.max(\n        forwardPressure,\n        1 + forwardSeg.forwardPressure,\n      )\n    }\n\n    seg.forwardPressure = forwardPressure\n  }\n}\n\n// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\n// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \"left\" and\n// seg.forwardCoord maps to \"right\" (via percentage). Vice-versa if the calendar is right-to-left.\n//\n// The segment might be part of a \"series\", which means consecutive segments with the same pressure\n// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\n// segments behind this one in the current series, and `seriesBackwardCoord` is the starting\n// coordinate of the first segment in the series.\nfunction computeSegForwardBack(seg: Seg, seriesBackwardPressure, seriesBackwardCoord, eventOrderSpecs) {\n  let forwardSegs = seg.forwardSegs\n  let i\n\n  if (seg.forwardCoord == null) { // not already computed\n    if (!forwardSegs.length) {\n      // if there are no forward segments, this segment should butt up against the edge\n      seg.forwardCoord = 1\n    } else {\n      // sort highest pressure first\n      sortForwardSegs(forwardSegs, eventOrderSpecs)\n\n      // this segment's forwardCoord will be calculated from the backwardCoord of the\n      // highest-pressure forward segment.\n      computeSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord, eventOrderSpecs)\n      seg.forwardCoord = forwardSegs[0].backwardCoord\n    }\n\n    // calculate the backwardCoord from the forwardCoord. consider the series\n    seg.backwardCoord = seg.forwardCoord -\n      (seg.forwardCoord - seriesBackwardCoord) / // available width for series\n      (seriesBackwardPressure + 1) // # of segments in the series\n\n    // use this segment's coordinates to computed the coordinates of the less-pressurized\n    // forward segments\n    for (i = 0; i < forwardSegs.length; i += 1) {\n      computeSegForwardBack(forwardSegs[i], 0, seg.forwardCoord, eventOrderSpecs)\n    }\n  }\n}\n\nfunction sortForwardSegs(forwardSegs: Seg[], eventOrderSpecs) {\n  let objs = forwardSegs.map(buildTimeGridSegCompareObj)\n\n  let specs = [\n    // put higher-pressure first\n    { field: 'forwardPressure', order: -1 },\n    // put segments that are closer to initial edge first (and favor ones with no coords yet)\n    { field: 'backwardCoord', order: 1 },\n  ].concat(eventOrderSpecs)\n\n  objs.sort((obj0, obj1) => compareByFieldSpecs(obj0, obj1, specs))\n\n  return objs.map((c) => c._seg)\n}\n\nfunction buildTimeGridSegCompareObj(seg: Seg): any {\n  let obj = buildSegCompareObj(seg) as any\n\n  obj.forwardPressure = seg.forwardPressure\n  obj.backwardCoord = seg.backwardCoord\n\n  return obj\n}\n","import { createElement, StandardEvent, BaseComponent, MinimalEventProps, createFormatter } from '@fullcalendar/common'\n\nconst DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  meridiem: false,\n})\n\nexport interface TimeColEventProps extends MinimalEventProps {\n  isCondensed: boolean\n}\n\nexport class TimeColEvent extends BaseComponent<TimeColEventProps> {\n  render() {\n    let classNames = [\n      'fc-timegrid-event',\n      'fc-v-event',\n    ]\n\n    if (this.props.isCondensed) {\n      classNames.push('fc-timegrid-event-condensed')\n    }\n\n    return (\n      <StandardEvent\n        {...this.props}\n        defaultTimeFormat={DEFAULT_TIME_FORMAT}\n        extraClassNames={classNames}\n      />\n    )\n  }\n}\n","import {\n  DateMarker, BaseComponent, createElement,\n  DateRange, DayCellContent, DateProfile,\n} from '@fullcalendar/common'\n\nexport interface TimeColMiscProps { // should be given nowDate too??\n  dateProfile: DateProfile\n  date: DateMarker\n  todayRange: DateRange\n  extraHookProps?: any\n}\n\nexport class TimeColMisc extends BaseComponent<TimeColMiscProps> {\n  render() {\n    let { props } = this\n\n    return (\n      <DayCellContent date={props.date} dateProfile={props.dateProfile} todayRange={props.todayRange} extraHookProps={props.extraHookProps}>\n        {(innerElRef, innerContent) => (\n          innerContent &&\n            <div className=\"fc-timegrid-col-misc\" ref={innerElRef}>{innerContent}</div>\n        )}\n      </DayCellContent>\n    )\n  }\n}\n","import {\n  Ref, DateMarker, BaseComponent, createElement, EventSegUiInteractionState, Seg, getSegMeta,\n  DateRange, Fragment, DayCellRoot, NowIndicatorRoot, BgEvent, renderFill,\n  DateProfile, config, buildEventRangeKey, sortEventSegs,\n} from '@fullcalendar/common'\nimport { TimeColsSeg } from './TimeColsSeg'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { computeSegCoords, computeSegVerticals } from './event-placement'\nimport { TimeColEvent } from './TimeColEvent'\nimport { TimeColMisc } from './TimeColMisc'\n\nexport interface TimeColProps {\n  elRef?: Ref<HTMLTableCellElement>\n  dateProfile: DateProfile\n  date: DateMarker\n  nowDate: DateMarker\n  todayRange: DateRange\n  extraDataAttrs?: any\n  extraHookProps?: any\n  extraClassNames?: string[]\n  fgEventSegs: TimeColsSeg[]\n  bgEventSegs: TimeColsSeg[]\n  businessHourSegs: TimeColsSeg[]\n  nowIndicatorSegs: TimeColsSeg[]\n  dateSelectionSegs: TimeColsSeg[]\n  eventSelection: string\n  eventDrag: EventSegUiInteractionState | null\n  eventResize: EventSegUiInteractionState | null\n  slatCoords: TimeColsSlatsCoords\n  forPrint: boolean\n}\n\nconfig.timeGridEventCondensedHeight = 30\n\nexport class TimeCol extends BaseComponent<TimeColProps> {\n  render() {\n    let { props, context } = this\n    let isSelectMirror = context.options.selectMirror\n\n    let mirrorSegs: Seg[] = // yuck\n      (props.eventDrag && props.eventDrag.segs) ||\n      (props.eventResize && props.eventResize.segs) ||\n      (isSelectMirror && props.dateSelectionSegs) ||\n      []\n\n    let interactionAffectedInstances = // TODO: messy way to compute this\n      (props.eventDrag && props.eventDrag.affectedInstances) ||\n      (props.eventResize && props.eventResize.affectedInstances) ||\n      {}\n\n    return (\n      <DayCellRoot\n        elRef={props.elRef}\n        date={props.date}\n        dateProfile={props.dateProfile}\n        todayRange={props.todayRange}\n        extraHookProps={props.extraHookProps}\n      >\n        {(rootElRef, classNames, dataAttrs) => (\n          <td\n            ref={rootElRef}\n            className={['fc-timegrid-col'].concat(classNames, props.extraClassNames || []).join(' ')}\n            {...dataAttrs}\n            {...props.extraDataAttrs}\n          >\n            <div className=\"fc-timegrid-col-frame\">\n              <div className=\"fc-timegrid-col-bg\">\n                {this.renderFillSegs(props.businessHourSegs, 'non-business')}\n                {this.renderFillSegs(props.bgEventSegs, 'bg-event')}\n                {this.renderFillSegs(props.dateSelectionSegs, 'highlight')}\n              </div>\n              <div className=\"fc-timegrid-col-events\">\n                {this.renderFgSegs(\n                  props.fgEventSegs,\n                  interactionAffectedInstances,\n                )}\n              </div>\n              <div className=\"fc-timegrid-col-events\">\n                {this.renderFgSegs(\n                  mirrorSegs as TimeColsSeg[],\n                  {},\n                  Boolean(props.eventDrag),\n                  Boolean(props.eventResize),\n                  Boolean(isSelectMirror),\n                  // TODO: pass in left/right instead of using only computeSegTopBottomCss\n                )}\n              </div>\n              <div className=\"fc-timegrid-now-indicator-container\">\n                {this.renderNowIndicator(props.nowIndicatorSegs)}\n              </div>\n              <TimeColMisc\n                date={props.date}\n                dateProfile={props.dateProfile}\n                todayRange={props.todayRange}\n                extraHookProps={props.extraHookProps}\n              />\n            </div>\n          </td>\n        )}\n      </DayCellRoot>\n    )\n  }\n\n  renderFgSegs(\n    segs: TimeColsSeg[],\n    segIsInvisible: { [instanceId: string]: any },\n    isDragging?: boolean,\n    isResizing?: boolean,\n    isDateSelecting?: boolean,\n  ) {\n    let { props } = this\n\n    if (props.forPrint) {\n      return this.renderPrintFgSegs(segs)\n    }\n\n    if (props.slatCoords) {\n      return this.renderPositionedFgSegs(segs, segIsInvisible, isDragging, isResizing, isDateSelecting)\n    }\n\n    return null\n  }\n\n  renderPrintFgSegs(segs: TimeColsSeg[]) {\n    let { props, context } = this\n\n    // not DRY\n    segs = sortEventSegs(segs, context.options.eventOrder) as TimeColsSeg[]\n\n    return segs.map((seg) => (\n      <div\n        className=\"fc-timegrid-event-harness\"\n        key={seg.eventRange.instance.instanceId}\n      >\n        <TimeColEvent\n          seg={seg}\n          isDragging={false}\n          isResizing={false}\n          isDateSelecting={false}\n          isSelected={false}\n          isCondensed={false}\n          {...getSegMeta(seg, props.todayRange, props.nowDate)}\n        />\n      </div>\n    ))\n  }\n\n  renderPositionedFgSegs(\n    segs: TimeColsSeg[],\n    segIsInvisible: { [instanceId: string]: any },\n    isDragging?: boolean,\n    isResizing?: boolean,\n    isDateSelecting?: boolean,\n  ) {\n    let { context, props } = this\n\n    // assigns TO THE SEGS THEMSELVES\n    // also, receives resorted array\n    segs = computeSegCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight, context.options.eventOrder) as TimeColsSeg[]\n\n    return segs.map((seg) => {\n      let instanceId = seg.eventRange.instance.instanceId\n      let isMirror = isDragging || isResizing || isDateSelecting\n      let positionCss = isMirror\n        // will span entire column width\n        // also, won't assign z-index, which is good, fc-event-mirror will overpower other harnesses\n        ? { left: 0, right: 0, ...this.computeSegTopBottomCss(seg) }\n        : this.computeFgSegPositionCss(seg)\n\n      return (\n        <div\n          className={'fc-timegrid-event-harness' + (seg.level > 0 ? ' fc-timegrid-event-harness-inset' : '')}\n          key={instanceId}\n          style={{\n            visibility: segIsInvisible[instanceId] ? 'hidden' : ('' as any),\n            ...positionCss,\n          }}\n        >\n          <TimeColEvent\n            seg={seg}\n            isDragging={isDragging}\n            isResizing={isResizing}\n            isDateSelecting={isDateSelecting}\n            isSelected={instanceId === props.eventSelection}\n            isCondensed={(seg.bottom - seg.top) < config.timeGridEventCondensedHeight}\n            {...getSegMeta(seg, props.todayRange, props.nowDate)}\n          />\n        </div>\n      )\n    })\n  }\n\n  renderFillSegs(segs: TimeColsSeg[], fillType: string) {\n    let { context, props } = this\n\n    if (!props.slatCoords) { return null }\n\n    // BAD: assigns TO THE SEGS THEMSELVES\n    computeSegVerticals(segs, props.date, props.slatCoords, context.options.eventMinHeight)\n\n    let children = segs.map((seg) => (\n      <div key={buildEventRangeKey(seg.eventRange)} className=\"fc-timegrid-bg-harness\" style={this.computeSegTopBottomCss(seg)}>\n        {fillType === 'bg-event' ?\n          <BgEvent seg={seg} {...getSegMeta(seg, props.todayRange, props.nowDate)} /> :\n          renderFill(fillType)}\n      </div>\n    ))\n\n    return <Fragment>{children}</Fragment>\n  }\n\n  renderNowIndicator(segs: TimeColsSeg[]) {\n    let { slatCoords, date } = this.props\n\n    if (!slatCoords) { return null }\n\n    return segs.map((seg, i) => (\n      <NowIndicatorRoot\n        isAxis={false}\n        date={date}\n        // key doesn't matter. will only ever be one\n        key={i} // eslint-disable-line react/no-array-index-key\n      >\n        {(rootElRef, classNames, innerElRef, innerContent) => (\n          <div\n            ref={rootElRef}\n            className={['fc-timegrid-now-indicator-line'].concat(classNames).join(' ')}\n            style={{ top: slatCoords.computeDateTop(seg.start, date) }}\n          >\n            {innerContent}\n          </div>\n        )}\n      </NowIndicatorRoot>\n    ))\n  }\n\n  computeFgSegPositionCss(seg) {\n    let { isRtl, options } = this.context\n    let shouldOverlap = options.slotEventOverlap\n    let backwardCoord = seg.backwardCoord // the left side if LTR. the right side if RTL. floating-point\n    let forwardCoord = seg.forwardCoord // the right side if LTR. the left side if RTL. floating-point\n    let left // amount of space from left edge, a fraction of the total width\n    let right // amount of space from right edge, a fraction of the total width\n\n    if (shouldOverlap) {\n      // double the width, but don't go beyond the maximum forward coordinate (1.0)\n      forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2)\n    }\n\n    if (isRtl) {\n      left = 1 - forwardCoord\n      right = backwardCoord\n    } else {\n      left = backwardCoord\n      right = 1 - forwardCoord\n    }\n\n    let props = {\n      zIndex: seg.level + 1, // convert from 0-base to 1-based\n      left: left * 100 + '%',\n      right: right * 100 + '%',\n    }\n\n    if (shouldOverlap && seg.forwardPressure) {\n      // add padding to the edge so that forward stacked events don't cover the resizer's icon\n      props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2 // 10 is a guesstimate of the icon's width\n    }\n\n    return { ...props, ...this.computeSegTopBottomCss(seg) }\n  }\n\n  computeSegTopBottomCss(seg) {\n    return {\n      top: seg.top,\n      bottom: -seg.bottom,\n    }\n  }\n}\n","import {\n  createElement, VNode,\n  BaseComponent,\n  EventSegUiInteractionState,\n  CssDimValue,\n  DateMarker,\n  RefMap,\n  createRef,\n  PositionCache,\n  memoize,\n  DateRange,\n  NowIndicatorRoot,\n  DateProfile,\n} from '@fullcalendar/common'\nimport { TableCellModel } from '@fullcalendar/daygrid' // TODO: good to use this interface?\nimport { TimeColsSeg, splitSegsByCol, splitInteractionByCol } from './TimeColsSeg'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { TimeCol } from './TimeCol'\n\nexport interface TimeColsContentProps {\n  axis: boolean\n  cells: TableCellModel[]\n  dateProfile: DateProfile\n  nowDate: DateMarker\n  todayRange: DateRange\n  businessHourSegs: TimeColsSeg[]\n  bgEventSegs: TimeColsSeg[]\n  fgEventSegs: TimeColsSeg[]\n  dateSelectionSegs: TimeColsSeg[]\n  eventSelection: string\n  eventDrag: EventSegUiInteractionState | null\n  eventResize: EventSegUiInteractionState | null\n  nowIndicatorSegs: TimeColsSeg[]\n  clientWidth: number | null\n  tableMinWidth: CssDimValue\n  tableColGroupNode: VNode\n  slatCoords: TimeColsSlatsCoords\n  onColCoords?: (colCoords: PositionCache) => void\n  forPrint: boolean\n}\n\nexport class TimeColsContent extends BaseComponent<TimeColsContentProps> { // TODO: rename\n  private splitFgEventSegs = memoize(splitSegsByCol)\n  private splitBgEventSegs = memoize(splitSegsByCol)\n  private splitBusinessHourSegs = memoize(splitSegsByCol)\n  private splitNowIndicatorSegs = memoize(splitSegsByCol)\n  private splitDateSelectionSegs = memoize(splitSegsByCol)\n  private splitEventDrag = memoize(splitInteractionByCol)\n  private splitEventResize = memoize(splitInteractionByCol)\n  private rootElRef = createRef<HTMLDivElement>()\n  private cellElRefs = new RefMap<HTMLTableCellElement>()\n\n  render() {\n    let { props, context } = this\n    let nowIndicatorTop =\n      context.options.nowIndicator &&\n      props.slatCoords &&\n      props.slatCoords.safeComputeTop(props.nowDate) // might return void\n\n    let colCnt = props.cells.length\n    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt)\n    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt)\n    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt)\n    let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt)\n    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt)\n    let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt)\n    let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt)\n\n    return (\n      <div className=\"fc-timegrid-cols\" ref={this.rootElRef}>\n        <table style={{\n          minWidth: props.tableMinWidth,\n          width: props.clientWidth,\n        }}\n        >\n          {props.tableColGroupNode}\n          <tbody>\n            <tr>\n              {props.axis && (\n                <td className=\"fc-timegrid-col fc-timegrid-axis\">\n                  <div className=\"fc-timegrid-col-frame\">\n                    <div className=\"fc-timegrid-now-indicator-container\">\n                      {typeof nowIndicatorTop === 'number' && (\n                        <NowIndicatorRoot isAxis date={props.nowDate}>\n                          {(rootElRef, classNames, innerElRef, innerContent) => (\n                            <div\n                              ref={rootElRef}\n                              className={['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' ')}\n                              style={{ top: nowIndicatorTop }}\n                            >\n                              {innerContent}\n                            </div>\n                          )}\n                        </NowIndicatorRoot>\n                      )}\n                    </div>\n                  </div>\n                </td>\n              )}\n              {props.cells.map((cell, i) => (\n                <TimeCol\n                  key={cell.key}\n                  elRef={this.cellElRefs.createRef(cell.key)}\n                  dateProfile={props.dateProfile}\n                  date={cell.date}\n                  nowDate={props.nowDate}\n                  todayRange={props.todayRange}\n                  extraHookProps={cell.extraHookProps}\n                  extraDataAttrs={cell.extraDataAttrs}\n                  extraClassNames={cell.extraClassNames}\n                  fgEventSegs={fgEventSegsByRow[i]}\n                  bgEventSegs={bgEventSegsByRow[i]}\n                  businessHourSegs={businessHourSegsByRow[i]}\n                  nowIndicatorSegs={nowIndicatorSegsByRow[i]}\n                  dateSelectionSegs={dateSelectionSegsByRow[i]}\n                  eventDrag={eventDragByRow[i]}\n                  eventResize={eventResizeByRow[i]}\n                  slatCoords={props.slatCoords}\n                  eventSelection={props.eventSelection}\n                  forPrint={props.forPrint}\n                />\n              ))}\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    )\n  }\n\n  componentDidMount() {\n    this.updateCoords()\n  }\n\n  componentDidUpdate() {\n    this.updateCoords()\n  }\n\n  updateCoords() {\n    let { props } = this\n\n    if (\n      props.onColCoords &&\n      props.clientWidth !== null // means sizing has stabilized\n    ) {\n      props.onColCoords(\n        new PositionCache(\n          this.rootElRef.current,\n          collectCellEls(this.cellElRefs.currentMap, props.cells),\n          true, // horizontal\n          false,\n        ),\n      )\n    }\n  }\n}\n\nfunction collectCellEls(elMap: { [key: string]: HTMLElement }, cells: TableCellModel[]) {\n  return cells.map((cell) => elMap[cell.key])\n}\n","import {\n  createElement, VNode, Ref,\n  addDurations,\n  multiplyDuration,\n  wholeDivideDurations,\n  DateMarker,\n  BaseComponent,\n  EventSegUiInteractionState,\n  memoize,\n  CssDimValue,\n  PositionCache,\n  ScrollResponder,\n  ScrollRequest,\n  DateRange,\n  Duration,\n  DateProfile,\n} from '@fullcalendar/common'\nimport { TableCellModel } from '@fullcalendar/daygrid' // TODO: good to use this interface?\nimport { TimeColsSlats } from './TimeColsSlats'\nimport { TimeSlatMeta } from './time-slat-meta'\nimport { TimeColsContent } from './TimeColsContent'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { TimeColsSeg } from './TimeColsSeg'\n\nexport interface TimeColsProps {\n  cells: TableCellModel[]\n  dateProfile: DateProfile\n  slotDuration: Duration\n  nowDate: DateMarker\n  todayRange: DateRange\n  businessHourSegs: TimeColsSeg[]\n  bgEventSegs: TimeColsSeg[]\n  fgEventSegs: TimeColsSeg[]\n  dateSelectionSegs: TimeColsSeg[]\n  eventSelection: string\n  eventDrag: EventSegUiInteractionState | null\n  eventResize: EventSegUiInteractionState | null\n  rootElRef?: Ref<HTMLDivElement>\n  tableColGroupNode: VNode\n  tableMinWidth: CssDimValue\n  clientWidth: number | null\n  clientHeight: number | null\n  expandRows: boolean\n  nowIndicatorSegs: TimeColsSeg[]\n  onScrollTopRequest?: (scrollTop: number) => void\n  forPrint: boolean\n  axis: boolean\n  slatMetas: TimeSlatMeta[]\n  onSlatCoords?: (slatCoords: TimeColsSlatsCoords) => void\n}\n\ninterface TimeColsState {\n  slatCoords: TimeColsSlatsCoords | null\n}\n\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\n\nexport class TimeCols extends BaseComponent<TimeColsProps, TimeColsState> {\n  private processSlotOptions = memoize(processSlotOptions)\n  private scrollResponder: ScrollResponder\n  private colCoords: PositionCache\n\n  state = {\n    slatCoords: null,\n  }\n\n  render() {\n    let { props, state } = this\n\n    return (\n      <div\n        className=\"fc-timegrid-body\"\n        ref={props.rootElRef}\n        style={{\n          // these props are important to give this wrapper correct dimensions for interactions\n          // TODO: if we set it here, can we avoid giving to inner tables?\n          width: props.clientWidth,\n          minWidth: props.tableMinWidth,\n        }}\n      >\n        <TimeColsSlats\n          axis={props.axis}\n          dateProfile={props.dateProfile}\n          slatMetas={props.slatMetas}\n          clientWidth={props.clientWidth}\n          minHeight={props.expandRows ? props.clientHeight : ''}\n          tableMinWidth={props.tableMinWidth}\n          tableColGroupNode={props.axis ? props.tableColGroupNode : null /* axis depends on the colgroup's shrinking */}\n          onCoords={this.handleSlatCoords}\n        />\n        <TimeColsContent\n          cells={props.cells}\n          axis={props.axis}\n          dateProfile={props.dateProfile}\n          businessHourSegs={props.businessHourSegs}\n          bgEventSegs={props.bgEventSegs}\n          fgEventSegs={props.fgEventSegs}\n          dateSelectionSegs={props.dateSelectionSegs}\n          eventSelection={props.eventSelection}\n          eventDrag={props.eventDrag}\n          eventResize={props.eventResize}\n          todayRange={props.todayRange}\n          nowDate={props.nowDate}\n          nowIndicatorSegs={props.nowIndicatorSegs}\n          clientWidth={props.clientWidth}\n          tableMinWidth={props.tableMinWidth}\n          tableColGroupNode={props.tableColGroupNode}\n          slatCoords={state.slatCoords}\n          onColCoords={this.handleColCoords}\n          forPrint={props.forPrint}\n        />\n      </div>\n    )\n  }\n\n  componentDidMount() {\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest)\n  }\n\n  componentDidUpdate(prevProps: TimeColsProps) {\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile)\n  }\n\n  componentWillUnmount() {\n    this.scrollResponder.detach()\n  }\n\n  handleScrollRequest = (request: ScrollRequest) => {\n    let { onScrollTopRequest } = this.props\n    let { slatCoords } = this.state\n\n    if (onScrollTopRequest && slatCoords) {\n      if (request.time) {\n        let top = slatCoords.computeTimeTop(request.time)\n        top = Math.ceil(top) // zoom can give weird floating-point values. rather scroll a little bit further\n        if (top) {\n          top += 1 // to overcome top border that slots beyond the first have. looks better\n        }\n\n        onScrollTopRequest(top)\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  handleColCoords = (colCoords: PositionCache | null) => {\n    this.colCoords = colCoords\n  }\n\n  handleSlatCoords = (slatCoords: TimeColsSlatsCoords | null) => {\n    this.setState({ slatCoords })\n\n    if (this.props.onSlatCoords) {\n      this.props.onSlatCoords(slatCoords)\n    }\n  }\n\n  positionToHit(positionLeft, positionTop) {\n    let { dateEnv, options } = this.context\n    let { colCoords } = this\n    let { dateProfile } = this.props\n    let { slatCoords } = this.state\n    let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration)\n\n    let colIndex = colCoords.leftToIndex(positionLeft)\n    let slatIndex = slatCoords.positions.topToIndex(positionTop)\n\n    if (colIndex != null && slatIndex != null) {\n      let slatTop = slatCoords.positions.tops[slatIndex]\n      let slatHeight = slatCoords.positions.getHeight(slatIndex)\n      let partial = (positionTop - slatTop) / slatHeight // floating point number between 0 and 1\n      let localSnapIndex = Math.floor(partial * snapsPerSlot) // the snap # relative to start of slat\n      let snapIndex = slatIndex * snapsPerSlot + localSnapIndex\n\n      let dayDate = this.props.cells[colIndex].date\n      let time = addDurations(\n        dateProfile.slotMinTime,\n        multiplyDuration(snapDuration, snapIndex),\n      )\n\n      let start = dateEnv.add(dayDate, time)\n      let end = dateEnv.add(start, snapDuration)\n\n      return {\n        col: colIndex,\n        dateSpan: {\n          range: { start, end },\n          allDay: false,\n        },\n        dayEl: colCoords.els[colIndex],\n        relativeRect: {\n          left: colCoords.lefts[colIndex],\n          right: colCoords.rights[colIndex],\n          top: slatTop,\n          bottom: slatTop + slatHeight,\n        },\n      }\n    }\n\n    return null\n  }\n}\n\nfunction processSlotOptions(slotDuration: Duration, snapDurationOverride: Duration | null) {\n  let snapDuration = snapDurationOverride || slotDuration\n  let snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration)\n\n  if (snapsPerSlot === null) {\n    snapDuration = slotDuration\n    snapsPerSlot = 1\n    // TODO: say warning?\n  }\n\n  return { snapDuration, snapsPerSlot }\n}\n","import { intersectRanges, DateRange, Slicer } from '@fullcalendar/common'\nimport { TimeColsSeg } from './TimeColsSeg'\n\nexport class DayTimeColsSlicer extends Slicer<TimeColsSeg, [DateRange[]]> {\n  sliceRange(range: DateRange, dayRanges: DateRange[]): TimeColsSeg[] {\n    let segs: TimeColsSeg[] = []\n\n    for (let col = 0; col < dayRanges.length; col += 1) {\n      let segRange = intersectRanges(range, dayRanges[col])\n\n      if (segRange) {\n        segs.push({\n          start: segRange.start,\n          end: segRange.end,\n          isStart: segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: segRange.end.valueOf() === range.end.valueOf(),\n          col,\n        })\n      }\n    }\n\n    return segs\n  }\n}\n","import {\n  createElement,\n  createRef,\n  VNode,\n  DateComponent,\n  DateProfile,\n  EventStore,\n  EventUiHash,\n  EventInteractionState,\n  DateSpan,\n  memoize,\n  DateRange,\n  DayTableModel,\n  DateEnv,\n  DateMarker,\n  Hit,\n  NowTimer,\n  CssDimValue,\n  Duration,\n} from '@fullcalendar/common'\nimport { TimeCols } from './TimeCols'\nimport { TimeSlatMeta } from './time-slat-meta'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { DayTimeColsSlicer } from './DayTimeColsSlicer'\n\nexport interface DayTimeColsProps {\n  dateProfile: DateProfile\n  dayTableModel: DayTableModel\n  axis: boolean\n  slotDuration: Duration\n  slatMetas: TimeSlatMeta[]\n  businessHours: EventStore\n  eventStore: EventStore\n  eventUiBases: EventUiHash\n  dateSelection: DateSpan | null\n  eventSelection: string\n  eventDrag: EventInteractionState | null\n  eventResize: EventInteractionState | null\n  tableColGroupNode: VNode\n  tableMinWidth: CssDimValue\n  clientWidth: number | null\n  clientHeight: number | null\n  expandRows: boolean\n  onScrollTopRequest?: (scrollTop: number) => void\n  forPrint: boolean\n  onSlatCoords?: (slatCoords: TimeColsSlatsCoords) => void\n}\n\nexport class DayTimeCols extends DateComponent<DayTimeColsProps> {\n  private buildDayRanges = memoize(buildDayRanges)\n  private slicer = new DayTimeColsSlicer()\n  private timeColsRef = createRef<TimeCols>()\n\n  render() {\n    let { props, context } = this\n    let { dateProfile, dayTableModel } = props\n\n    let isNowIndicator = context.options.nowIndicator\n    let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv)\n\n    // give it the first row of cells\n    // TODO: would move this further down hierarchy, but sliceNowDate needs it\n    return (\n      <NowTimer unit={isNowIndicator ? 'minute' : 'day'}>\n        {(nowDate: DateMarker, todayRange: DateRange) => (\n          <TimeCols\n            ref={this.timeColsRef}\n            rootElRef={this.handleRootEl}\n            {...this.slicer.sliceProps(props, dateProfile, null, context, dayRanges)}\n            forPrint={props.forPrint}\n            axis={props.axis}\n            dateProfile={dateProfile}\n            slatMetas={props.slatMetas}\n            slotDuration={props.slotDuration}\n            cells={dayTableModel.cells[0]}\n            tableColGroupNode={props.tableColGroupNode}\n            tableMinWidth={props.tableMinWidth}\n            clientWidth={props.clientWidth}\n            clientHeight={props.clientHeight}\n            expandRows={props.expandRows}\n            nowDate={nowDate}\n            nowIndicatorSegs={isNowIndicator && this.slicer.sliceNowDate(nowDate, context, dayRanges)}\n            todayRange={todayRange}\n            onScrollTopRequest={props.onScrollTopRequest}\n            onSlatCoords={props.onSlatCoords}\n          />\n        )}\n      </NowTimer>\n    )\n  }\n\n  handleRootEl = (rootEl: HTMLDivElement | null) => {\n    if (rootEl) {\n      this.context.registerInteractiveComponent(this, { el: rootEl })\n    } else {\n      this.context.unregisterInteractiveComponent(this)\n    }\n  }\n\n  queryHit(positionLeft: number, positionTop: number): Hit {\n    let rawHit = this.timeColsRef.current.positionToHit(positionLeft, positionTop)\n\n    if (rawHit) {\n      return {\n        component: this,\n        dateSpan: rawHit.dateSpan,\n        dayEl: rawHit.dayEl,\n        rect: {\n          left: rawHit.relativeRect.left,\n          right: rawHit.relativeRect.right,\n          top: rawHit.relativeRect.top,\n          bottom: rawHit.relativeRect.bottom,\n        },\n        layer: 0,\n      }\n    }\n\n    return null\n  }\n}\n\nexport function buildDayRanges(dayTableModel: DayTableModel, dateProfile: DateProfile, dateEnv: DateEnv): DateRange[] {\n  let ranges: DateRange[] = []\n\n  for (let date of dayTableModel.headerDates) {\n    ranges.push({\n      start: dateEnv.add(date, dateProfile.slotMinTime),\n      end: dateEnv.add(date, dateProfile.slotMaxTime),\n    })\n  }\n\n  return ranges\n}\n","import {\n  createDuration,\n  asRoughMs,\n  formatIsoTimeString,\n  addDurations,\n  wholeDivideDurations,\n  Duration,\n  DateMarker,\n  DateEnv,\n} from '@fullcalendar/common'\n\nexport interface TimeSlatMeta {\n  date: DateMarker\n  time: Duration\n  key: string\n  isoTimeStr: string\n  isLabeled: boolean\n}\n\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nconst STOCK_SUB_DURATIONS = [\n  { hours: 1 },\n  { minutes: 30 },\n  { minutes: 15 },\n  { seconds: 30 },\n  { seconds: 15 },\n]\n\nexport function buildSlatMetas(\n  slotMinTime: Duration,\n  slotMaxTime: Duration,\n  explicitLabelInterval: Duration | null,\n  slotDuration: Duration,\n  dateEnv: DateEnv,\n) {\n  let dayStart = new Date(0)\n  let slatTime = slotMinTime\n  let slatIterator = createDuration(0)\n  let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration)\n  let metas: TimeSlatMeta[] = []\n\n  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {\n    let date = dateEnv.add(dayStart, slatTime)\n    let isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null\n\n    metas.push({\n      date,\n      time: slatTime,\n      key: date.toISOString(), // we can't use the isoTimeStr for uniqueness when minTime/maxTime beyone 0h/24h\n      isoTimeStr: formatIsoTimeString(date),\n      isLabeled,\n    })\n\n    slatTime = addDurations(slatTime, slotDuration)\n    slatIterator = addDurations(slatIterator, slotDuration)\n  }\n\n  return metas\n}\n\n// Computes an automatic value for slotLabelInterval\nfunction computeLabelInterval(slotDuration) {\n  let i\n  let labelInterval\n  let slotsPerLabel\n\n  // find the smallest stock label interval that results in more than one slots-per-label\n  for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {\n    labelInterval = createDuration(STOCK_SUB_DURATIONS[i])\n    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration)\n    if (slotsPerLabel !== null && slotsPerLabel > 1) {\n      return labelInterval\n    }\n  }\n\n  return slotDuration // fall back\n}\n","import {\n  createElement,\n  DateProfileGenerator, DateProfile,\n  DayHeader,\n  DaySeriesModel,\n  DayTableModel,\n  memoize,\n  ChunkContentCallbackArgs,\n} from '@fullcalendar/common'\nimport { DayTable } from '@fullcalendar/daygrid'\nimport { TimeColsView } from './TimeColsView'\nimport { DayTimeCols } from './DayTimeCols'\nimport { buildSlatMetas } from './time-slat-meta'\n\nexport class DayTimeColsView extends TimeColsView {\n  private buildTimeColsModel = memoize(buildTimeColsModel)\n  private buildSlatMetas = memoize(buildSlatMetas)\n\n  render() {\n    let { options, dateEnv, dateProfileGenerator } = this.context\n    let { props } = this\n    let { dateProfile } = props\n    let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator)\n    let splitProps = this.allDaySplitter.splitProps(props)\n    let slatMetas = this.buildSlatMetas(\n      dateProfile.slotMinTime,\n      dateProfile.slotMaxTime,\n      options.slotLabelInterval,\n      options.slotDuration,\n      dateEnv,\n    )\n    let { dayMinWidth } = options\n    let hasAttachedAxis = !dayMinWidth\n    let hasDetachedAxis = dayMinWidth\n\n    let headerContent = options.dayHeaders && (\n      <DayHeader\n        dates={dayTableModel.headerDates}\n        dateProfile={dateProfile}\n        datesRepDistinctDays\n        renderIntro={hasAttachedAxis ? this.renderHeadAxis : null}\n      />\n    )\n\n    let allDayContent = (options.allDaySlot !== false) && ((contentArg: ChunkContentCallbackArgs) => (\n      <DayTable\n        {...splitProps.allDay}\n        dateProfile={dateProfile}\n        dayTableModel={dayTableModel}\n        nextDayThreshold={options.nextDayThreshold}\n        tableMinWidth={contentArg.tableMinWidth}\n        colGroupNode={contentArg.tableColGroupNode}\n        renderRowIntro={hasAttachedAxis ? this.renderTableRowAxis : null}\n        showWeekNumbers={false}\n        expandRows={false}\n        headerAlignElRef={this.headerElRef}\n        clientWidth={contentArg.clientWidth}\n        clientHeight={contentArg.clientHeight}\n        forPrint={props.forPrint}\n        {...this.getAllDayMaxEventProps()}\n      />\n    ))\n\n    let timeGridContent = (contentArg: ChunkContentCallbackArgs) => (\n      <DayTimeCols\n        {...splitProps.timed}\n        dayTableModel={dayTableModel}\n        dateProfile={dateProfile}\n        axis={hasAttachedAxis}\n        slotDuration={options.slotDuration}\n        slatMetas={slatMetas}\n        forPrint={props.forPrint}\n        tableColGroupNode={contentArg.tableColGroupNode}\n        tableMinWidth={contentArg.tableMinWidth}\n        clientWidth={contentArg.clientWidth}\n        clientHeight={contentArg.clientHeight}\n        onSlatCoords={this.handleSlatCoords}\n        expandRows={contentArg.expandRows}\n        onScrollTopRequest={this.handleScrollTopRequest}\n      />\n    )\n\n    return hasDetachedAxis\n      ? this.renderHScrollLayout(\n        headerContent,\n        allDayContent,\n        timeGridContent,\n        dayTableModel.colCnt,\n        dayMinWidth,\n        slatMetas,\n        this.state.slatCoords,\n      )\n      : this.renderSimpleLayout(\n        headerContent,\n        allDayContent,\n        timeGridContent,\n      )\n  }\n}\n\nexport function buildTimeColsModel(dateProfile: DateProfile, dateProfileGenerator: DateProfileGenerator) {\n  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator)\n\n  return new DayTableModel(daySeries, false)\n}\n","export const OPTION_REFINERS = {\n  allDaySlot: Boolean,\n}\n","import { createPlugin } from '@fullcalendar/common'\nimport { TimeColsView } from './TimeColsView'\nimport { DayTimeColsView, buildTimeColsModel } from './DayTimeColsView'\nimport { TimeColsSeg } from './TimeColsSeg'\nimport { DayTimeCols, buildDayRanges } from './DayTimeCols'\nimport { DayTimeColsSlicer } from './DayTimeColsSlicer'\nimport { OPTION_REFINERS } from './options'\nimport './options-declare'\nimport './main.css'\n\nexport { DayTimeCols, DayTimeColsView, TimeColsView, buildTimeColsModel, buildDayRanges, DayTimeColsSlicer, TimeColsSeg }\nexport { TimeCols } from './TimeCols'\nexport { TimeSlatMeta, buildSlatMetas } from './time-slat-meta'\nexport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\n\nexport default createPlugin({\n  initialView: 'timeGridWeek',\n  optionRefiners: OPTION_REFINERS,\n  views: {\n\n    timeGrid: {\n      component: DayTimeColsView,\n      usesMinMaxTime: true, // indicates that slotMinTime/slotMaxTime affects rendering\n      allDaySlot: true,\n      slotDuration: '00:30:00',\n      slotEventOverlap: true, // a bad name. confused with overlap/constraint system\n    },\n\n    timeGridDay: {\n      type: 'timeGrid',\n      duration: { days: 1 },\n    },\n\n    timeGridWeek: {\n      type: 'timeGrid',\n      duration: { weeks: 1 },\n    },\n\n  },\n})\n"]},"metadata":{},"sourceType":"module"}