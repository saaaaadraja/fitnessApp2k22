{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { getPoint, appendClipElement, pathAnimation } from '../../common/utils/helper';\nimport { LineBase } from './line-base';\nimport { RectOption, getElement } from '../../common/utils/helper';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\n * Base class for multi colored series\n */\n\nvar MultiColoredSeries =\n/** @class */\nfunction (_super) {\n  __extends(MultiColoredSeries, _super);\n\n  function MultiColoredSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * To Generate the area path direction\n   * @param xValue\n   * @param yValue\n   * @param series\n   * @param isInverted\n   * @param getPointLocation\n   * @param startPoint\n   * @param startPath\n   */\n\n\n  MultiColoredSeries.prototype.getAreaPathDirection = function (xValue, yValue, series, isInverted, getPointLocation, startPoint, startPath) {\n    var direction = '';\n    var firstPoint;\n\n    if (startPoint === null) {\n      firstPoint = getPointLocation(xValue, yValue, series.xAxis, series.yAxis, isInverted, series);\n      direction += startPath + ' ' + firstPoint.x + ' ' + firstPoint.y + ' ';\n    }\n\n    return direction;\n  };\n  /**\n   * To Generate the empty point direction\n   * @param firstPoint\n   * @param secondPoint\n   * @param series\n   * @param isInverted\n   * @param getPointLocation\n   */\n\n\n  MultiColoredSeries.prototype.getAreaEmptyDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation) {\n    var direction = '';\n    direction += this.getAreaPathDirection(firstPoint.x, firstPoint.y, series, isInverted, getPointLocation, null, 'L');\n    direction += this.getAreaPathDirection(secondPoint.x, secondPoint.y, series, isInverted, getPointLocation, null, 'L');\n    return direction;\n  };\n  /**\n   * To set point color\n   * @param points\n   */\n\n\n  MultiColoredSeries.prototype.setPointColor = function (currentPoint, previous, series, isXSegment, segments) {\n    if (series.pointColorMapping === '') {\n      var segment = void 0;\n      var value = void 0;\n\n      for (var i = 0; i < segments.length; i++) {\n        segment = segments[i];\n        value = isXSegment ? currentPoint.xValue : currentPoint.yValue;\n\n        if (value <= this.getAxisValue(segment.value, isXSegment ? series.xAxis : series.yAxis, series.chart) || !segment.value) {\n          currentPoint.interior = segment.color;\n          break;\n        }\n      }\n\n      if (currentPoint.interior == null) {\n        currentPoint.interior = series.interior;\n      }\n\n      return false;\n    } else {\n      if (previous) {\n        return series.setPointColor(currentPoint, series.interior) !== series.setPointColor(previous, series.interior);\n      } else {\n        return false;\n      }\n    }\n  };\n\n  MultiColoredSeries.prototype.sortSegments = function (series, chartSegments) {\n    var axis = series.segmentAxis === 'X' ? series.xAxis : series.yAxis;\n    var segments = [].concat(chartSegments);\n    var access = this;\n    return segments.sort(function (a, b) {\n      return access.getAxisValue(a.value, axis, series.chart) - access.getAxisValue(b.value, axis, series.chart);\n    });\n  };\n  /**\n   * Segment calculation performed here\n   * @param series\n   * @param options\n   * @param chartSegments\n   */\n\n\n  MultiColoredSeries.prototype.applySegmentAxis = function (series, options, segments) {\n    var _this = this;\n\n    if (series.pointColorMapping !== '') {\n      options.map(function (option) {\n        _this.appendLinePath(option, series, '');\n      });\n      return null;\n    }\n\n    var isXSegment = series.segmentAxis === 'X';\n    var axis = isXSegment ? series.xAxis : series.yAxis;\n    var chart = series.chart;\n    var segment;\n    this.includeSegment(segments, axis, series, segments.length);\n    var length = segments.length;\n    var value;\n    var clipPath;\n    var attributeOptions;\n\n    var _loop_1 = function (index) {\n      segment = segments[index];\n      value = this_1.getAxisValue(segment.value, axis, series.chart);\n      clipPath = this_1.createClipRect(index ? this_1.getAxisValue(segments[index - 1].value, axis, series.chart) : axis.visibleRange.min, value, series, index, isXSegment);\n\n      if (clipPath) {\n        options.map(function (option) {\n          attributeOptions = {\n            'clip-path': clipPath,\n            'stroke-dasharray': segment.dashArray,\n            'opacity': option.opacity,\n            'stroke': series.type.indexOf('Line') > -1 ? segment.color || series.interior : series.border.color,\n            'stroke-width': option['stroke-width'],\n            'fill': series.type.indexOf('Line') > -1 ? 'none' : segment.color || series.interior,\n            'id': option.id + '_Segment_' + index,\n            'd': option.d\n          };\n          pathAnimation(getElement(attributeOptions.id), attributeOptions.d, chart.redraw);\n          series.seriesElement.appendChild(chart.renderer.drawPath(attributeOptions));\n        });\n      }\n    };\n\n    var this_1 = this;\n\n    for (var index = 0; index < length; index++) {\n      _loop_1(index);\n    }\n  };\n\n  MultiColoredSeries.prototype.includeSegment = function (segments, axis, series, length) {\n    if (length <= 0) {\n      segments.push({\n        value: axis.visibleRange.max,\n        color: series.interior\n      });\n      return null;\n    }\n\n    if (this.getAxisValue(segments[length - 1].value, axis, series.chart) < axis.visibleRange.max) {\n      segments.push({\n        value: axis.visibleRange.max,\n        color: series.interior\n      });\n    }\n  };\n  /**\n   * To create clip rect for segment axis\n   * @param startValue\n   * @param endValue\n   * @param series\n   * @param index\n   * @param isX\n   * @param chart\n   */\n\n\n  MultiColoredSeries.prototype.createClipRect = function (startValue, endValue, series, index, isX) {\n    var isRequired = series.chart.requireInvertedAxis;\n    var startPointLocation = getPoint(isX ? startValue : series.xAxis.visibleRange.min, isX ? series.yAxis.visibleRange.max : endValue, series.xAxis, series.yAxis, isRequired);\n    var endPointLocation = getPoint(isX ? endValue : series.xAxis.visibleRange.max, isX ? series.yAxis.visibleRange.min : startValue, series.xAxis, series.yAxis, isRequired);\n    endPointLocation = isRequired ? [startPointLocation, startPointLocation = endPointLocation][0] : endPointLocation;\n    var options;\n\n    if (endPointLocation.x - startPointLocation.x > 0 && endPointLocation.y - startPointLocation.y > 0) {\n      options = new RectOption(series.chart.element.id + '_ChartSegment' + series.index + 'ClipRect_' + index, 'transparent', {\n        width: 1,\n        color: 'Gray'\n      }, 1, {\n        x: startPointLocation.x,\n        y: startPointLocation.y,\n        width: endPointLocation.x - startPointLocation.x,\n        height: endPointLocation.y - startPointLocation.y\n      });\n      series.seriesElement.appendChild(appendClipElement(series.chart.redraw, options, series.chart.renderer));\n      return 'url(#' + series.chart.element.id + '_ChartSegment' + series.index + 'ClipRect_' + index + ')';\n    }\n\n    return null;\n  };\n  /**\n   * To get exact value from segment value\n   * @param segmentValue\n   * @param axis\n   * @param chart\n   */\n\n\n  MultiColoredSeries.prototype.getAxisValue = function (segmentValue, axis, chart) {\n    if (segmentValue === null) {\n      segmentValue = axis.visibleRange.max;\n    }\n\n    if (axis.valueType === 'DateTime') {\n      var option = {\n        skeleton: 'full',\n        type: 'dateTime'\n      };\n      return Date.parse(chart.intl.getDateParser(option)(chart.intl.getDateFormat(option)(new Date(DataUtil.parse.parseJson({\n        val: segmentValue\n      }).val))));\n    } else if (axis.valueType.indexOf('Category') > -1) {\n      var xValue = axis.valueType === 'DateTimeCategory' ? segmentValue.getTime().toString() : segmentValue;\n      return axis.labels.indexOf(xValue) < 0 ? +segmentValue : axis.labels.indexOf(xValue);\n    } else {\n      return +segmentValue;\n    }\n  };\n\n  return MultiColoredSeries;\n}(LineBase);\n\nexport { MultiColoredSeries };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","getPoint","appendClipElement","pathAnimation","LineBase","RectOption","getElement","DataUtil","MultiColoredSeries","_super","apply","arguments","getAreaPathDirection","xValue","yValue","series","isInverted","getPointLocation","startPoint","startPath","direction","firstPoint","xAxis","yAxis","x","y","getAreaEmptyDirection","secondPoint","setPointColor","currentPoint","previous","isXSegment","segments","pointColorMapping","segment","value","i","length","getAxisValue","chart","interior","color","sortSegments","chartSegments","axis","segmentAxis","concat","access","sort","a","applySegmentAxis","options","_this","map","option","appendLinePath","includeSegment","clipPath","attributeOptions","_loop_1","index","this_1","createClipRect","visibleRange","min","dashArray","opacity","type","indexOf","border","id","redraw","seriesElement","appendChild","renderer","drawPath","push","max","startValue","endValue","isX","isRequired","requireInvertedAxis","startPointLocation","endPointLocation","element","width","height","segmentValue","valueType","skeleton","Date","parse","intl","getDateParser","getDateFormat","parseJson","val","getTime","toString","labels"],"sources":["D:/Theme/package/node_modules/@syncfusion/ej2-charts/src/chart/series/multi-colored-base.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getPoint, appendClipElement, pathAnimation } from '../../common/utils/helper';\nimport { LineBase } from './line-base';\nimport { RectOption, getElement } from '../../common/utils/helper';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\n * Base class for multi colored series\n */\nvar MultiColoredSeries = /** @class */ (function (_super) {\n    __extends(MultiColoredSeries, _super);\n    function MultiColoredSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * To Generate the area path direction\n     * @param xValue\n     * @param yValue\n     * @param series\n     * @param isInverted\n     * @param getPointLocation\n     * @param startPoint\n     * @param startPath\n     */\n    MultiColoredSeries.prototype.getAreaPathDirection = function (xValue, yValue, series, isInverted, getPointLocation, startPoint, startPath) {\n        var direction = '';\n        var firstPoint;\n        if (startPoint === null) {\n            firstPoint = getPointLocation(xValue, yValue, series.xAxis, series.yAxis, isInverted, series);\n            direction += (startPath + ' ' + (firstPoint.x) + ' ' + (firstPoint.y) + ' ');\n        }\n        return direction;\n    };\n    /**\n     * To Generate the empty point direction\n     * @param firstPoint\n     * @param secondPoint\n     * @param series\n     * @param isInverted\n     * @param getPointLocation\n     */\n    MultiColoredSeries.prototype.getAreaEmptyDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation) {\n        var direction = '';\n        direction += this.getAreaPathDirection(firstPoint.x, firstPoint.y, series, isInverted, getPointLocation, null, 'L');\n        direction += this.getAreaPathDirection(secondPoint.x, secondPoint.y, series, isInverted, getPointLocation, null, 'L');\n        return direction;\n    };\n    /**\n     * To set point color\n     * @param points\n     */\n    MultiColoredSeries.prototype.setPointColor = function (currentPoint, previous, series, isXSegment, segments) {\n        if (series.pointColorMapping === '') {\n            var segment = void 0;\n            var value = void 0;\n            for (var i = 0; i < segments.length; i++) {\n                segment = segments[i];\n                value = isXSegment ? currentPoint.xValue : currentPoint.yValue;\n                if (value <= this.getAxisValue(segment.value, isXSegment ? series.xAxis : series.yAxis, series.chart) || !segment.value) {\n                    currentPoint.interior = segment.color;\n                    break;\n                }\n            }\n            if (currentPoint.interior == null) {\n                currentPoint.interior = series.interior;\n            }\n            return false;\n        }\n        else {\n            if (previous) {\n                return series.setPointColor(currentPoint, series.interior) !== series.setPointColor(previous, series.interior);\n            }\n            else {\n                return false;\n            }\n        }\n    };\n    MultiColoredSeries.prototype.sortSegments = function (series, chartSegments) {\n        var axis = series.segmentAxis === 'X' ? series.xAxis : series.yAxis;\n        var segments = [].concat(chartSegments);\n        var access = this;\n        return segments.sort(function (a, b) {\n            return access.getAxisValue(a.value, axis, series.chart) - access.getAxisValue(b.value, axis, series.chart);\n        });\n    };\n    /**\n     * Segment calculation performed here\n     * @param series\n     * @param options\n     * @param chartSegments\n     */\n    MultiColoredSeries.prototype.applySegmentAxis = function (series, options, segments) {\n        var _this = this;\n        if (series.pointColorMapping !== '') {\n            options.map(function (option) {\n                _this.appendLinePath(option, series, '');\n            });\n            return null;\n        }\n        var isXSegment = series.segmentAxis === 'X';\n        var axis = isXSegment ? series.xAxis : series.yAxis;\n        var chart = series.chart;\n        var segment;\n        this.includeSegment(segments, axis, series, segments.length);\n        var length = segments.length;\n        var value;\n        var clipPath;\n        var attributeOptions;\n        var _loop_1 = function (index) {\n            segment = segments[index];\n            value = this_1.getAxisValue(segment.value, axis, series.chart);\n            clipPath = this_1.createClipRect(index ? this_1.getAxisValue(segments[index - 1].value, axis, series.chart)\n                : axis.visibleRange.min, value, series, index, isXSegment);\n            if (clipPath) {\n                options.map(function (option) {\n                    attributeOptions = {\n                        'clip-path': clipPath,\n                        'stroke-dasharray': segment.dashArray,\n                        'opacity': option.opacity,\n                        'stroke': series.type.indexOf('Line') > -1 ? segment.color || series.interior : series.border.color,\n                        'stroke-width': option['stroke-width'],\n                        'fill': series.type.indexOf('Line') > -1 ? 'none' : segment.color || series.interior,\n                        'id': option.id + '_Segment_' + index,\n                        'd': option.d\n                    };\n                    pathAnimation(getElement(attributeOptions.id), attributeOptions.d, chart.redraw);\n                    series.seriesElement.appendChild(chart.renderer.drawPath(attributeOptions));\n                });\n            }\n        };\n        var this_1 = this;\n        for (var index = 0; index < length; index++) {\n            _loop_1(index);\n        }\n    };\n    MultiColoredSeries.prototype.includeSegment = function (segments, axis, series, length) {\n        if (length <= 0) {\n            segments.push({ value: axis.visibleRange.max, color: series.interior });\n            return null;\n        }\n        if (this.getAxisValue(segments[length - 1].value, axis, series.chart) < axis.visibleRange.max) {\n            segments.push({ value: axis.visibleRange.max, color: series.interior });\n        }\n    };\n    /**\n     * To create clip rect for segment axis\n     * @param startValue\n     * @param endValue\n     * @param series\n     * @param index\n     * @param isX\n     * @param chart\n     */\n    MultiColoredSeries.prototype.createClipRect = function (startValue, endValue, series, index, isX) {\n        var isRequired = series.chart.requireInvertedAxis;\n        var startPointLocation = getPoint(isX ? startValue : series.xAxis.visibleRange.min, isX ? series.yAxis.visibleRange.max : endValue, series.xAxis, series.yAxis, isRequired);\n        var endPointLocation = getPoint(isX ? endValue : series.xAxis.visibleRange.max, isX ? series.yAxis.visibleRange.min : startValue, series.xAxis, series.yAxis, isRequired);\n        endPointLocation = isRequired ?\n            [startPointLocation, startPointLocation = endPointLocation][0] : endPointLocation;\n        var options;\n        if ((endPointLocation.x - startPointLocation.x > 0) && (endPointLocation.y - startPointLocation.y > 0)) {\n            options = new RectOption(series.chart.element.id + '_ChartSegment' + series.index + 'ClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {\n                x: startPointLocation.x,\n                y: startPointLocation.y,\n                width: endPointLocation.x - startPointLocation.x,\n                height: endPointLocation.y - startPointLocation.y\n            });\n            series.seriesElement.appendChild(appendClipElement(series.chart.redraw, options, series.chart.renderer));\n            return 'url(#' + series.chart.element.id + '_ChartSegment' + series.index + 'ClipRect_' + index + ')';\n        }\n        return null;\n    };\n    /**\n     * To get exact value from segment value\n     * @param segmentValue\n     * @param axis\n     * @param chart\n     */\n    MultiColoredSeries.prototype.getAxisValue = function (segmentValue, axis, chart) {\n        if (segmentValue === null) {\n            segmentValue = axis.visibleRange.max;\n        }\n        if (axis.valueType === 'DateTime') {\n            var option = { skeleton: 'full', type: 'dateTime' };\n            return Date.parse(chart.intl.getDateParser(option)(chart.intl.getDateFormat(option)(new Date(DataUtil.parse.parseJson({ val: segmentValue }).val))));\n        }\n        else if (axis.valueType.indexOf('Category') > -1) {\n            var xValue = axis.valueType === 'DateTimeCategory' ?\n                (segmentValue.getTime()).toString() :\n                segmentValue;\n            return (axis.labels.indexOf(xValue) < 0) ? +segmentValue : axis.labels.indexOf(xValue);\n        }\n        else {\n            return +segmentValue;\n        }\n    };\n    return MultiColoredSeries;\n}(LineBase));\nexport { MultiColoredSeries };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}