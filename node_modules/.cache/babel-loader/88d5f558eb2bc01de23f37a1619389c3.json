{"ast":null,"code":"import { withInRange, getPoint, drawSymbol } from '../../common/utils/helper';\nimport { Size, PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { markerAnimate, appendChildElement, animateRedrawElement } from '../../common/utils/helper';\nimport { pointRender } from '../../common/model/constants';\n/**\n * `BubbleSeries` module is used to render the bubble series.\n */\n\nvar BubbleSeries =\n/** @class */\nfunction () {\n  function BubbleSeries() {}\n  /**\n   * Render the Bubble series.\n   * @return {void}\n   * @private\n   */\n\n\n  BubbleSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\n    var marker = series.marker;\n    var visiblePoints = series.points;\n    var shapeOption;\n    var argsData; //let bubbleMode: RadiusMode = bubbleOptions.radiusMode;\n\n    var segmentRadius;\n    var radius;\n    var value = Math.max(series.chart.initialClipRect.height, series.chart.initialClipRect.width);\n    var percentChange = value / 100;\n    var maxRadius = series.maxRadius * percentChange;\n    var minRadius = series.minRadius * percentChange;\n    var maximumSize = null;\n    var maxValue = null;\n    var element;\n    var startLocation;\n    var redraw = series.chart.redraw;\n\n    if (series.maxRadius === null || series.minRadius === null) {\n      for (var _i = 0, _a = series.chart.visibleSeries; _i < _a.length; _i++) {\n        var value_1 = _a[_i];\n\n        if (value_1.type === 'Bubble' && value_1.visible === true && (value_1.maxRadius === null || value_1.minRadius === null)) {\n          maximumSize = value_1.sizeMax > maximumSize ? value_1.sizeMax : maximumSize;\n        }\n      }\n\n      maxValue = value / 5 / 2;\n      minRadius = maxRadius = 1;\n      radius = maxValue * maxRadius;\n    } else {\n      maximumSize = series.sizeMax;\n      radius = maxRadius - minRadius;\n    }\n\n    for (var _b = 0, visiblePoints_1 = visiblePoints; _b < visiblePoints_1.length; _b++) {\n      var bubblePoint = visiblePoints_1[_b];\n      startLocation = redraw ? bubblePoint.symbolLocations[0] : null;\n      bubblePoint.symbolLocations = [];\n      bubblePoint.regions = [];\n\n      if (bubblePoint.visible && withInRange(visiblePoints[bubblePoint.index - 1], bubblePoint, visiblePoints[bubblePoint.index + 1], series)) {\n        if (series.maxRadius === null || series.minRadius === null) {\n          segmentRadius = radius * Math.abs(+bubblePoint.size / maximumSize);\n        } else {\n          segmentRadius = minRadius + radius * Math.abs(+bubblePoint.size / maximumSize);\n        }\n\n        segmentRadius = segmentRadius || minRadius;\n        argsData = {\n          cancel: false,\n          name: pointRender,\n          series: series,\n          point: bubblePoint,\n          fill: series.setPointColor(bubblePoint, series.interior),\n          border: series.setBorderColor(bubblePoint, {\n            width: series.border.width,\n            color: series.border.color\n          }),\n          height: 2 * segmentRadius,\n          width: 2 * segmentRadius\n        };\n        series.chart.trigger(pointRender, argsData);\n\n        if (!argsData.cancel) {\n          bubblePoint.symbolLocations.push(getPoint(bubblePoint.xValue, bubblePoint.yValue, xAxis, yAxis, isInverted));\n          bubblePoint.color = argsData.fill;\n          shapeOption = new PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + bubblePoint.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, null);\n          element = drawSymbol(bubblePoint.symbolLocations[0], 'Circle', new Size(argsData.width, argsData.height), marker.imageUrl, shapeOption, bubblePoint.x.toString() + ':' + bubblePoint.yValue.toString(), series.chart.svgRenderer, series.clipRect);\n          appendChildElement(false, series.seriesElement, element, redraw);\n          bubblePoint.regions.push(new Rect(bubblePoint.symbolLocations[0].x - segmentRadius, bubblePoint.symbolLocations[0].y - segmentRadius, 2 * segmentRadius, 2 * segmentRadius));\n          bubblePoint.marker = {\n            border: argsData.border,\n            fill: argsData.fill,\n            height: argsData.height,\n            visible: true,\n            shape: 'Circle',\n            width: argsData.width\n          };\n\n          if (redraw) {\n            animateRedrawElement(element, 300, startLocation, bubblePoint.symbolLocations[0], 'cx', 'cy');\n          }\n        } else {\n          bubblePoint.marker = {\n            visible: false\n          };\n        }\n      }\n    }\n  };\n  /**\n   * To destroy the Bubble.\n   * @return {void}\n   * @private\n   */\n\n\n  BubbleSeries.prototype.destroy = function (chart) {\n    /**\n     * Destroy method calling here\n     */\n  };\n  /**\n   * Get module name.\n   */\n\n\n  BubbleSeries.prototype.getModuleName = function () {\n    /**\n     * Returns the module name of the series\n     */\n    return 'BubbleSeries';\n  };\n  /**\n   * Animates the series.\n   * @param  {Series} series - Defines the series to animate.\n   * @return {void}\n   */\n\n\n  BubbleSeries.prototype.doAnimation = function (series) {\n    var duration = series.animation.duration;\n    var delay = series.animation.delay;\n    var rectElements = series.seriesElement.childNodes;\n    var count = 1;\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var bubblePoint = _a[_i];\n\n      if (!bubblePoint.symbolLocations.length) {\n        continue;\n      }\n\n      markerAnimate(rectElements[count], delay, duration, series, bubblePoint.index, bubblePoint.symbolLocations[0], false);\n      count++;\n    }\n  };\n\n  return BubbleSeries;\n}();\n\nexport { BubbleSeries };","map":{"version":3,"names":["withInRange","getPoint","drawSymbol","Size","PathOption","Rect","markerAnimate","appendChildElement","animateRedrawElement","pointRender","BubbleSeries","prototype","render","series","xAxis","yAxis","isInverted","marker","visiblePoints","points","shapeOption","argsData","segmentRadius","radius","value","Math","max","chart","initialClipRect","height","width","percentChange","maxRadius","minRadius","maximumSize","maxValue","element","startLocation","redraw","_i","_a","visibleSeries","length","value_1","type","visible","sizeMax","_b","visiblePoints_1","bubblePoint","symbolLocations","regions","index","abs","size","cancel","name","point","fill","setPointColor","interior","border","setBorderColor","color","trigger","push","xValue","yValue","id","opacity","imageUrl","x","toString","svgRenderer","clipRect","seriesElement","y","shape","destroy","getModuleName","doAnimation","duration","animation","delay","rectElements","childNodes","count"],"sources":["D:/Theme/package/node_modules/@syncfusion/ej2-charts/src/chart/series/bubble-series.js"],"sourcesContent":["import { withInRange, getPoint, drawSymbol } from '../../common/utils/helper';\nimport { Size, PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { markerAnimate, appendChildElement, animateRedrawElement } from '../../common/utils/helper';\nimport { pointRender } from '../../common/model/constants';\n/**\n * `BubbleSeries` module is used to render the bubble series.\n */\nvar BubbleSeries = /** @class */ (function () {\n    function BubbleSeries() {\n    }\n    /**\n     * Render the Bubble series.\n     * @return {void}\n     * @private\n     */\n    BubbleSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\n        var marker = series.marker;\n        var visiblePoints = series.points;\n        var shapeOption;\n        var argsData;\n        //let bubbleMode: RadiusMode = bubbleOptions.radiusMode;\n        var segmentRadius;\n        var radius;\n        var value = Math.max(series.chart.initialClipRect.height, series.chart.initialClipRect.width);\n        var percentChange = value / 100;\n        var maxRadius = series.maxRadius * percentChange;\n        var minRadius = series.minRadius * percentChange;\n        var maximumSize = null;\n        var maxValue = null;\n        var element;\n        var startLocation;\n        var redraw = series.chart.redraw;\n        if ((series.maxRadius === null || series.minRadius === null)) {\n            for (var _i = 0, _a = series.chart.visibleSeries; _i < _a.length; _i++) {\n                var value_1 = _a[_i];\n                if (value_1.type === 'Bubble' && value_1.visible === true && (value_1.maxRadius === null || value_1.minRadius === null)) {\n                    maximumSize = value_1.sizeMax > maximumSize ? value_1.sizeMax : maximumSize;\n                }\n            }\n            maxValue = (value / 5) / 2;\n            minRadius = maxRadius = 1;\n            radius = maxValue * maxRadius;\n        }\n        else {\n            maximumSize = series.sizeMax;\n            radius = maxRadius - minRadius;\n        }\n        for (var _b = 0, visiblePoints_1 = visiblePoints; _b < visiblePoints_1.length; _b++) {\n            var bubblePoint = visiblePoints_1[_b];\n            startLocation = redraw ? bubblePoint.symbolLocations[0] : null;\n            bubblePoint.symbolLocations = [];\n            bubblePoint.regions = [];\n            if (bubblePoint.visible &&\n                withInRange(visiblePoints[bubblePoint.index - 1], bubblePoint, visiblePoints[bubblePoint.index + 1], series)) {\n                if ((series.maxRadius === null || series.minRadius === null)) {\n                    segmentRadius = radius * Math.abs(+bubblePoint.size / maximumSize);\n                }\n                else {\n                    segmentRadius = minRadius + radius * Math.abs(+bubblePoint.size / maximumSize);\n                }\n                segmentRadius = segmentRadius || minRadius;\n                argsData = {\n                    cancel: false, name: pointRender, series: series, point: bubblePoint,\n                    fill: series.setPointColor(bubblePoint, series.interior),\n                    border: series.setBorderColor(bubblePoint, { width: series.border.width, color: series.border.color }),\n                    height: 2 * segmentRadius, width: 2 * segmentRadius\n                };\n                series.chart.trigger(pointRender, argsData);\n                if (!argsData.cancel) {\n                    bubblePoint.symbolLocations.push(getPoint(bubblePoint.xValue, bubblePoint.yValue, xAxis, yAxis, isInverted));\n                    bubblePoint.color = argsData.fill;\n                    shapeOption = new PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + bubblePoint.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, null);\n                    element = drawSymbol(bubblePoint.symbolLocations[0], 'Circle', new Size(argsData.width, argsData.height), marker.imageUrl, shapeOption, bubblePoint.x.toString() + ':' + bubblePoint.yValue.toString(), series.chart.svgRenderer, series.clipRect);\n                    appendChildElement(false, series.seriesElement, element, redraw);\n                    bubblePoint.regions.push(new Rect(bubblePoint.symbolLocations[0].x - segmentRadius, bubblePoint.symbolLocations[0].y - segmentRadius, 2 * segmentRadius, 2 * segmentRadius));\n                    bubblePoint.marker = {\n                        border: argsData.border, fill: argsData.fill,\n                        height: argsData.height, visible: true,\n                        shape: 'Circle', width: argsData.width\n                    };\n                    if (redraw) {\n                        animateRedrawElement(element, 300, startLocation, bubblePoint.symbolLocations[0], 'cx', 'cy');\n                    }\n                }\n                else {\n                    bubblePoint.marker = { visible: false };\n                }\n            }\n        }\n    };\n    /**\n     * To destroy the Bubble.\n     * @return {void}\n     * @private\n     */\n    BubbleSeries.prototype.destroy = function (chart) {\n        /**\n         * Destroy method calling here\n         */\n    };\n    /**\n     * Get module name.\n     */\n    BubbleSeries.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the series\n         */\n        return 'BubbleSeries';\n    };\n    /**\n     * Animates the series.\n     * @param  {Series} series - Defines the series to animate.\n     * @return {void}\n     */\n    BubbleSeries.prototype.doAnimation = function (series) {\n        var duration = series.animation.duration;\n        var delay = series.animation.delay;\n        var rectElements = series.seriesElement.childNodes;\n        var count = 1;\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var bubblePoint = _a[_i];\n            if (!bubblePoint.symbolLocations.length) {\n                continue;\n            }\n            markerAnimate(rectElements[count], delay, duration, series, bubblePoint.index, bubblePoint.symbolLocations[0], false);\n            count++;\n        }\n    };\n    return BubbleSeries;\n}());\nexport { BubbleSeries };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}