{"ast":null,"code":"import { SizeF, RectangleF, PointF } from './../../drawing/pdf-drawing';\nimport { PdfWordWrapType } from './enum';\nimport { StringTokenizer } from './string-tokenizer';\n/**\n * Class `lay outing the text`.\n */\n\nvar PdfStringLayouter =\n/** @class */\nfunction () {\n  // Constructors\n\n  /**\n   * Initializes a new instance of the `StringLayouter` class.\n   * @private\n   */\n  function PdfStringLayouter() {\n    /**\n     * Checks whether the x co-ordinate is need to set as client size or not.\n     * @hidden\n     * @private\n     */\n    this.isOverloadWithPosition = false; //\n  }\n\n  PdfStringLayouter.prototype.layout = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n    if (arg4 instanceof RectangleF) {\n      this.initialize(arg1, arg2, arg3, arg4, arg5);\n      this.isOverloadWithPosition = arg6;\n      this.clientSize = arg7;\n      var result = this.doLayout();\n      this.clear();\n      return result;\n    } else {\n      this.initialize(arg1, arg2, arg3, arg4);\n      this.isOverloadWithPosition = arg5;\n      this.clientSize = arg6;\n      var result = this.doLayout();\n      this.clear();\n      return result;\n    }\n  };\n\n  PdfStringLayouter.prototype.initialize = function (text, font, format, rectSize, pageHeight) {\n    if (typeof pageHeight === 'number') {\n      if (text == null) {\n        throw new Error('ArgumentNullException:text');\n      }\n\n      if (font == null) {\n        throw new Error('ArgumentNullException:font');\n      }\n\n      this.text = text;\n      this.font = font;\n      this.format = format;\n      this.size = new SizeF(rectSize.width, rectSize.height);\n      this.rectangle = rectSize;\n      this.pageHeight = pageHeight;\n      this.reader = new StringTokenizer(text);\n    } else {\n      this.initialize(text, font, format, new RectangleF(new PointF(0, 0), rectSize), 0);\n    }\n  };\n  /**\n   * `Clear` all resources.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.clear = function () {\n    this.font = null;\n    this.format = null;\n    this.reader.close();\n    this.reader = null;\n    this.text = null;\n  };\n  /**\n   * `Layouts` the text.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.doLayout = function () {\n    var result = new PdfStringLayoutResult();\n    var lineResult = new PdfStringLayoutResult();\n    var lines = [];\n    var line = this.reader.peekLine();\n    var lineIndent = this.getLineIndent(true);\n\n    while (line != null) {\n      lineResult = this.layoutLine(line, lineIndent);\n\n      if (lineResult !== null || typeof lineResult !== 'undefined') {\n        var numSymbolsInserted = 0;\n        /* tslint:disable */\n\n        var returnedValue = this.copyToResult(result, lineResult, lines,\n        /*out*/\n        numSymbolsInserted);\n        /* tslint:enable */\n\n        var success = returnedValue.success;\n        numSymbolsInserted = returnedValue.numInserted;\n\n        if (!success) {\n          this.reader.read(numSymbolsInserted);\n          break;\n        }\n      } // if (lineResult.textRemainder != null && lineResult.textRemainder.length > 0 ) {\n      //     break;\n      // }\n\n\n      this.reader.readLine();\n      line = this.reader.peekLine();\n      lineIndent = this.getLineIndent(false);\n    }\n\n    this.finalizeResult(result, lines);\n    return result;\n  };\n  /**\n   * Returns `line indent` for the line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.getLineIndent = function (firstLine) {\n    var lineIndent = 0;\n\n    if (this.format != null) {\n      lineIndent = firstLine ? this.format.firstLineIndent : this.format.paragraphIndent;\n      lineIndent = this.size.width > 0 ? Math.min(this.size.width, lineIndent) : lineIndent;\n    }\n\n    return lineIndent;\n  };\n  /**\n   * Calculates `height` of the line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.getLineHeight = function () {\n    var height = this.font.height;\n\n    if (this.format != null && this.format.lineSpacing !== 0) {\n      height = this.format.lineSpacing + this.font.height;\n    }\n\n    return height;\n  };\n  /**\n   * Calculates `width` of the line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.getLineWidth = function (line) {\n    var width = this.font.getLineWidth(line, this.format);\n    return width;\n  }; // tslint:disable\n\n  /**\n   * `Layouts` line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.layoutLine = function (line, lineIndent) {\n    var lineResult = new PdfStringLayoutResult();\n    lineResult.layoutLineHeight = this.getLineHeight();\n    var lines = [];\n    var maxWidth = this.size.width;\n    var lineWidth = this.getLineWidth(line) + lineIndent;\n    var lineType = LineType.FirstParagraphLine;\n    var readWord = true; // line is in bounds.\n\n    if (maxWidth <= 0 || Math.round(lineWidth) <= Math.round(maxWidth)) {\n      this.addToLineResult(lineResult, lines, line, lineWidth, LineType.NewLineBreak | lineType);\n    } else {\n      var builder = '';\n      var curLine = '';\n      lineWidth = lineIndent;\n      var curIndent = lineIndent;\n      var reader = new StringTokenizer(line);\n      var word = reader.peekWord();\n      var isSingleWord = false;\n\n      if (word.length !== reader.length) {\n        if (word === ' ') {\n          curLine = curLine + word;\n          builder = builder + word;\n          reader.position += 1;\n          word = reader.peekWord();\n        }\n      }\n\n      while (word != null) {\n        curLine = curLine + word;\n        var curLineWidth = this.getLineWidth(curLine.toString()) + curIndent\n        /*)*/\n        ;\n\n        if (curLine.toString() === ' ') {\n          curLine = '';\n          curLineWidth = 0;\n        }\n\n        if (curLineWidth > maxWidth) {\n          if (this.getWrapType() === PdfWordWrapType.None) {\n            break;\n          }\n\n          if (curLine.length === word.length) {\n            //  Character wrap is disabled or one symbol is greater than bounds.\n            if (this.getWrapType() === PdfWordWrapType.WordOnly) {\n              lineResult.textRemainder = line.substring(reader.position);\n              break;\n            } else if (curLine.length === 1) {\n              builder = builder + word;\n              break;\n            } else {\n              readWord = false;\n              curLine = '';\n              word = reader.peek().toString();\n              continue;\n            }\n          } else {\n            if (this.getLineWidth(word.toString()) > maxWidth) {\n              this.format.wordWrap = PdfWordWrapType.Character;\n            } else {\n              if (typeof this.format !== 'undefined' && this.format !== null) {\n                this.format.wordWrap = PdfWordWrapType.Word;\n              }\n            }\n\n            if (this.getWrapType() !== PdfWordWrapType.Character || !readWord) {\n              var ln = builder.toString(); // if (ln.indexOf(' ') === -1) {\n              //     isSingleWord = true;\n              //     this.addToLineResult(lineResult, lines, curLine, lineWidth, LineType.LayoutBreak | lineType);\n              // } else {\n              //     this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);\n              // }                          \n\n              if (ln !== ' ') {\n                this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);\n              }\n\n              if (this.isOverloadWithPosition) {\n                maxWidth = this.clientSize.width;\n              }\n\n              curLine = '';\n              builder = '';\n              lineWidth = 0;\n              curIndent = 0;\n              curLineWidth = 0;\n              lineType = LineType.None; // if (isSingleWord) {\n              //     reader.readWord();\n              //     readWord = false;\n              // }\n\n              word = readWord ? word : reader.peekWord(); //isSingleWord = false;\n\n              readWord = true;\n            } else {\n              readWord = false;\n              curLine = '';\n              curLine = curLine + builder.toString();\n              word = reader.peek().toString();\n            }\n\n            continue;\n          }\n        }\n        /*tslint:disable:max-func-body-length */\n\n\n        builder = builder + word;\n        lineWidth = curLineWidth;\n\n        if (readWord) {\n          reader.readWord();\n          word = reader.peekWord(); //isSingleWord = false;\n        } else {\n          reader.read();\n          word = reader.peek().toString();\n        }\n      }\n\n      if (builder.length > 0) {\n        var ln = builder.toString();\n        this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.NewLineBreak | LineType.LastParagraphLine);\n      }\n\n      reader.close();\n    }\n\n    lineResult.layoutLines = [];\n\n    for (var index = 0; index < lines.length; index++) {\n      lineResult.layoutLines.push(lines[index]);\n    }\n\n    lines = [];\n    return lineResult;\n  };\n  /**\n   * `Adds` line to line result.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.addToLineResult = function (lineResult, lines, line, lineWidth, breakType) {\n    var info = new LineInfo();\n    info.text = line;\n    info.width = lineWidth;\n    info.lineType = breakType;\n    lines.push(info);\n    var size = lineResult.actualSize;\n    size.height += this.getLineHeight();\n    size.width = Math.max(size.width, lineWidth);\n    lineResult.size = size;\n  };\n  /**\n   * `Copies` layout result from line result to entire result. Checks whether we can proceed lay outing or not.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.copyToResult = function (result, lineResult, lines,\n  /*out*/\n  numInserted) {\n    var success = true;\n    var allowPartialLines = this.format != null && !this.format.lineLimit;\n    var height = result.actualSize.height;\n    var maxHeight = this.size.height;\n\n    if (this.pageHeight > 0 && maxHeight + this.rectangle.y > this.pageHeight) {\n      maxHeight = this.rectangle.y - this.pageHeight;\n      maxHeight = Math.max(maxHeight, -maxHeight);\n    }\n\n    numInserted = 0;\n\n    if (lineResult.lines != null) {\n      for (var i = 0, len = lineResult.lines.length; i < len; i++) {\n        var expHeight = height + lineResult.lineHeight;\n\n        if (expHeight <= maxHeight || maxHeight <= 0 || allowPartialLines) {\n          var info = lineResult.lines[i];\n          numInserted += info.text.length;\n          info = this.trimLine(info, lines.length === 0);\n          lines.push(info); // Update width.\n\n          var size = result.actualSize;\n          size.width = Math.max(size.width, info.width);\n          result.size = size; // The part of the line fits only and it's allowed to use partial lines.\n          // if (expHeight >= maxHeight && maxHeight > 0 && allowPartialLines)\n          // {\n          //     let shouldClip : boolean = (this.format == null || !this.format.noClip);\n          //     if (shouldClip)\n          //     {\n          //         let exceededHeight : number = expHeight - maxHeight;\n          //         let fitHeight : number  = /*Utils.Round(*/ lineResult.lineHeight - exceededHeight /*)*/;\n          //         height = /*Utils.Round(*/ height + fitHeight /*)*/;\n          //     }\n          //     else\n          //     {\n          //         height = expHeight;\n          //     }\n          //     success = false;\n          //     break;\n          // } else {\n\n          height = expHeight; // }\n        } else {\n          success = false;\n          break;\n        }\n      }\n    }\n\n    if (height != result.size.height) {\n      var size1 = result.actualSize;\n      size1.height = height;\n      result.size = size1;\n    }\n\n    return {\n      success: success,\n      numInserted: numInserted\n    };\n  };\n  /**\n   * `Finalizes` final result.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.finalizeResult = function (result, lines) {\n    result.layoutLines = [];\n\n    for (var index = 0; index < lines.length; index++) {\n      result.layoutLines.push(lines[index]);\n    }\n\n    result.layoutLineHeight = this.getLineHeight();\n\n    if (!this.reader.end) {\n      result.textRemainder = this.reader.readToEnd();\n    }\n\n    lines = [];\n  };\n  /**\n   * `Trims` whitespaces at the line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.trimLine = function (info, firstLine) {\n    var line = info.text;\n    var lineWidth = info.width; // Trim start whitespaces if the line is not a start of the paragraph only.\n\n    var trimStartSpaces = (info.lineType & LineType.FirstParagraphLine) === 0;\n    var start = this.format == null || !this.format.rightToLeft;\n    var spaces = StringTokenizer.spaces;\n    line = start ? line.trim() : line.trim(); // Recalculate line width.\n\n    if (line.length !== info.text.length) {\n      lineWidth = this.getLineWidth(line);\n\n      if ((info.lineType & LineType.FirstParagraphLine) > 0) {\n        lineWidth += this.getLineIndent(firstLine);\n      }\n    }\n\n    info.text = line;\n    info.width = lineWidth;\n    return info;\n  };\n  /**\n   * Returns `wrap` type.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.getWrapType = function () {\n    var wrapType = this.format != null ? this.format.wordWrap : PdfWordWrapType.Word;\n    return wrapType;\n  };\n\n  return PdfStringLayouter;\n}();\n\nexport { PdfStringLayouter }; //Internal declaration\n\nvar PdfStringLayoutResult =\n/** @class */\nfunction () {\n  function PdfStringLayoutResult() {}\n\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"remainder\", {\n    // Properties\n\n    /**\n     * Gets the `text` which is not lay outed.\n     * @private\n     */\n    get: function get() {\n      return this.textRemainder;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"actualSize\", {\n    /**\n     * Gets the actual layout text `bounds`.\n     * @private\n     */\n    get: function get() {\n      if (typeof this.size === 'undefined') {\n        this.size = new SizeF(0, 0);\n      }\n\n      return this.size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"lines\", {\n    /**\n     * Gets layout `lines` information.\n     * @private\n     */\n    get: function get() {\n      return this.layoutLines;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"lineHeight\", {\n    /**\n     * Gets the `height` of the line.\n     * @private\n     */\n    get: function get() {\n      return this.layoutLineHeight;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"empty\", {\n    /**\n     * Gets value that indicates whether any layout text [`empty`].\n     * @private\n     */\n    get: function get() {\n      return this.layoutLines == null || this.layoutLines.length === 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"lineCount\", {\n    /**\n     * Gets `number of` the layout lines.\n     * @private\n     */\n    get: function get() {\n      var count = !this.empty ? this.layoutLines.length : 0;\n      return count;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return PdfStringLayoutResult;\n}();\n\nexport { PdfStringLayoutResult };\n\nvar LineInfo =\n/** @class */\nfunction () {\n  function LineInfo() {}\n\n  Object.defineProperty(LineInfo.prototype, \"lineType\", {\n    //Properties\n\n    /**\n     * Gets the `type` of the line text.\n     * @private\n     */\n    get: function get() {\n      return this.type;\n    },\n    set: function set(value) {\n      this.type = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LineInfo.prototype, \"text\", {\n    /**\n     * Gets the line `text`.\n     * @private\n     */\n    get: function get() {\n      return this.content;\n    },\n    set: function set(value) {\n      this.content = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LineInfo.prototype, \"width\", {\n    /**\n     * Gets `width` of the line text.\n     * @private\n     */\n    get: function get() {\n      return this.lineWidth;\n    },\n    set: function set(value) {\n      this.lineWidth = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return LineInfo;\n}();\n\nexport { LineInfo };\n/**\n* Break type of the `line`.\n* @private\n*/\n\nexport var LineType;\n\n(function (LineType) {\n  /**\n   * Specifies the type of `None`.\n   * @private\n   */\n  LineType[LineType[\"None\"] = 0] = \"None\";\n  /**\n   * Specifies the type of `NewLineBreak`.\n   * @private\n   */\n\n  LineType[LineType[\"NewLineBreak\"] = 1] = \"NewLineBreak\";\n  /**\n   * Specifies the type of `LayoutBreak`.\n   * @private\n   */\n\n  LineType[LineType[\"LayoutBreak\"] = 2] = \"LayoutBreak\";\n  /**\n   * Specifies the type of `FirstParagraphLine`.\n   * @private\n   */\n\n  LineType[LineType[\"FirstParagraphLine\"] = 4] = \"FirstParagraphLine\";\n  /**\n   * Specifies the type of `LastParagraphLine`.\n   * @private\n   */\n\n  LineType[LineType[\"LastParagraphLine\"] = 8] = \"LastParagraphLine\";\n})(LineType || (LineType = {}));","map":{"version":3,"names":["SizeF","RectangleF","PointF","PdfWordWrapType","StringTokenizer","PdfStringLayouter","isOverloadWithPosition","prototype","layout","arg1","arg2","arg3","arg4","arg5","arg6","arg7","initialize","clientSize","result","doLayout","clear","text","font","format","rectSize","pageHeight","Error","size","width","height","rectangle","reader","close","PdfStringLayoutResult","lineResult","lines","line","peekLine","lineIndent","getLineIndent","layoutLine","numSymbolsInserted","returnedValue","copyToResult","success","numInserted","read","readLine","finalizeResult","firstLine","firstLineIndent","paragraphIndent","Math","min","getLineHeight","lineSpacing","getLineWidth","layoutLineHeight","maxWidth","lineWidth","lineType","LineType","FirstParagraphLine","readWord","round","addToLineResult","NewLineBreak","builder","curLine","curIndent","word","peekWord","isSingleWord","length","position","curLineWidth","toString","getWrapType","None","WordOnly","textRemainder","substring","peek","wordWrap","Character","Word","ln","LayoutBreak","LastParagraphLine","layoutLines","index","push","breakType","info","LineInfo","actualSize","max","allowPartialLines","lineLimit","maxHeight","y","i","len","expHeight","lineHeight","trimLine","size1","end","readToEnd","trimStartSpaces","start","rightToLeft","spaces","trim","wrapType","Object","defineProperty","get","enumerable","configurable","count","empty","type","set","value","content"],"sources":["D:/Theme/package/node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/string-layouter.js"],"sourcesContent":["import { SizeF, RectangleF, PointF } from './../../drawing/pdf-drawing';\nimport { PdfWordWrapType } from './enum';\nimport { StringTokenizer } from './string-tokenizer';\n/**\n * Class `lay outing the text`.\n */\nvar PdfStringLayouter = /** @class */ (function () {\n    // Constructors\n    /**\n     * Initializes a new instance of the `StringLayouter` class.\n     * @private\n     */\n    function PdfStringLayouter() {\n        /**\n         * Checks whether the x co-ordinate is need to set as client size or not.\n         * @hidden\n         * @private\n         */\n        this.isOverloadWithPosition = false;\n        //\n    }\n    PdfStringLayouter.prototype.layout = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n        if (arg4 instanceof RectangleF) {\n            this.initialize(arg1, arg2, arg3, arg4, arg5);\n            this.isOverloadWithPosition = arg6;\n            this.clientSize = arg7;\n            var result = this.doLayout();\n            this.clear();\n            return result;\n        }\n        else {\n            this.initialize(arg1, arg2, arg3, arg4);\n            this.isOverloadWithPosition = arg5;\n            this.clientSize = arg6;\n            var result = this.doLayout();\n            this.clear();\n            return result;\n        }\n    };\n    PdfStringLayouter.prototype.initialize = function (text, font, format, rectSize, pageHeight) {\n        if (typeof pageHeight === 'number') {\n            if (text == null) {\n                throw new Error('ArgumentNullException:text');\n            }\n            if (font == null) {\n                throw new Error('ArgumentNullException:font');\n            }\n            this.text = text;\n            this.font = font;\n            this.format = format;\n            this.size = new SizeF(rectSize.width, rectSize.height);\n            this.rectangle = rectSize;\n            this.pageHeight = pageHeight;\n            this.reader = new StringTokenizer(text);\n        }\n        else {\n            this.initialize(text, font, format, new RectangleF(new PointF(0, 0), rectSize), 0);\n        }\n    };\n    /**\n     * `Clear` all resources.\n     * @private\n     */\n    PdfStringLayouter.prototype.clear = function () {\n        this.font = null;\n        this.format = null;\n        this.reader.close();\n        this.reader = null;\n        this.text = null;\n    };\n    /**\n     * `Layouts` the text.\n     * @private\n     */\n    PdfStringLayouter.prototype.doLayout = function () {\n        var result = new PdfStringLayoutResult();\n        var lineResult = new PdfStringLayoutResult();\n        var lines = [];\n        var line = this.reader.peekLine();\n        var lineIndent = this.getLineIndent(true);\n        while (line != null) {\n            lineResult = this.layoutLine(line, lineIndent);\n            if (lineResult !== null || typeof lineResult !== 'undefined') {\n                var numSymbolsInserted = 0;\n                /* tslint:disable */\n                var returnedValue = this.copyToResult(result, lineResult, lines, /*out*/ numSymbolsInserted);\n                /* tslint:enable */\n                var success = returnedValue.success;\n                numSymbolsInserted = returnedValue.numInserted;\n                if (!success) {\n                    this.reader.read(numSymbolsInserted);\n                    break;\n                }\n            }\n            // if (lineResult.textRemainder != null && lineResult.textRemainder.length > 0 ) {\n            //     break;\n            // }\n            this.reader.readLine();\n            line = this.reader.peekLine();\n            lineIndent = this.getLineIndent(false);\n        }\n        this.finalizeResult(result, lines);\n        return result;\n    };\n    /**\n     * Returns `line indent` for the line.\n     * @private\n     */\n    PdfStringLayouter.prototype.getLineIndent = function (firstLine) {\n        var lineIndent = 0;\n        if (this.format != null) {\n            lineIndent = (firstLine) ? this.format.firstLineIndent : this.format.paragraphIndent;\n            lineIndent = (this.size.width > 0) ? Math.min(this.size.width, lineIndent) : lineIndent;\n        }\n        return lineIndent;\n    };\n    /**\n     * Calculates `height` of the line.\n     * @private\n     */\n    PdfStringLayouter.prototype.getLineHeight = function () {\n        var height = this.font.height;\n        if (this.format != null && this.format.lineSpacing !== 0) {\n            height = this.format.lineSpacing + this.font.height;\n        }\n        return height;\n    };\n    /**\n     * Calculates `width` of the line.\n     * @private\n     */\n    PdfStringLayouter.prototype.getLineWidth = function (line) {\n        var width = this.font.getLineWidth(line, this.format);\n        return width;\n    };\n    // tslint:disable\n    /**\n     * `Layouts` line.\n     * @private\n     */\n    PdfStringLayouter.prototype.layoutLine = function (line, lineIndent) {\n        var lineResult = new PdfStringLayoutResult();\n        lineResult.layoutLineHeight = this.getLineHeight();\n        var lines = [];\n        var maxWidth = this.size.width;\n        var lineWidth = this.getLineWidth(line) + lineIndent;\n        var lineType = LineType.FirstParagraphLine;\n        var readWord = true;\n        // line is in bounds.\n        if (maxWidth <= 0 || Math.round(lineWidth) <= Math.round(maxWidth)) {\n            this.addToLineResult(lineResult, lines, line, lineWidth, LineType.NewLineBreak | lineType);\n        }\n        else {\n            var builder = '';\n            var curLine = '';\n            lineWidth = lineIndent;\n            var curIndent = lineIndent;\n            var reader = new StringTokenizer(line);\n            var word = reader.peekWord();\n            var isSingleWord = false;\n            if (word.length !== reader.length) {\n                if (word === ' ') {\n                    curLine = curLine + word;\n                    builder = builder + word;\n                    reader.position += 1;\n                    word = reader.peekWord();\n                }\n            }\n            while (word != null) {\n                curLine = curLine + word;\n                var curLineWidth = this.getLineWidth(curLine.toString()) + curIndent /*)*/;\n                if (curLine.toString() === ' ') {\n                    curLine = '';\n                    curLineWidth = 0;\n                }\n                if (curLineWidth > maxWidth) {\n                    if (this.getWrapType() === PdfWordWrapType.None) {\n                        break;\n                    }\n                    if (curLine.length === word.length) {\n                        //  Character wrap is disabled or one symbol is greater than bounds.\n                        if (this.getWrapType() === PdfWordWrapType.WordOnly) {\n                            lineResult.textRemainder = line.substring(reader.position);\n                            break;\n                        }\n                        else if (curLine.length === 1) {\n                            builder = builder + word;\n                            break;\n                        }\n                        else {\n                            readWord = false;\n                            curLine = '';\n                            word = reader.peek().toString();\n                            continue;\n                        }\n                    }\n                    else {\n                        if (this.getLineWidth(word.toString()) > maxWidth) {\n                            this.format.wordWrap = PdfWordWrapType.Character;\n                        }\n                        else {\n                            if (typeof this.format !== 'undefined' && this.format !== null) {\n                                this.format.wordWrap = PdfWordWrapType.Word;\n                            }\n                        }\n                        if (this.getWrapType() !== PdfWordWrapType.Character || !readWord) {\n                            var ln = builder.toString();\n                            // if (ln.indexOf(' ') === -1) {\n                            //     isSingleWord = true;\n                            //     this.addToLineResult(lineResult, lines, curLine, lineWidth, LineType.LayoutBreak | lineType);\n                            // } else {\n                            //     this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);\n                            // }                          \n                            if (ln !== ' ') {\n                                this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);\n                            }\n                            if (this.isOverloadWithPosition) {\n                                maxWidth = this.clientSize.width;\n                            }\n                            curLine = '';\n                            builder = '';\n                            lineWidth = 0;\n                            curIndent = 0;\n                            curLineWidth = 0;\n                            lineType = LineType.None;\n                            // if (isSingleWord) {\n                            //     reader.readWord();\n                            //     readWord = false;\n                            // }\n                            word = (readWord) ? word : reader.peekWord();\n                            //isSingleWord = false;\n                            readWord = true;\n                        }\n                        else {\n                            readWord = false;\n                            curLine = '';\n                            curLine = curLine + builder.toString();\n                            word = reader.peek().toString();\n                        }\n                        continue;\n                    }\n                }\n                /*tslint:disable:max-func-body-length */\n                builder = builder + word;\n                lineWidth = curLineWidth;\n                if (readWord) {\n                    reader.readWord();\n                    word = reader.peekWord();\n                    //isSingleWord = false;\n                }\n                else {\n                    reader.read();\n                    word = reader.peek().toString();\n                }\n            }\n            if (builder.length > 0) {\n                var ln = builder.toString();\n                this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.NewLineBreak | LineType.LastParagraphLine);\n            }\n            reader.close();\n        }\n        lineResult.layoutLines = [];\n        for (var index = 0; index < lines.length; index++) {\n            lineResult.layoutLines.push(lines[index]);\n        }\n        lines = [];\n        return lineResult;\n    };\n    /**\n     * `Adds` line to line result.\n     * @private\n     */\n    PdfStringLayouter.prototype.addToLineResult = function (lineResult, lines, line, lineWidth, breakType) {\n        var info = new LineInfo();\n        info.text = line;\n        info.width = lineWidth;\n        info.lineType = breakType;\n        lines.push(info);\n        var size = lineResult.actualSize;\n        size.height += this.getLineHeight();\n        size.width = Math.max(size.width, lineWidth);\n        lineResult.size = size;\n    };\n    /**\n     * `Copies` layout result from line result to entire result. Checks whether we can proceed lay outing or not.\n     * @private\n     */\n    PdfStringLayouter.prototype.copyToResult = function (result, lineResult, lines, \n    /*out*/ numInserted) {\n        var success = true;\n        var allowPartialLines = (this.format != null && !this.format.lineLimit);\n        var height = result.actualSize.height;\n        var maxHeight = this.size.height;\n        if ((this.pageHeight > 0) && (maxHeight + this.rectangle.y > this.pageHeight)) {\n            maxHeight = this.rectangle.y - this.pageHeight;\n            maxHeight = Math.max(maxHeight, -maxHeight);\n        }\n        numInserted = 0;\n        if (lineResult.lines != null) {\n            for (var i = 0, len = lineResult.lines.length; i < len; i++) {\n                var expHeight = height + lineResult.lineHeight;\n                if (expHeight <= maxHeight || maxHeight <= 0 || allowPartialLines) {\n                    var info = lineResult.lines[i];\n                    numInserted += info.text.length;\n                    info = this.trimLine(info, (lines.length === 0));\n                    lines.push(info);\n                    // Update width.\n                    var size = result.actualSize;\n                    size.width = Math.max(size.width, info.width);\n                    result.size = size;\n                    // The part of the line fits only and it's allowed to use partial lines.\n                    // if (expHeight >= maxHeight && maxHeight > 0 && allowPartialLines)\n                    // {\n                    //     let shouldClip : boolean = (this.format == null || !this.format.noClip);\n                    //     if (shouldClip)\n                    //     {\n                    //         let exceededHeight : number = expHeight - maxHeight;\n                    //         let fitHeight : number  = /*Utils.Round(*/ lineResult.lineHeight - exceededHeight /*)*/;\n                    //         height = /*Utils.Round(*/ height + fitHeight /*)*/;\n                    //     }\n                    //     else\n                    //     {\n                    //         height = expHeight;\n                    //     }\n                    //     success = false;\n                    //     break;\n                    // } else {\n                    height = expHeight;\n                    // }\n                }\n                else {\n                    success = false;\n                    break;\n                }\n            }\n        }\n        if (height != result.size.height) {\n            var size1 = result.actualSize;\n            size1.height = height;\n            result.size = size1;\n        }\n        return { success: success, numInserted: numInserted };\n    };\n    /**\n     * `Finalizes` final result.\n     * @private\n     */\n    PdfStringLayouter.prototype.finalizeResult = function (result, lines) {\n        result.layoutLines = [];\n        for (var index = 0; index < lines.length; index++) {\n            result.layoutLines.push(lines[index]);\n        }\n        result.layoutLineHeight = this.getLineHeight();\n        if (!this.reader.end) {\n            result.textRemainder = this.reader.readToEnd();\n        }\n        lines = [];\n    };\n    /**\n     * `Trims` whitespaces at the line.\n     * @private\n     */\n    PdfStringLayouter.prototype.trimLine = function (info, firstLine) {\n        var line = info.text;\n        var lineWidth = info.width;\n        // Trim start whitespaces if the line is not a start of the paragraph only.\n        var trimStartSpaces = ((info.lineType & LineType.FirstParagraphLine) === 0);\n        var start = (this.format == null || !this.format.rightToLeft);\n        var spaces = StringTokenizer.spaces;\n        line = (start) ? line.trim() : line.trim();\n        // Recalculate line width.\n        if (line.length !== info.text.length) {\n            lineWidth = this.getLineWidth(line);\n            if ((info.lineType & LineType.FirstParagraphLine) > 0) {\n                lineWidth += this.getLineIndent(firstLine);\n            }\n        }\n        info.text = line;\n        info.width = lineWidth;\n        return info;\n    };\n    /**\n     * Returns `wrap` type.\n     * @private\n     */\n    PdfStringLayouter.prototype.getWrapType = function () {\n        var wrapType = (this.format != null) ? this.format.wordWrap : PdfWordWrapType.Word;\n        return wrapType;\n    };\n    return PdfStringLayouter;\n}());\nexport { PdfStringLayouter };\n//Internal declaration\nvar PdfStringLayoutResult = /** @class */ (function () {\n    function PdfStringLayoutResult() {\n    }\n    Object.defineProperty(PdfStringLayoutResult.prototype, \"remainder\", {\n        // Properties\n        /**\n         * Gets the `text` which is not lay outed.\n         * @private\n         */\n        get: function () {\n            return this.textRemainder;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfStringLayoutResult.prototype, \"actualSize\", {\n        /**\n         * Gets the actual layout text `bounds`.\n         * @private\n         */\n        get: function () {\n            if (typeof this.size === 'undefined') {\n                this.size = new SizeF(0, 0);\n            }\n            return this.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfStringLayoutResult.prototype, \"lines\", {\n        /**\n         * Gets layout `lines` information.\n         * @private\n         */\n        get: function () {\n            return this.layoutLines;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfStringLayoutResult.prototype, \"lineHeight\", {\n        /**\n         * Gets the `height` of the line.\n         * @private\n         */\n        get: function () {\n            return this.layoutLineHeight;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfStringLayoutResult.prototype, \"empty\", {\n        /**\n         * Gets value that indicates whether any layout text [`empty`].\n         * @private\n         */\n        get: function () {\n            return (this.layoutLines == null || this.layoutLines.length === 0);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfStringLayoutResult.prototype, \"lineCount\", {\n        /**\n         * Gets `number of` the layout lines.\n         * @private\n         */\n        get: function () {\n            var count = (!this.empty) ? this.layoutLines.length : 0;\n            return count;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PdfStringLayoutResult;\n}());\nexport { PdfStringLayoutResult };\nvar LineInfo = /** @class */ (function () {\n    function LineInfo() {\n    }\n    Object.defineProperty(LineInfo.prototype, \"lineType\", {\n        //Properties\n        /**\n         * Gets the `type` of the line text.\n         * @private\n         */\n        get: function () {\n            return this.type;\n        },\n        set: function (value) {\n            this.type = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LineInfo.prototype, \"text\", {\n        /**\n         * Gets the line `text`.\n         * @private\n         */\n        get: function () {\n            return this.content;\n        },\n        set: function (value) {\n            this.content = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LineInfo.prototype, \"width\", {\n        /**\n         * Gets `width` of the line text.\n         * @private\n         */\n        get: function () {\n            return this.lineWidth;\n        },\n        set: function (value) {\n            this.lineWidth = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return LineInfo;\n}());\nexport { LineInfo };\n/**\n* Break type of the `line`.\n* @private\n*/\nexport var LineType;\n(function (LineType) {\n    /**\n     * Specifies the type of `None`.\n     * @private\n     */\n    LineType[LineType[\"None\"] = 0] = \"None\";\n    /**\n     * Specifies the type of `NewLineBreak`.\n     * @private\n     */\n    LineType[LineType[\"NewLineBreak\"] = 1] = \"NewLineBreak\";\n    /**\n     * Specifies the type of `LayoutBreak`.\n     * @private\n     */\n    LineType[LineType[\"LayoutBreak\"] = 2] = \"LayoutBreak\";\n    /**\n     * Specifies the type of `FirstParagraphLine`.\n     * @private\n     */\n    LineType[LineType[\"FirstParagraphLine\"] = 4] = \"FirstParagraphLine\";\n    /**\n     * Specifies the type of `LastParagraphLine`.\n     * @private\n     */\n    LineType[LineType[\"LastParagraphLine\"] = 8] = \"LastParagraphLine\";\n})(LineType || (LineType = {}));\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}