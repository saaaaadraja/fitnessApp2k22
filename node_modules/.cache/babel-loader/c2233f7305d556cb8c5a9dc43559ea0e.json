{"ast":null,"code":"import { ChartLocation, RectOption, isCollide, isOverlap } from '../../common/utils/helper';\nimport { markerAnimate, appendChildElement, getVisiblePoints } from '../../common/utils/helper';\nimport { getLabelText, convertHexToColor, calculateRect, textElement, colorNameToHex } from '../../common/utils/helper';\nimport { measureText, TextOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { textRender } from '../../common/model/constants';\nimport { createTemplate, getFontStyle, getElement, measureElementRect, templateAnimate, withIn, withInBounds } from '../../common/utils/helper';\nimport { createElement, getValue, extend } from '@syncfusion/ej2-base';\nimport { getPoint, getRotatedRectangleCoordinates, isRotatedRectIntersect } from '../../common/utils/helper';\n/**\n * `DataLabel` module is used to render data label for the data point.\n */\n\nvar DataLabel =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the data label module.\n   * @private\n   */\n  function DataLabel(chart) {\n    this.errorHeight = 0;\n    this.chart = chart;\n  }\n\n  DataLabel.prototype.initPrivateVariables = function (series, marker) {\n    var transform = '';\n    var clipPath = '';\n    var render = series.chart.renderer;\n    var index = series.index === undefined ? series.category : series.index;\n\n    if (series.chart.chartAreaType === 'Cartesian') {\n      transform = 'translate(' + series.clipRect.x + ',' + series.clipRect.y + ')';\n      clipPath = 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')';\n    }\n\n    if (marker.dataLabel.visible) {\n      series.shapeElement = render.createGroup({\n        'id': this.chart.element.id + 'ShapeGroup' + index,\n        'transform': transform,\n        'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'\n      });\n      series.textElement = render.createGroup({\n        'id': this.chart.element.id + 'TextGroup' + index,\n        'transform': transform,\n        'clip-path': clipPath\n      });\n    }\n\n    this.markerHeight = series.type === 'Scatter' || marker.visible ? marker.height / 2 : 0;\n    this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';\n    this.calculateErrorHeight(series, series.marker.dataLabel.position);\n    this.chartBackground = this.chart.chartArea.background === 'transparent' ? this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;\n  };\n\n  DataLabel.prototype.calculateErrorHeight = function (series, position) {\n    if (!series.errorBar.visible) {\n      return null;\n    } else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {\n      var direction = series.errorBar.direction;\n      var positiveHeight = this.chart.errorBarModule.positiveHeight;\n      var negativeHeight = this.chart.errorBarModule.negativeHeight;\n\n      if (this.isRectSeries(series)) {\n        if (position === 'Top' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Minus') {\n            this.errorHeight = negativeHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n\n        if (position === 'Outer' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Plus') {\n            this.errorHeight = positiveHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n      } else {\n        if (position === 'Top' || position === 'Outer' || position === 'Auto') {\n          if ((direction === 'Both' || direction === 'Plus') && !series.chart.isTransposed) {\n            this.errorHeight = positiveHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n\n        if (position === 'Bottom' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Minus') {\n            this.errorHeight = negativeHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n      }\n    } else {\n      this.errorHeight = 0;\n    }\n  };\n\n  DataLabel.prototype.isRectSeries = function (series) {\n    return series.isRectSeries || series.type === 'RangeArea';\n  };\n  /**\n   * Render the data label for series.\n   * @return {void}\n   */\n  // tslint:disable-next-line:max-func-body-length\n\n\n  DataLabel.prototype.render = function (series, chart, dataLabel) {\n    // initialize the private variable\n    this.initPrivateVariables(series, series.marker);\n    var rect;\n    var labelLocation = {\n      x: 0,\n      y: 0\n    };\n    var rgbValue;\n    var contrast;\n    var argsData;\n    var border;\n    var textSize;\n    var angle;\n    var degree;\n    this.inverted = chart.requireInvertedAxis;\n    this.yAxisInversed = series.yAxis.isInversed;\n    var redraw = chart.redraw;\n    var isDataLabelOverlap = false;\n    var coordinatesAfterRotation = [];\n    var templateId = chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';\n    var element = createElement('div', {\n      id: templateId\n    });\n    var visiblePoints = getVisiblePoints(series);\n    var point;\n    var rectCenterX;\n    var rectCenterY; // Data label point iteration started\n\n    for (var i = 0; i < visiblePoints.length; i++) {\n      point = visiblePoints[i];\n\n      if (!dataLabel.showZero && (point.y !== 0 || point.y === 0 && series.emptyPointSettings.mode === 'Zero')) {\n        return null;\n      }\n\n      this.margin = dataLabel.margin;\n      var labelText = [];\n      var labelLength = void 0;\n      var xPos = void 0;\n      var yPos = void 0;\n      var xValue = void 0;\n      var yValue = void 0;\n      var isRender = true;\n      var clip = series.clipRect;\n      var shapeRect = void 0;\n      isDataLabelOverlap = false;\n      angle = degree = dataLabel.angle;\n      border = {\n        width: dataLabel.border.width,\n        color: dataLabel.border.color\n      };\n      var argsFont = extend({}, getValue('properties', dataLabel.font), null, true);\n\n      if (point.symbolLocations.length && point.symbolLocations[0] || series.type === 'BoxAndWhisker' && point.regions.length) {\n        labelText = getLabelText(point, series, chart);\n        labelLength = labelText.length;\n\n        for (var i_1 = 0; i_1 < labelLength; i_1++) {\n          argsData = {\n            cancel: false,\n            name: textRender,\n            series: series,\n            point: point,\n            text: labelText[i_1],\n            border: border,\n            color: dataLabel.fill,\n            template: dataLabel.template,\n            font: argsFont,\n            location: labelLocation,\n            textSize: measureText(labelText[i_1], dataLabel.font)\n          };\n          chart.trigger(textRender, argsData);\n\n          if (!argsData.cancel) {\n            this.fontBackground = argsData.color;\n            this.isDataLabelShape(argsData);\n            this.markerHeight = series.type === 'Bubble' ? point.regions[0].height / 2 : this.markerHeight;\n\n            if (argsData.template !== null) {\n              this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i_1, redraw);\n            } else {\n              textSize = measureText(argsData.text, dataLabel.font);\n              rect = this.calculateTextPosition(point, series, textSize, dataLabel, i_1); // To check whether the polar radar chart datalabel intersects the axis label or not\n\n              if (chart.chartAreaType === 'PolarRadar') {\n                for (var _i = 0, _a = chart.chartAxisLayoutPanel.visibleAxisLabelRect; _i < _a.length; _i++) {\n                  var rectRegion = _a[_i];\n\n                  if (isOverlap(new Rect(rect.x, rect.y, rect.width, rect.height), rectRegion)) {\n                    isRender = false;\n                    break;\n                  }\n                }\n              }\n\n              var actualRect = new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height); //let notOverlapping: boolean;\n\n              if (dataLabel.enableRotation) {\n                var rectCoordinates = this.getRectanglePoints(rect);\n                rectCenterX = rect.x + rect.width / 2;\n                rectCenterY = rect.y + rect.height / 2;\n                coordinatesAfterRotation = getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle);\n                isDataLabelOverlap = this.isDataLabelOverlapWithChartBound(coordinatesAfterRotation, chart, clip);\n\n                if (!isDataLabelOverlap) {\n                  this.chart.rotatedDataLabelCollections.push(coordinatesAfterRotation);\n                  var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;\n\n                  for (var index = currentPointIndex; index >= 0; index--) {\n                    if (this.chart.rotatedDataLabelCollections[currentPointIndex] && this.chart.rotatedDataLabelCollections[index - 1] && isRotatedRectIntersect(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {\n                      isDataLabelOverlap = true;\n                      this.chart.rotatedDataLabelCollections[currentPointIndex] = null;\n                      break;\n                    }\n                  }\n                }\n              } else {\n                isDataLabelOverlap = isCollide(rect, chart.dataLabelCollections, clip);\n              }\n\n              if ((!isDataLabelOverlap || dataLabel.labelIntersectAction === 'None') && isRender) {\n                chart.dataLabelCollections.push(actualRect);\n\n                if (this.isShape) {\n                  shapeRect = chart.renderer.drawRectangle(new RectOption(this.commonId + point.index + '_TextShape_' + i_1, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry), new Int32Array([clip.x, clip.y]));\n\n                  if (series.shapeElement) {\n                    series.shapeElement.appendChild(shapeRect);\n                  }\n                } // Checking the font color\n\n\n                rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\n                contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n                xPos = rect.x + this.margin.left + textSize.width / 2 + labelLocation.x;\n                yPos = rect.y + this.margin.top + textSize.height * 3 / 4 + labelLocation.y;\n                labelLocation = {\n                  x: 0,\n                  y: 0\n                };\n\n                if (angle !== 0 && dataLabel.enableRotation) {\n                  // xValue = xPos - (dataLabel.margin.left) / 2 + (dataLabel.margin.right / 2);\n                  xValue = rectCenterX; //yValue = yPos - (dataLabel.margin.top) / 2 - (textSize.height / dataLabel.margin.top) +\n                  // (dataLabel.margin.bottom) / 2;\n\n                  yValue = rectCenterY;\n                  degree = angle > 360 ? angle - 360 : angle < -360 ? angle + 360 : angle;\n                } else {\n                  degree = 0;\n                  xValue = rect.x;\n                  yValue = rect.y;\n                }\n\n                textElement(chart.renderer, new TextOption(this.commonId + point.index + '_Text_' + i_1, xPos, yPos, 'middle', argsData.text, 'rotate(' + degree + ',' + xValue + ',' + yValue + ')', 'auto', degree), argsData.font, argsData.font.color || (contrast >= 128 || series.type === 'Hilo' ? 'black' : 'white'), series.textElement, false, redraw, true, false, series.chart.duration, series.clipRect);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (element.childElementCount) {\n      if (!chart.enableCanvas) {\n        appendChildElement(chart.enableCanvas, getElement(chart.element.id + '_Secondary_Element'), element, chart.redraw, // tslint:disable-next-line:align\n        false, 'x', 'y', null, '', false, false, null, chart.duration);\n      } else {\n        getElement(chart.element.id + '_Secondary_Element').appendChild(element);\n      }\n    }\n  };\n  /**\n   * Get rect coordinates\n   */\n\n\n  DataLabel.prototype.getRectanglePoints = function (rect) {\n    var loc1 = new ChartLocation(rect.x, rect.y);\n    var loc2 = new ChartLocation(rect.x + rect.width, rect.y);\n    var loc3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n    var loc4 = new ChartLocation(rect.x, rect.y + rect.height);\n    return [loc1, loc2, loc3, loc4];\n  };\n\n  DataLabel.prototype.isDataLabelOverlapWithChartBound = function (rectCoordinates, chart, clip) {\n    for (var index = 0; index < rectCoordinates.length; index++) {\n      if (!withInBounds(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Render the data label template.\n   * @return {void}\n   * @private\n   */\n\n\n  DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {\n    this.margin = {\n      left: 0,\n      right: 0,\n      bottom: 0,\n      top: 0\n    };\n    var clip = series.clipRect;\n    var childElement = createTemplate(createElement('div', {\n      id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_' + point.index + (labelIndex ? '_' + labelIndex : ''),\n      styles: 'position: absolute;background-color:' + data.color + ';' + getFontStyle(dataLabel.font) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'\n    }), point.index, data.template, this.chart, point, series, this.chart.element.id + '_DataLabel', labelIndex);\n    this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);\n  };\n\n  DataLabel.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {\n    var elementRect = measureElementRect(childElement, redraw);\n    var rect = this.calculateTextPosition(point, series, {\n      width: elementRect.width,\n      height: elementRect.height\n    }, dataLabel, labelIndex);\n    var clipWidth = 0;\n    var clipHeight = 0;\n\n    if (isReactCallback) {\n      clipWidth = series.clipRect.x + rect.x + elementRect.width > parentElement.clientWidth ? parentElement.clientWidth - (series.clipRect.x + rect.x) : 0;\n      clipHeight = series.points.length - 1 === point.index ? elementRect.height / 2 : 0;\n    }\n\n    childElement.style.left = (this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x - clipWidth + 'px';\n    childElement.style.top = (this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + clipHeight + 'px';\n    var rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\n    var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;\n    var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;\n    childElement.style.color = dataLabel.font.color || (Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000) >= 128 ? 'black' : 'white');\n\n    if (childElement.childElementCount && (!isCollide(rect, this.chart.dataLabelCollections, clip) || dataLabel.labelIntersectAction === 'None') && (series.seriesType !== 'XY' || point.yValue === undefined || withIn(point.yValue, series.yAxis.visibleRange) || series.type.indexOf('Stacking') > -1 || series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange)) && withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y && parseFloat(childElement.style.left) >= hAxis.rect.x && parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height && parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {\n      this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));\n      appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');\n\n      if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {\n        this.doDataLabelAnimation(series, childElement);\n      } else if (this.chart.enableCanvas) {\n        parentElement.appendChild(childElement);\n      }\n    }\n  };\n\n  DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {\n    var labelRegion = labelIndex > 1 ? series.type === 'Candle' ? point.regions[1] : point.regions[0] : point.regions[0];\n\n    if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n      labelRegion = labelIndex === 2 ? point.regions[1] : point.regions[2];\n    }\n\n    var location;\n    location = this.getLabelLocation(point, series, textSize, labelIndex);\n    var padding = 5;\n    var clipRect = series.clipRect;\n    var rect; // calculating alignment\n\n    if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {\n      this.locationX = location.x;\n      var alignmentValue = textSize.height + this.borderWidth * 2 + this.markerHeight + this.margin.bottom + this.margin.top + padding;\n      location.y = dataLabel.position === 'Auto' ? location.y : this.calculateAlignment(alignmentValue, location.y, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false); // calculating position\n\n      location.y = !this.isRectSeries(series) || series.type === 'BoxAndWhisker' ? this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) : this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n\n      if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {\n        location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);\n      }\n    } else {\n      this.locationY = location.y;\n      var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;\n      location.x = dataLabel.position === 'Auto' ? location.x : this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);\n      location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n    }\n\n    rect = calculateRect(location, textSize, this.margin); // Checking the condition whether data Label has been exist the clip rect\n\n    if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) && !(rect.y > clipRect.y + clipRect.height || rect.x > clipRect.x + clipRect.width || rect.x + rect.width < 0 || rect.y + rect.height < 0)) {\n      rect.x = rect.x < 0 ? padding : rect.x;\n      rect.y = rect.y < 0 && !(dataLabel.labelIntersectAction === 'None') ? padding : rect.y;\n      rect.x -= rect.x + rect.width > clipRect.x + clipRect.width ? rect.x + rect.width - (clipRect.x + clipRect.width) + padding : 0;\n      rect.y -= rect.y + rect.height > clipRect.y + clipRect.height ? rect.y + rect.height - (clipRect.y + clipRect.height) + padding : 0;\n      this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n    }\n\n    return rect;\n  }; // Calculation label location for polar column draw types\n\n\n  DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex, alignment, alignmentValue) {\n    var padding = 5;\n    var columnRadius;\n    var chartWidth = this.chart.availableSize.width;\n    var alignmentSign = alignment === 'Center' ? 0 : alignment === 'Far' ? 1 : -1;\n    var angle = point.regionData.startAngle - 0.5 * Math.PI + (point.regionData.endAngle - point.regionData.startAngle) / 2;\n\n    if (labelIndex === 0) {\n      columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius : point.regionData.radius;\n    } else {\n      columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius : point.regionData.radius;\n    }\n\n    this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n\n    if (series.drawType.indexOf('Stacking') > -1) {\n      position = position === 'Outer' ? 'Top' : position;\n    } else if (series.drawType.indexOf('Range') > -1) {\n      position = position === 'Outer' || position === 'Top' ? position : 'Auto';\n    }\n\n    if (position === 'Outer') {\n      columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight : columnRadius - 2 * padding - this.markerHeight;\n    } else if (position === 'Middle') {\n      columnRadius = columnRadius / 2 + padding;\n\n      if (series.drawType === 'StackingColumn') {\n        columnRadius = point.regionData.innerRadius + (point.regionData.radius - point.regionData.innerRadius) / 2 + padding - size.height / 2;\n      }\n    } else if (position === 'Top') {\n      columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight : columnRadius + 2 * padding + this.markerHeight;\n    } else if (position === 'Bottom') {\n      columnRadius = 2 * padding;\n      columnRadius += series.drawType === 'StackingColumn' ? point.regionData.innerRadius + this.markerHeight : 0;\n    } else {\n      if (labelIndex === 0) {\n        columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding : series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;\n      } else {\n        columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;\n      }\n    }\n\n    columnRadius += alignmentValue * alignmentSign;\n    location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle); // To change x location based on text anchor for column and stackingcolumn chart\n\n    if (series.drawType === 'StackingColumn') {\n      location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 : location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x;\n    } else if (series.drawType === 'Column') {\n      location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 : location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x;\n    }\n\n    location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);\n    return location;\n  };\n  /**\n   * Get the label location\n   */\n\n\n  DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {\n    var location = new ChartLocation(0, 0);\n    var labelRegion = series.type === 'Candle' && labelIndex > 1 ? point.regions[1] : point.regions[0];\n\n    if (series.type === 'HiloOpenClose') {\n      labelRegion = labelIndex === 2 ? point.regions[1] : point.regions[2];\n    }\n\n    var xAxis = series.xAxis;\n    var yAxis = series.yAxis;\n    var isInverted = series.chart.requireInvertedAxis;\n\n    if (series.type === 'BoxAndWhisker') {\n      this.markerHeight = 0;\n\n      switch (labelIndex) {\n        case 0:\n          location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);\n          break;\n\n        case 1:\n          location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);\n          break;\n\n        case 2:\n          location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);\n          break;\n\n        case 3:\n          location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);\n          break;\n\n        case 4:\n          location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);\n          break;\n\n        default:\n          {\n            location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);\n            this.markerHeight = series.marker.height / 2;\n            break;\n          }\n      }\n\n      if (isInverted) {\n        location.y = point.regions[0].y + point.regions[0].height / 2;\n      } else {\n        location.x = point.regions[0].x + point.regions[0].width / 2;\n      }\n    } else if (labelIndex === 0 || labelIndex === 1) {\n      location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);\n    } else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {\n      location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);\n    } else if (isInverted) {\n      location = {\n        x: labelRegion.x + labelRegion.width / 2,\n        y: labelRegion.y\n      };\n    } else {\n      location = {\n        x: labelRegion.x + labelRegion.width,\n        y: labelRegion.y + labelRegion.height / 2\n      };\n    } //Aligning the label at the beginning of the tick, when tick size is less than text size\n\n\n    if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n      if (series.chart.requireInvertedAxis) {\n        var height = labelRegion.height;\n        location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n      } else {\n        var width = labelRegion.width;\n        location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n      }\n    }\n\n    return location;\n  };\n\n  DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {\n    if (series.chart.chartAreaType === 'PolarRadar') {\n      return null;\n    }\n\n    var padding = 5;\n    var margin = this.margin;\n    var textLength = !this.inverted ? textSize.height : textSize.width;\n    var extraSpace = this.borderWidth + textLength / 2 + padding;\n\n    if (series.type === 'StackingColumn100' || series.type === 'StackingBar100') {\n      position = position === 'Outer' ? 'Top' : position;\n    } else if (series.type.indexOf('Range') > -1) {\n      position = position === 'Outer' || position === 'Top' ? position : 'Auto';\n    } else if (series.type === 'Waterfall') {\n      position = position === 'Auto' ? 'Middle' : position;\n    }\n\n    switch (position) {\n      case 'Bottom':\n        labelLocation = !this.inverted ? isMinus ? labelLocation - rect.height + extraSpace + margin.top : labelLocation + rect.height - extraSpace - margin.bottom : isMinus ? labelLocation + rect.width - extraSpace - margin.left : labelLocation - rect.width + extraSpace + margin.right;\n        break;\n\n      case 'Middle':\n        labelLocation = labelLocation = !this.inverted ? isMinus ? labelLocation - rect.height / 2 : labelLocation + rect.height / 2 : isMinus ? labelLocation + rect.width / 2 : labelLocation - rect.width / 2;\n        break;\n\n      case 'Auto':\n        labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);\n        break;\n\n      default:\n        extraSpace += this.errorHeight;\n        labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, extraSpace, isMinus);\n        break;\n    }\n\n    var check = !this.inverted ? labelLocation < rect.y || labelLocation > rect.y + rect.height : labelLocation < rect.x || labelLocation > rect.x + rect.width;\n    this.fontBackground = check ? this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground : this.fontBackground === 'transparent' ? point.color || series.interior : this.fontBackground;\n    var seriesLength = series.chart.series.length;\n\n    if (position === 'Outer' && series.type.indexOf('Stacking') > -1 && seriesLength - 1 > series.index) {\n      var nextSeries = void 0;\n      var nextSeriesPoint = void 0;\n\n      for (var i = series.index + 1; i < seriesLength; i++) {\n        nextSeries = series.chart.series[i];\n        nextSeriesPoint = nextSeries.points[point.index];\n\n        if (nextSeries.type.indexOf('Stacking') > -1 && nextSeries.type.indexOf('100') === -1) {\n          this.fontBackground = nextSeriesPoint && (nextSeriesPoint.yValue < 0 && point.yValue < 0 || nextSeriesPoint.yValue > 0 && point.yValue > 0) ? nextSeriesPoint ? nextSeriesPoint.color : nextSeries.interior : this.fontBackground;\n          break;\n        }\n      }\n    }\n\n    return labelLocation;\n  };\n\n  DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {\n    var padding = 5;\n\n    if (series.type.indexOf('Area') > -1 && series.type !== 'RangeArea' && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {\n      position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;\n    }\n\n    this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n\n    switch (position) {\n      case 'Top':\n      case 'Outer':\n        labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding - this.errorHeight;\n        break;\n\n      case 'Bottom':\n        labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding + this.errorHeight;\n        break;\n\n      case 'Auto':\n        labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);\n        break;\n    }\n\n    return labelLocation;\n  };\n\n  DataLabel.prototype.isDataLabelShape = function (style) {\n    this.isShape = style.color !== 'transparent' || style.border.width > 0;\n    this.borderWidth = style.border.width;\n\n    if (!this.isShape) {\n      this.margin = {\n        left: 0,\n        right: 0,\n        bottom: 0,\n        top: 0\n      };\n    }\n  };\n\n  DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {\n    var location;\n    var labelRect;\n    var isOverLap = true;\n    var position = 0;\n    var collection = this.chart.dataLabelCollections;\n    var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;\n\n    while (isOverLap && position < finalPosition) {\n      var actualPosition = this.getPosition(position);\n\n      if (series.type.indexOf('Stacking') > -1 && actualPosition === 'Outer') {\n        actualPosition = 'Top';\n        position++;\n      }\n\n      location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);\n\n      if (!this.inverted) {\n        labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);\n        isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;\n      } else {\n        labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);\n        isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.x + labelRect.width > series.clipRect.width;\n      }\n\n      position++;\n    }\n\n    return location;\n  }; // alignment calculation assigned here\n\n\n  DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {\n    switch (alignment) {\n      case 'Far':\n        labelLocation = !this.inverted ? isMinus ? labelLocation + value : labelLocation - value : isMinus ? labelLocation - value : labelLocation + value;\n        break;\n\n      case 'Near':\n        labelLocation = !this.inverted ? isMinus ? labelLocation - value : labelLocation + value : isMinus ? labelLocation + value : labelLocation - value;\n        break;\n\n      case 'Center':\n        labelLocation = labelLocation;\n        break;\n    }\n\n    return labelLocation;\n  }; //calculation for top and outer position of datalabel for rect series\n\n\n  DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus) {\n    var margin = this.margin;\n    var top;\n\n    switch (series.type) {\n      case 'RangeColumn':\n      case 'RangeArea':\n      case 'Hilo':\n        top = index === 0 && !this.yAxisInversed || index === 1 && this.yAxisInversed;\n        location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n        break;\n\n      case 'Candle':\n        top = (index === 0 || index === 2) && !this.yAxisInversed || (index === 1 || index === 3) && this.yAxisInversed;\n        location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);\n        break;\n\n      case 'HiloOpenClose':\n        if (index <= 1) {\n          top = index === 0 && !this.yAxisInversed || index === 1 && this.yAxisInversed;\n          location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n        } else {\n          if (this.yAxisInversed) {\n            location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;\n          } else {\n            location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;\n          }\n        }\n\n        break;\n\n      default:\n        if (isMinus && position === 'Top' || !isMinus && position === 'Outer') {\n          location = !this.inverted ? location - extraSpace - margin.bottom - this.markerHeight : location + extraSpace + margin.left + this.markerHeight;\n        } else {\n          location = !this.inverted ? location + extraSpace + margin.top + this.markerHeight : location - extraSpace - margin.right - this.markerHeight;\n        }\n\n        break;\n    }\n\n    return location;\n  };\n  /**\n   * Updates the label location\n   */\n\n\n  DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside) {\n    if (inside === void 0) {\n      inside = false;\n    }\n\n    if (!this.inverted) {\n      if (top) {\n        location = position === 'Outer' && !inside ? location - extraSpace - margin.bottom - this.markerHeight : location + extraSpace + margin.top + this.markerHeight;\n      } else {\n        location = position === 'Outer' && !inside ? location + rect.height + extraSpace + margin.top + this.markerHeight : location + rect.height - extraSpace - margin.bottom - this.markerHeight;\n      }\n    } else {\n      if (top) {\n        location = position === 'Outer' && !inside ? location + extraSpace + margin.left + this.markerHeight : location - extraSpace - margin.right - this.markerHeight;\n      } else {\n        location = position === 'Outer' && !inside ? location - rect.width - extraSpace - margin.right - this.markerHeight : location - rect.width + extraSpace + margin.left + this.markerHeight;\n      }\n    }\n\n    return location;\n  };\n\n  DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {\n    var points = series.points;\n    var index = point.index;\n    var yValue = points[index].yValue;\n    var position;\n    var nextPoint = points.length - 1 > index ? points[index + 1] : null;\n    var previousPoint = index > 0 ? points[index - 1] : null;\n    var yLocation;\n    var isOverLap = true;\n    var labelRect;\n    var isBottom;\n    var positionIndex;\n    var collection = this.chart.dataLabelCollections;\n\n    if (series.type === 'Bubble') {\n      position = 'Top';\n    } else if (series.type.indexOf('Step') > -1) {\n      position = 'Top';\n\n      if (index) {\n        position = !previousPoint || !previousPoint.visible || yValue > previousPoint.yValue !== this.yAxisInversed || yValue === previousPoint.yValue ? 'Top' : 'Bottom';\n      }\n    } else if (series.type === 'BoxAndWhisker') {\n      if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {\n        position = series.yAxis.isInversed ? 'Bottom' : 'Top';\n      } else if (labelIndex === 2 || labelIndex === 4) {\n        position = series.yAxis.isInversed ? 'Top' : 'Bottom';\n      } else {\n        isOverLap = false;\n        position = 'Middle';\n        yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);\n      }\n    } else {\n      if (index === 0) {\n        position = !nextPoint || !nextPoint.visible || yValue > nextPoint.yValue || yValue < nextPoint.yValue && this.yAxisInversed ? 'Top' : 'Bottom';\n      } else if (index === points.length - 1) {\n        position = !previousPoint || !previousPoint.visible || yValue > previousPoint.yValue || yValue < previousPoint.yValue && this.yAxisInversed ? 'Top' : 'Bottom';\n      } else {\n        if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {\n          position = 'Top';\n        } else if (!nextPoint.visible || !previousPoint) {\n          position = nextPoint.yValue > yValue || previousPoint && previousPoint.yValue > yValue ? 'Bottom' : 'Top';\n        } else {\n          var slope = (nextPoint.yValue - previousPoint.yValue) / 2;\n          var intersectY = slope * index + (nextPoint.yValue - slope * (index + 1));\n          position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' : intersectY < yValue ? 'Bottom' : 'Top';\n        }\n      }\n    }\n\n    isBottom = position === 'Bottom';\n    positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);\n\n    while (isOverLap && positionIndex < 4) {\n      yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);\n      labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);\n      isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y + labelRect.height > series.clipRect.height;\n      positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;\n      isBottom = false;\n    }\n\n    return yLocation;\n  };\n  /**\n   * Animates the data label.\n   * @param  {Series} series - Data label of the series gets animated.\n   * @return {void}\n   */\n\n\n  DataLabel.prototype.doDataLabelAnimation = function (series, element) {\n    var shapeElements = series.shapeElement.childNodes;\n    var textNode = series.textElement.childNodes;\n    var delay = series.animation.delay + series.animation.duration;\n    var duration = series.chart.animated ? series.chart.duration : 200;\n    var location;\n    var length = element ? 1 : textNode.length;\n    var tempElement;\n\n    for (var i = 0; i < length; i++) {\n      tempElement = textNode[i];\n\n      if (element) {\n        element.style.visibility = 'hidden';\n        templateAnimate(element, delay, duration, 'ZoomIn');\n      } else {\n        location = new ChartLocation(+tempElement.getAttribute('x') + +tempElement.getAttribute('width') / 2, +tempElement.getAttribute('y') + +tempElement.getAttribute('height') / 2);\n        markerAnimate(tempElement, delay, duration, series, null, location, true);\n\n        if (shapeElements[i]) {\n          tempElement = shapeElements[i];\n          location = new ChartLocation(+tempElement.getAttribute('x') + +tempElement.getAttribute('width') / 2, +tempElement.getAttribute('y') + +tempElement.getAttribute('height') / 2);\n          markerAnimate(tempElement, delay, duration, series, null, location, true);\n        }\n      }\n    }\n  };\n\n  DataLabel.prototype.getPosition = function (index) {\n    return ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index];\n  };\n  /**\n   * Get module name.\n   */\n\n\n  DataLabel.prototype.getModuleName = function () {\n    // Returns the module name\n    return 'DataLabel';\n  };\n  /**\n   * To destroy the dataLabel for series.\n   * @return {void}\n   * @private\n   */\n\n\n  DataLabel.prototype.destroy = function (chart) {// Destroy method performed here\n  };\n\n  return DataLabel;\n}();\n\nexport { DataLabel };","map":{"version":3,"names":["ChartLocation","RectOption","isCollide","isOverlap","markerAnimate","appendChildElement","getVisiblePoints","getLabelText","convertHexToColor","calculateRect","textElement","colorNameToHex","measureText","TextOption","Rect","textRender","createTemplate","getFontStyle","getElement","measureElementRect","templateAnimate","withIn","withInBounds","createElement","getValue","extend","getPoint","getRotatedRectangleCoordinates","isRotatedRectIntersect","DataLabel","chart","errorHeight","prototype","initPrivateVariables","series","marker","transform","clipPath","render","renderer","index","undefined","category","chartAreaType","clipRect","x","y","element","id","dataLabel","visible","shapeElement","createGroup","markerHeight","type","height","commonId","calculateErrorHeight","position","chartBackground","chartArea","background","themeStyle","errorBar","direction","positiveHeight","errorBarModule","negativeHeight","isRectSeries","isTransposed","rect","labelLocation","rgbValue","contrast","argsData","border","textSize","angle","degree","inverted","requireInvertedAxis","yAxisInversed","yAxis","isInversed","redraw","isDataLabelOverlap","coordinatesAfterRotation","templateId","visiblePoints","point","rectCenterX","rectCenterY","i","length","showZero","emptyPointSettings","mode","margin","labelText","labelLength","xPos","yPos","xValue","yValue","isRender","clip","shapeRect","width","color","argsFont","font","symbolLocations","regions","i_1","cancel","name","text","fill","template","location","trigger","fontBackground","isDataLabelShape","createDataLabelTemplate","calculateTextPosition","_i","_a","chartAxisLayoutPanel","visibleAxisLabelRect","rectRegion","actualRect","enableRotation","rectCoordinates","getRectanglePoints","isDataLabelOverlapWithChartBound","rotatedDataLabelCollections","push","currentPointIndex","dataLabelCollections","labelIntersectAction","isShape","drawRectangle","opacity","rx","ry","Int32Array","appendChild","Math","round","r","g","b","left","top","duration","childElementCount","enableCanvas","loc1","loc2","loc3","loc4","initialClipRect","parentElement","data","labelIndex","right","bottom","childElement","styles","calculateTemplateLabelSize","isReactCallback","elementRect","clipWidth","clipHeight","clientWidth","points","style","vAxis","xAxis","hAxis","seriesType","visibleRange","indexOf","stackedValues","endValues","parseFloat","animation","enable","animateSeries","doDataLabelAnimation","labelRegion","getLabelLocation","padding","locationX","alignmentValue","borderWidth","calculateAlignment","alignment","calculatePathPosition","calculateRectPosition","calculatePolarRectPosition","locationY","size","columnRadius","chartWidth","availableSize","alignmentSign","regionData","startAngle","PI","endAngle","radius","innerRadius","drawType","cos","sin","isInverted","median","maximum","minimum","upperQuartile","lowerQuartile","outliers","isMinus","textLength","extraSpace","calculateRectActualPosition","calculateTopAndOuterPosition","check","interior","seriesLength","nextSeries","nextSeriesPoint","calculatePathActualPosition","labelRect","isOverLap","collection","finalPosition","actualPosition","getPosition","value","updateLabelLocation","inside","markerSize","nextPoint","previousPoint","yLocation","isBottom","positionIndex","slope","intersectY","shapeElements","childNodes","textNode","delay","animated","tempElement","visibility","getAttribute","getModuleName","destroy"],"sources":["D:/Theme/package/node_modules/@syncfusion/ej2-charts/src/chart/series/data-label.js"],"sourcesContent":["import { ChartLocation, RectOption, isCollide, isOverlap } from '../../common/utils/helper';\nimport { markerAnimate, appendChildElement, getVisiblePoints } from '../../common/utils/helper';\nimport { getLabelText, convertHexToColor, calculateRect, textElement, colorNameToHex } from '../../common/utils/helper';\nimport { measureText, TextOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { textRender } from '../../common/model/constants';\nimport { createTemplate, getFontStyle, getElement, measureElementRect, templateAnimate, withIn, withInBounds } from '../../common/utils/helper';\nimport { createElement, getValue, extend } from '@syncfusion/ej2-base';\nimport { getPoint, getRotatedRectangleCoordinates, isRotatedRectIntersect } from '../../common/utils/helper';\n/**\n * `DataLabel` module is used to render data label for the data point.\n */\nvar DataLabel = /** @class */ (function () {\n    /**\n     * Constructor for the data label module.\n     * @private\n     */\n    function DataLabel(chart) {\n        this.errorHeight = 0;\n        this.chart = chart;\n    }\n    DataLabel.prototype.initPrivateVariables = function (series, marker) {\n        var transform = '';\n        var clipPath = '';\n        var render = series.chart.renderer;\n        var index = (series.index === undefined) ? series.category : series.index;\n        if (series.chart.chartAreaType === 'Cartesian') {\n            transform = 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')';\n            clipPath = 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')';\n        }\n        if (marker.dataLabel.visible) {\n            series.shapeElement = render.createGroup({\n                'id': this.chart.element.id + 'ShapeGroup' + index,\n                'transform': transform,\n                'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'\n            });\n            series.textElement = render.createGroup({\n                'id': this.chart.element.id + 'TextGroup' + index,\n                'transform': transform,\n                'clip-path': clipPath\n            });\n        }\n        this.markerHeight = ((series.type === 'Scatter' || marker.visible)) ? (marker.height / 2) : 0;\n        this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';\n        this.calculateErrorHeight(series, series.marker.dataLabel.position);\n        this.chartBackground = this.chart.chartArea.background === 'transparent' ?\n            this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;\n    };\n    DataLabel.prototype.calculateErrorHeight = function (series, position) {\n        if (!series.errorBar.visible) {\n            return null;\n        }\n        else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {\n            var direction = series.errorBar.direction;\n            var positiveHeight = this.chart.errorBarModule.positiveHeight;\n            var negativeHeight = this.chart.errorBarModule.negativeHeight;\n            if (this.isRectSeries(series)) {\n                if (position === 'Top' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Minus') {\n                        this.errorHeight = negativeHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n                if (position === 'Outer' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Plus') {\n                        this.errorHeight = positiveHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n            }\n            else {\n                if (position === 'Top' || position === 'Outer' || position === 'Auto') {\n                    if ((direction === 'Both' || direction === 'Plus') && (!series.chart.isTransposed)) {\n                        this.errorHeight = positiveHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n                if (position === 'Bottom' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Minus') {\n                        this.errorHeight = negativeHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n            }\n        }\n        else {\n            this.errorHeight = 0;\n        }\n    };\n    DataLabel.prototype.isRectSeries = function (series) {\n        return series.isRectSeries || series.type === 'RangeArea';\n    };\n    /**\n     * Render the data label for series.\n     * @return {void}\n     */\n    // tslint:disable-next-line:max-func-body-length\n    DataLabel.prototype.render = function (series, chart, dataLabel) {\n        // initialize the private variable\n        this.initPrivateVariables(series, series.marker);\n        var rect;\n        var labelLocation = { x: 0, y: 0 };\n        var rgbValue;\n        var contrast;\n        var argsData;\n        var border;\n        var textSize;\n        var angle;\n        var degree;\n        this.inverted = chart.requireInvertedAxis;\n        this.yAxisInversed = series.yAxis.isInversed;\n        var redraw = chart.redraw;\n        var isDataLabelOverlap = false;\n        var coordinatesAfterRotation = [];\n        var templateId = chart.element.id + '_Series_' +\n            (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';\n        var element = createElement('div', {\n            id: templateId\n        });\n        var visiblePoints = getVisiblePoints(series);\n        var point;\n        var rectCenterX;\n        var rectCenterY;\n        // Data label point iteration started\n        for (var i = 0; i < visiblePoints.length; i++) {\n            point = visiblePoints[i];\n            if (!dataLabel.showZero && ((point.y !== 0) || (point.y === 0 && series.emptyPointSettings.mode === 'Zero'))) {\n                return null;\n            }\n            this.margin = dataLabel.margin;\n            var labelText = [];\n            var labelLength = void 0;\n            var xPos = void 0;\n            var yPos = void 0;\n            var xValue = void 0;\n            var yValue = void 0;\n            var isRender = true;\n            var clip = series.clipRect;\n            var shapeRect = void 0;\n            isDataLabelOverlap = false;\n            angle = degree = dataLabel.angle;\n            border = { width: dataLabel.border.width, color: dataLabel.border.color };\n            var argsFont = (extend({}, getValue('properties', dataLabel.font), null, true));\n            if ((point.symbolLocations.length && point.symbolLocations[0]) ||\n                (series.type === 'BoxAndWhisker' && point.regions.length)) {\n                labelText = getLabelText(point, series, chart);\n                labelLength = labelText.length;\n                for (var i_1 = 0; i_1 < labelLength; i_1++) {\n                    argsData = {\n                        cancel: false, name: textRender, series: series,\n                        point: point, text: labelText[i_1], border: border,\n                        color: dataLabel.fill, template: dataLabel.template, font: argsFont, location: labelLocation,\n                        textSize: measureText(labelText[i_1], dataLabel.font)\n                    };\n                    chart.trigger(textRender, argsData);\n                    if (!argsData.cancel) {\n                        this.fontBackground = argsData.color;\n                        this.isDataLabelShape(argsData);\n                        this.markerHeight = series.type === 'Bubble' ? (point.regions[0].height / 2) : this.markerHeight;\n                        if (argsData.template !== null) {\n                            this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i_1, redraw);\n                        }\n                        else {\n                            textSize = measureText(argsData.text, dataLabel.font);\n                            rect = this.calculateTextPosition(point, series, textSize, dataLabel, i_1);\n                            // To check whether the polar radar chart datalabel intersects the axis label or not\n                            if (chart.chartAreaType === 'PolarRadar') {\n                                for (var _i = 0, _a = chart.chartAxisLayoutPanel.visibleAxisLabelRect; _i < _a.length; _i++) {\n                                    var rectRegion = _a[_i];\n                                    if (isOverlap(new Rect(rect.x, rect.y, rect.width, rect.height), rectRegion)) {\n                                        isRender = false;\n                                        break;\n                                    }\n                                }\n                            }\n                            var actualRect = new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height);\n                            //let notOverlapping: boolean;\n                            if (dataLabel.enableRotation) {\n                                var rectCoordinates = this.getRectanglePoints(rect);\n                                rectCenterX = rect.x + (rect.width / 2);\n                                rectCenterY = (rect.y + (rect.height / 2));\n                                coordinatesAfterRotation = getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle);\n                                isDataLabelOverlap = this.isDataLabelOverlapWithChartBound(coordinatesAfterRotation, chart, clip);\n                                if (!isDataLabelOverlap) {\n                                    this.chart.rotatedDataLabelCollections.push(coordinatesAfterRotation);\n                                    var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;\n                                    for (var index = currentPointIndex; index >= 0; index--) {\n                                        if (this.chart.rotatedDataLabelCollections[currentPointIndex] &&\n                                            this.chart.rotatedDataLabelCollections[index - 1] &&\n                                            isRotatedRectIntersect(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {\n                                            isDataLabelOverlap = true;\n                                            this.chart.rotatedDataLabelCollections[currentPointIndex] = null;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                            else {\n                                isDataLabelOverlap = isCollide(rect, chart.dataLabelCollections, clip);\n                            }\n                            if ((!isDataLabelOverlap || dataLabel.labelIntersectAction === 'None') && isRender) {\n                                chart.dataLabelCollections.push(actualRect);\n                                if (this.isShape) {\n                                    shapeRect = chart.renderer.drawRectangle(new RectOption(this.commonId + point.index + '_TextShape_' + i_1, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry), new Int32Array([clip.x, clip.y]));\n                                    if (series.shapeElement) {\n                                        series.shapeElement.appendChild(shapeRect);\n                                    }\n                                }\n                                // Checking the font color\n                                rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\n                                contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n                                xPos = (rect.x + this.margin.left + textSize.width / 2) + labelLocation.x;\n                                yPos = (rect.y + this.margin.top + textSize.height * 3 / 4) + labelLocation.y;\n                                labelLocation = { x: 0, y: 0 };\n                                if (angle !== 0 && dataLabel.enableRotation) {\n                                    // xValue = xPos - (dataLabel.margin.left) / 2 + (dataLabel.margin.right / 2);\n                                    xValue = rectCenterX;\n                                    //yValue = yPos - (dataLabel.margin.top) / 2 - (textSize.height / dataLabel.margin.top) +\n                                    // (dataLabel.margin.bottom) / 2;\n                                    yValue = rectCenterY;\n                                    degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;\n                                }\n                                else {\n                                    degree = 0;\n                                    xValue = rect.x;\n                                    yValue = rect.y;\n                                }\n                                textElement(chart.renderer, new TextOption(this.commonId + point.index + '_Text_' + i_1, xPos, yPos, 'middle', argsData.text, 'rotate(' + degree + ',' + (xValue) + ',' + (yValue) + ')', 'auto', degree), argsData.font, argsData.font.color ||\n                                    ((contrast >= 128 || series.type === 'Hilo') ? 'black' : 'white'), series.textElement, false, redraw, true, false, series.chart.duration, series.clipRect);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (element.childElementCount) {\n            if (!chart.enableCanvas) {\n                appendChildElement(chart.enableCanvas, getElement(chart.element.id + '_Secondary_Element'), element, chart.redraw, \n                // tslint:disable-next-line:align\n                false, 'x', 'y', null, '', false, false, null, chart.duration);\n            }\n            else {\n                getElement(chart.element.id + '_Secondary_Element').appendChild(element);\n            }\n        }\n    };\n    /**\n     * Get rect coordinates\n     */\n    DataLabel.prototype.getRectanglePoints = function (rect) {\n        var loc1 = new ChartLocation(rect.x, rect.y);\n        var loc2 = new ChartLocation(rect.x + rect.width, rect.y);\n        var loc3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n        var loc4 = new ChartLocation(rect.x, rect.y + rect.height);\n        return [loc1, loc2, loc3, loc4];\n    };\n    DataLabel.prototype.isDataLabelOverlapWithChartBound = function (rectCoordinates, chart, clip) {\n        for (var index = 0; index < rectCoordinates.length; index++) {\n            if (!withInBounds(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Render the data label template.\n     * @return {void}\n     * @private\n     */\n    DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {\n        this.margin = { left: 0, right: 0, bottom: 0, top: 0 };\n        var clip = series.clipRect;\n        var childElement = createTemplate(createElement('div', {\n            id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_'\n                + point.index + (labelIndex ? ('_' + labelIndex) : ''),\n            styles: 'position: absolute;background-color:' + data.color + ';' +\n                getFontStyle(dataLabel.font) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'\n        }), point.index, data.template, this.chart, point, series, this.chart.element.id + '_DataLabel', labelIndex);\n        this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);\n    };\n    DataLabel.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {\n        var elementRect = measureElementRect(childElement, redraw);\n        var rect = this.calculateTextPosition(point, series, { width: elementRect.width, height: elementRect.height }, dataLabel, labelIndex);\n        var clipWidth = 0;\n        var clipHeight = 0;\n        if (isReactCallback) {\n            clipWidth = ((series.clipRect.x + rect.x) + elementRect.width) > parentElement.clientWidth ?\n                (parentElement.clientWidth - (series.clipRect.x + rect.x)) : 0;\n            clipHeight = (series.points.length - 1 === point.index) ? elementRect.height / 2 : 0;\n        }\n        childElement.style.left = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x - clipWidth) + 'px';\n        childElement.style.top = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + clipHeight) + 'px';\n        var rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\n        var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;\n        var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;\n        childElement.style.color = dataLabel.font.color ||\n            ((Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000)) >= 128 ? 'black' : 'white');\n        if (childElement.childElementCount && (!isCollide(rect, this.chart.dataLabelCollections, clip) ||\n            dataLabel.labelIntersectAction === 'None') && (series.seriesType !== 'XY' || point.yValue === undefined ||\n            withIn(point.yValue, series.yAxis.visibleRange) || (series.type.indexOf('Stacking') > -1) ||\n            (series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange))) &&\n            withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y &&\n            parseFloat(childElement.style.left) >= hAxis.rect.x &&\n            parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height &&\n            parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {\n            this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));\n            appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');\n            if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {\n                this.doDataLabelAnimation(series, childElement);\n            }\n            else if (this.chart.enableCanvas) {\n                parentElement.appendChild(childElement);\n            }\n        }\n    };\n    DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {\n        var labelRegion = labelIndex > 1 ? (series.type === 'Candle') ? point.regions[1] : point.regions[0] : point.regions[0];\n        if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];\n        }\n        var location;\n        location = this.getLabelLocation(point, series, textSize, labelIndex);\n        var padding = 5;\n        var clipRect = series.clipRect;\n        var rect;\n        // calculating alignment\n        if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {\n            this.locationX = location.x;\n            var alignmentValue = textSize.height + (this.borderWidth * 2) + this.markerHeight +\n                this.margin.bottom + this.margin.top + padding;\n            location.y = (dataLabel.position === 'Auto') ? location.y :\n                this.calculateAlignment(alignmentValue, location.y, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false);\n            // calculating position\n            location.y = (!this.isRectSeries(series) || series.type === 'BoxAndWhisker') ?\n                this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) :\n                this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n            if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {\n                location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);\n            }\n        }\n        else {\n            this.locationY = location.y;\n            var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;\n            location.x = dataLabel.position === 'Auto' ? location.x :\n                this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);\n            location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n        }\n        rect = calculateRect(location, textSize, this.margin);\n        // Checking the condition whether data Label has been exist the clip rect\n        if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) &&\n            !((rect.y > (clipRect.y + clipRect.height)) || (rect.x > (clipRect.x + clipRect.width)) ||\n                (rect.x + rect.width < 0) || (rect.y + rect.height < 0))) {\n            rect.x = rect.x < 0 ? padding : rect.x;\n            rect.y = (rect.y < 0) && !(dataLabel.labelIntersectAction === 'None') ? padding : rect.y;\n            rect.x -= (rect.x + rect.width) > (clipRect.x + clipRect.width) ? (rect.x + rect.width)\n                - (clipRect.x + clipRect.width) + padding : 0;\n            rect.y -= (rect.y + rect.height) > (clipRect.y + clipRect.height) ? (rect.y + rect.height)\n                - (clipRect.y + clipRect.height) + padding : 0;\n            this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        }\n        return rect;\n    };\n    // Calculation label location for polar column draw types\n    DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex, alignment, alignmentValue) {\n        var padding = 5;\n        var columnRadius;\n        var chartWidth = this.chart.availableSize.width;\n        var alignmentSign = (alignment === 'Center') ? 0 : (alignment === 'Far' ? 1 : -1);\n        var angle = (point.regionData.startAngle - 0.5 * Math.PI) + (point.regionData.endAngle - point.regionData.startAngle) / 2;\n        if (labelIndex === 0) {\n            columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius\n                : point.regionData.radius;\n        }\n        else {\n            columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius\n                : point.regionData.radius;\n        }\n        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        if (series.drawType.indexOf('Stacking') > -1) {\n            position = position === 'Outer' ? 'Top' : position;\n        }\n        else if (series.drawType.indexOf('Range') > -1) {\n            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';\n        }\n        if (position === 'Outer') {\n            columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight :\n                columnRadius - 2 * padding - this.markerHeight;\n        }\n        else if (position === 'Middle') {\n            columnRadius = columnRadius / 2 + padding;\n            if (series.drawType === 'StackingColumn') {\n                columnRadius = point.regionData.innerRadius + ((point.regionData.radius - point.regionData.innerRadius) / 2)\n                    + padding - (size.height / 2);\n            }\n        }\n        else if (position === 'Top') {\n            columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight :\n                columnRadius + 2 * padding + this.markerHeight;\n        }\n        else if (position === 'Bottom') {\n            columnRadius = 2 * padding;\n            columnRadius += (series.drawType === 'StackingColumn') ? (point.regionData.innerRadius + this.markerHeight) : 0;\n        }\n        else {\n            if (labelIndex === 0) {\n                columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding :\n                    series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;\n            }\n            else {\n                columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;\n            }\n        }\n        columnRadius += (alignmentValue * alignmentSign);\n        location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle);\n        // To change x location based on text anchor for column and stackingcolumn chart\n        if (series.drawType === 'StackingColumn') {\n            location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 :\n                (location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x);\n        }\n        else if (series.drawType === 'Column') {\n            location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 :\n                (location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x);\n        }\n        location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);\n        return location;\n    };\n    /**\n     * Get the label location\n     */\n    DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {\n        var location = new ChartLocation(0, 0);\n        var labelRegion = (series.type === 'Candle' && labelIndex > 1) ? point.regions[1] : point.regions[0];\n        if (series.type === 'HiloOpenClose') {\n            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];\n        }\n        var xAxis = series.xAxis;\n        var yAxis = series.yAxis;\n        var isInverted = series.chart.requireInvertedAxis;\n        if (series.type === 'BoxAndWhisker') {\n            this.markerHeight = 0;\n            switch (labelIndex) {\n                case 0:\n                    location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);\n                    break;\n                case 1:\n                    location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);\n                    break;\n                case 2:\n                    location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);\n                    break;\n                case 3:\n                    location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);\n                    break;\n                case 4:\n                    location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);\n                    break;\n                default: {\n                    location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);\n                    this.markerHeight = series.marker.height / 2;\n                    break;\n                }\n            }\n            if (isInverted) {\n                location.y = point.regions[0].y + (point.regions[0].height / 2);\n            }\n            else {\n                location.x = point.regions[0].x + (point.regions[0].width / 2);\n            }\n        }\n        else if (labelIndex === 0 || labelIndex === 1) {\n            location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);\n        }\n        else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {\n            location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);\n        }\n        else if (isInverted) {\n            location = { x: labelRegion.x + (labelRegion.width) / 2, y: labelRegion.y };\n        }\n        else {\n            location = { x: labelRegion.x + labelRegion.width, y: labelRegion.y + (labelRegion.height) / 2 };\n        }\n        //Aligning the label at the beginning of the tick, when tick size is less than text size\n        if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n            if (series.chart.requireInvertedAxis) {\n                var height = labelRegion.height;\n                location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n            }\n            else {\n                var width = labelRegion.width;\n                location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n            }\n        }\n        return location;\n    };\n    DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {\n        if (series.chart.chartAreaType === 'PolarRadar') {\n            return null;\n        }\n        var padding = 5;\n        var margin = this.margin;\n        var textLength = !this.inverted ? textSize.height : textSize.width;\n        var extraSpace = this.borderWidth + textLength / 2 + padding;\n        if (series.type === 'StackingColumn100' || series.type === 'StackingBar100') {\n            position = (position === 'Outer') ? 'Top' : position;\n        }\n        else if (series.type.indexOf('Range') > -1) {\n            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';\n        }\n        else if (series.type === 'Waterfall') {\n            position = position === 'Auto' ? 'Middle' : position;\n        }\n        switch (position) {\n            case 'Bottom':\n                labelLocation = !this.inverted ?\n                    isMinus ? (labelLocation - rect.height + extraSpace + margin.top) :\n                        (labelLocation + rect.height - extraSpace - margin.bottom) :\n                    isMinus ? (labelLocation + rect.width - extraSpace - margin.left) :\n                        (labelLocation - rect.width + extraSpace + margin.right);\n                break;\n            case 'Middle':\n                labelLocation = labelLocation = !this.inverted ?\n                    (isMinus ? labelLocation - (rect.height / 2) : labelLocation + (rect.height / 2)) :\n                    (isMinus ? labelLocation + (rect.width / 2) : labelLocation - (rect.width / 2));\n                break;\n            case 'Auto':\n                labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);\n                break;\n            default:\n                extraSpace += this.errorHeight;\n                labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, extraSpace, isMinus);\n                break;\n        }\n        var check = !this.inverted ? (labelLocation < rect.y || labelLocation > rect.y + rect.height) :\n            (labelLocation < rect.x || labelLocation > rect.x + rect.width);\n        this.fontBackground = check ?\n            (this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground)\n            : this.fontBackground === 'transparent' ? (point.color || series.interior) : this.fontBackground;\n        var seriesLength = series.chart.series.length;\n        if (position === 'Outer' && (series.type.indexOf('Stacking') > -1) && ((seriesLength - 1) > series.index)) {\n            var nextSeries = void 0;\n            var nextSeriesPoint = void 0;\n            for (var i = series.index + 1; i < seriesLength; i++) {\n                nextSeries = series.chart.series[i];\n                nextSeriesPoint = nextSeries.points[point.index];\n                if ((nextSeries.type.indexOf('Stacking') > -1) && (nextSeries.type.indexOf('100') === -1)) {\n                    this.fontBackground = (nextSeriesPoint && ((nextSeriesPoint.yValue < 0 && point.yValue < 0) ||\n                        (nextSeriesPoint.yValue > 0 && point.yValue > 0))) ? (nextSeriesPoint ? nextSeriesPoint.color :\n                        nextSeries.interior) : this.fontBackground;\n                    break;\n                }\n            }\n        }\n        return labelLocation;\n    };\n    DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {\n        var padding = 5;\n        if ((series.type.indexOf('Area') > -1 && series.type !== 'RangeArea')\n            && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {\n            position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;\n        }\n        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        switch (position) {\n            case 'Top':\n            case 'Outer':\n                labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding -\n                    this.errorHeight;\n                break;\n            case 'Bottom':\n                labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding +\n                    this.errorHeight;\n                break;\n            case 'Auto':\n                labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);\n                break;\n        }\n        return labelLocation;\n    };\n    DataLabel.prototype.isDataLabelShape = function (style) {\n        this.isShape = (style.color !== 'transparent' || style.border.width > 0);\n        this.borderWidth = style.border.width;\n        if (!this.isShape) {\n            this.margin = { left: 0, right: 0, bottom: 0, top: 0 };\n        }\n    };\n    DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {\n        var location;\n        var labelRect;\n        var isOverLap = true;\n        var position = 0;\n        var collection = this.chart.dataLabelCollections;\n        var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;\n        while (isOverLap && position < finalPosition) {\n            var actualPosition = this.getPosition(position);\n            if (series.type.indexOf('Stacking') > -1 && actualPosition === 'Outer') {\n                actualPosition = 'Top';\n                position++;\n            }\n            location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);\n            if (!this.inverted) {\n                labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);\n                isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;\n            }\n            else {\n                labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);\n                isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) ||\n                    labelRect.x + labelRect.width > series.clipRect.width;\n            }\n            position++;\n        }\n        return location;\n    };\n    // alignment calculation assigned here\n    DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {\n        switch (alignment) {\n            case 'Far':\n                labelLocation = !this.inverted ? (isMinus ? labelLocation + value : labelLocation - value) :\n                    (isMinus ? labelLocation - value : labelLocation + value);\n                break;\n            case 'Near':\n                labelLocation = !this.inverted ? (isMinus ? labelLocation - value : labelLocation + value) :\n                    (isMinus ? labelLocation + value : labelLocation - value);\n                break;\n            case 'Center':\n                labelLocation = labelLocation;\n                break;\n        }\n        return labelLocation;\n    };\n    //calculation for top and outer position of datalabel for rect series\n    DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus) {\n        var margin = this.margin;\n        var top;\n        switch (series.type) {\n            case 'RangeColumn':\n            case 'RangeArea':\n            case 'Hilo':\n                top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);\n                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n                break;\n            case 'Candle':\n                top = (index === 0 || index === 2) && !this.yAxisInversed\n                    || (index === 1 || index === 3) && this.yAxisInversed;\n                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);\n                break;\n            case 'HiloOpenClose':\n                if (index <= 1) {\n                    top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);\n                    location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n                }\n                else {\n                    if (this.yAxisInversed) {\n                        location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;\n                    }\n                    else {\n                        location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;\n                    }\n                }\n                break;\n            default:\n                if ((isMinus && position === 'Top') || (!isMinus && position === 'Outer')) {\n                    location = !this.inverted ? location - extraSpace - margin.bottom - this.markerHeight :\n                        location + extraSpace + margin.left + this.markerHeight;\n                }\n                else {\n                    location = !this.inverted ? location + extraSpace + margin.top + this.markerHeight :\n                        location - extraSpace - margin.right - this.markerHeight;\n                }\n                break;\n        }\n        return location;\n    };\n    /**\n     * Updates the label location\n     */\n    DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside) {\n        if (inside === void 0) { inside = false; }\n        if (!this.inverted) {\n            if (top) {\n                location = (position === 'Outer' && !inside) ? location - extraSpace - margin.bottom - this.markerHeight :\n                    location + extraSpace + margin.top + this.markerHeight;\n            }\n            else {\n                location = (position === 'Outer' && !inside) ? location + rect.height + extraSpace + margin.top + this.markerHeight :\n                    location + rect.height - extraSpace - margin.bottom - this.markerHeight;\n            }\n        }\n        else {\n            if (top) {\n                location = (position === 'Outer' && !inside) ? location + extraSpace + margin.left + this.markerHeight :\n                    location - extraSpace - margin.right - this.markerHeight;\n            }\n            else {\n                location = (position === 'Outer' && !inside) ? location - rect.width - extraSpace - margin.right - this.markerHeight :\n                    location - rect.width + extraSpace + margin.left + this.markerHeight;\n            }\n        }\n        return location;\n    };\n    DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {\n        var points = series.points;\n        var index = point.index;\n        var yValue = points[index].yValue;\n        var position;\n        var nextPoint = points.length - 1 > index ? points[index + 1] : null;\n        var previousPoint = index > 0 ? points[index - 1] : null;\n        var yLocation;\n        var isOverLap = true;\n        var labelRect;\n        var isBottom;\n        var positionIndex;\n        var collection = this.chart.dataLabelCollections;\n        if (series.type === 'Bubble') {\n            position = 'Top';\n        }\n        else if (series.type.indexOf('Step') > -1) {\n            position = 'Top';\n            if (index) {\n                position = (!previousPoint || !previousPoint.visible || (yValue > previousPoint.yValue !== this.yAxisInversed)\n                    || yValue === previousPoint.yValue) ? 'Top' : 'Bottom';\n            }\n        }\n        else if (series.type === 'BoxAndWhisker') {\n            if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {\n                position = series.yAxis.isInversed ? 'Bottom' : 'Top';\n            }\n            else if (labelIndex === 2 || labelIndex === 4) {\n                position = series.yAxis.isInversed ? 'Top' : 'Bottom';\n            }\n            else {\n                isOverLap = false;\n                position = 'Middle';\n                yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);\n            }\n        }\n        else {\n            if (index === 0) {\n                position = (!nextPoint || !nextPoint.visible || yValue > nextPoint.yValue ||\n                    (yValue < nextPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';\n            }\n            else if (index === points.length - 1) {\n                position = (!previousPoint || !previousPoint.visible || yValue > previousPoint.yValue ||\n                    (yValue < previousPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';\n            }\n            else {\n                if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {\n                    position = 'Top';\n                }\n                else if (!nextPoint.visible || !previousPoint) {\n                    position = (nextPoint.yValue > yValue || (previousPoint && previousPoint.yValue > yValue)) ?\n                        'Bottom' : 'Top';\n                }\n                else {\n                    var slope = (nextPoint.yValue - previousPoint.yValue) / 2;\n                    var intersectY = (slope * index) + (nextPoint.yValue - (slope * (index + 1)));\n                    position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' :\n                        intersectY < yValue ? 'Bottom' : 'Top';\n                }\n            }\n        }\n        isBottom = position === 'Bottom';\n        positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);\n        while (isOverLap && positionIndex < 4) {\n            yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);\n            labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);\n            isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect)\n                || (labelRect.y + labelRect.height) > series.clipRect.height;\n            positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;\n            isBottom = false;\n        }\n        return yLocation;\n    };\n    /**\n     * Animates the data label.\n     * @param  {Series} series - Data label of the series gets animated.\n     * @return {void}\n     */\n    DataLabel.prototype.doDataLabelAnimation = function (series, element) {\n        var shapeElements = series.shapeElement.childNodes;\n        var textNode = series.textElement.childNodes;\n        var delay = series.animation.delay + series.animation.duration;\n        var duration = series.chart.animated ? series.chart.duration : 200;\n        var location;\n        var length = element ? 1 : textNode.length;\n        var tempElement;\n        for (var i = 0; i < length; i++) {\n            tempElement = textNode[i];\n            if (element) {\n                element.style.visibility = 'hidden';\n                templateAnimate(element, delay, duration, 'ZoomIn');\n            }\n            else {\n                location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));\n                markerAnimate(tempElement, delay, duration, series, null, location, true);\n                if (shapeElements[i]) {\n                    tempElement = shapeElements[i];\n                    location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));\n                    markerAnimate(tempElement, delay, duration, series, null, location, true);\n                }\n            }\n        }\n    };\n    DataLabel.prototype.getPosition = function (index) {\n        return (['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index]);\n    };\n    /**\n     * Get module name.\n     */\n    DataLabel.prototype.getModuleName = function () {\n        // Returns the module name\n        return 'DataLabel';\n    };\n    /**\n     * To destroy the dataLabel for series.\n     * @return {void}\n     * @private\n     */\n    DataLabel.prototype.destroy = function (chart) {\n        // Destroy method performed here\n    };\n    return DataLabel;\n}());\nexport { DataLabel };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}