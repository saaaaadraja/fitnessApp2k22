{"ast":null,"code":"import { measureText } from '../../smithchart/utils/helper';\nimport { HorizontalLabelCollection, LabelRegion, Point, Direction } from '../../smithchart/utils/utils';\nimport { GridArcPoints, RadialLabelCollections } from '../../smithchart/utils/utils';\nimport { PathOption, TextOption, renderTextElement, _getEpsilonValue } from '../../smithchart/utils/helper';\nimport { axisLabelRender } from '../model/constant';\n/* tslint:disable:no-string-literal */\n\nvar AxisRender =\n/** @class */\nfunction () {\n  function AxisRender() {\n    this.radialLabels = [-50, -20, -10, -5, -4, -3, -2, -1.5, -1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1, 1.5, 2, 3, 4, 5, 10, 20, 50];\n    this.radialLabelCollections = [];\n    this.horizontalLabelCollections = [];\n    this.labelCollections = [];\n    this.direction = new Direction();\n  }\n\n  AxisRender.prototype.renderArea = function (smithchart, bounds) {\n    this.calculateChartArea(smithchart, bounds);\n    this.calculateCircleMargin(smithchart, bounds);\n    this.calculateXAxisRange(smithchart);\n    this.calculateRAxisRange(smithchart);\n    this.measureHorizontalAxis(smithchart);\n    this.measureRadialAxis(smithchart);\n\n    if (smithchart.horizontalAxis.visible) {\n      this.updateHAxis(smithchart);\n    }\n\n    if (smithchart.radialAxis.visible) {\n      this.updateRAxis(smithchart);\n    }\n\n    if (smithchart.horizontalAxis.visible) {\n      this.drawHAxisLabels(smithchart);\n    }\n\n    if (smithchart.radialAxis.visible) {\n      this.drawRAxisLabels(smithchart);\n    }\n  };\n\n  AxisRender.prototype.updateHAxis = function (smithchart) {\n    var majorGridLines = smithchart.horizontalAxis.majorGridLines;\n    var minorGridLines = smithchart.horizontalAxis.minorGridLines;\n    var axisLine = smithchart.horizontalAxis.axisLine;\n\n    if (majorGridLines.visible) {\n      this.updateHMajorGridLines(smithchart);\n    }\n\n    if (minorGridLines.visible) {\n      this.updateHMinorGridLines(smithchart);\n    }\n\n    if (axisLine.visible) {\n      this.updateHAxisLine(smithchart);\n    }\n  };\n\n  AxisRender.prototype.updateRAxis = function (smithchart) {\n    var majorGridLines = smithchart.radialAxis.majorGridLines;\n    var minorGridLines = smithchart.radialAxis.minorGridLines;\n    var axisLine = smithchart.radialAxis.axisLine;\n\n    if (majorGridLines.visible) {\n      this.updateRMajorGridLines(smithchart);\n    }\n\n    if (minorGridLines.visible) {\n      this.updateRMinorGridLines(smithchart);\n    }\n\n    if (axisLine.visible) {\n      this.updateRAxisLine(smithchart);\n    }\n  };\n\n  AxisRender.prototype.measureHorizontalAxis = function (smithchart) {\n    var majorGridLines = smithchart.horizontalAxis.majorGridLines;\n    var minorGridLines = smithchart.horizontalAxis.minorGridLines;\n    this.measureHMajorGridLines(smithchart);\n\n    if (minorGridLines.visible) {\n      this.measureHMinorGridLines(smithchart);\n    }\n  };\n\n  AxisRender.prototype.measureRadialAxis = function (smithchart) {\n    var majorGridLines = smithchart.radialAxis.majorGridLines;\n    var minorGridLines = smithchart.radialAxis.minorGridLines;\n    this.measureRMajorGridLines(smithchart);\n\n    if (minorGridLines.visible) {\n      this.measureRMinorGridLines(smithchart);\n    }\n  };\n\n  AxisRender.prototype.calculateChartArea = function (smithchart, bounds) {\n    var chartAreaWidth;\n    var chartAreaHeight;\n    var width = smithchart.availableSize.width;\n    var height = smithchart.availableSize.height;\n    var x;\n    var y;\n    width = bounds.width;\n    height = bounds.height;\n    chartAreaWidth = Math.min(width, height);\n    chartAreaHeight = Math.min(width, height);\n    x = bounds.x + (bounds.width / 2 - chartAreaWidth / 2);\n    y = bounds.y + ((height - chartAreaHeight) / 2 > 0 ? (height - chartAreaHeight) / 2 : 0);\n    smithchart.chartArea = {\n      x: x,\n      y: y,\n      width: chartAreaWidth,\n      height: chartAreaHeight\n    };\n  };\n\n  AxisRender.prototype.calculateCircleMargin = function (smithchart, bounds) {\n    var padding = 10;\n    var maxLabelWidth = 0;\n    var width = smithchart.chartArea.width;\n    var radius = smithchart.radius;\n    maxLabelWidth = this.maximumLabelLength(smithchart);\n    var labelMargin = smithchart.radialAxis.labelPosition === 'Outside' ? maxLabelWidth + padding : padding;\n    var diameter = width - labelMargin * 2 > 0 ? width - labelMargin * 2 : 0;\n    var actualRadius = diameter / 2;\n    var circleCoefficient = radius > 1 ? 1 : radius < 0.1 ? 0.1 : radius;\n    this.areaRadius = actualRadius * circleCoefficient;\n    this.circleLeftX = smithchart.chartArea.x + labelMargin + actualRadius * (1 - circleCoefficient);\n    this.circleTopY = smithchart.chartArea.y + labelMargin + actualRadius * (1 - circleCoefficient);\n    this.circleCenterX = this.circleLeftX + this.areaRadius;\n    this.circleCenterY = bounds.y + bounds.height / 2;\n  };\n\n  AxisRender.prototype.maximumLabelLength = function (smithchart) {\n    var maximumLabelLength = 0;\n    var font = smithchart.horizontalAxis.labelStyle;\n    var label;\n    var textSize;\n\n    for (var i = 0; i < this.radialLabels.length; i++) {\n      label = this.radialLabels[i].toString();\n      textSize = measureText(label, font);\n\n      if (maximumLabelLength < textSize.width) {\n        maximumLabelLength = textSize.width;\n      }\n    }\n\n    return maximumLabelLength;\n  };\n\n  AxisRender.prototype.calculateAxisLabels = function () {\n    var spacingBetweenGridLines = 30;\n    var previousR = 0;\n    var j = 0;\n    var labels = [];\n    var diameter = this.areaRadius * 2;\n\n    for (var i = 0; i < 2; i = i + 0.1) {\n      i = Math.round(i * 10) / 10;\n      var coeff = 1 / (i + 1);\n      var isOverlap1 = false;\n      var isOverlap2 = false;\n      var radius = diameter * coeff / 2 * 2;\n\n      if (previousR === 0.0 || i === 1) {\n        previousR = radius;\n        labels[j] = i;\n        j++;\n        continue;\n      }\n\n      if (i < 1) {\n        isOverlap1 = this.isOverlap(1, diameter, radius, spacingBetweenGridLines);\n      }\n\n      if (i > 1) {\n        isOverlap2 = this.isOverlap(2, diameter, radius, spacingBetweenGridLines);\n      }\n\n      if (isOverlap1 || isOverlap2) {\n        continue;\n      }\n\n      if (previousR - radius >= spacingBetweenGridLines) {\n        labels[j] = i;\n        j++;\n        previousR = radius;\n      }\n    }\n\n    var staticlabels = [2, 3, 4, 5, 10, 20, 50];\n\n    for (var k = 0; k < staticlabels.length; k++) {\n      labels[j] = staticlabels[k];\n      j++;\n    }\n\n    return labels;\n  };\n\n  AxisRender.prototype.isOverlap = function (x, d, previousR, spacingBetweenGridLines) {\n    var coeff;\n    var radius;\n    coeff = 1 / (x + 1); // (1 / 1+r) find the radius for the x value\n\n    radius = d * coeff / 2 * 2;\n    return previousR - radius < spacingBetweenGridLines;\n  };\n\n  AxisRender.prototype.calculateXAxisRange = function (smithchart) {\n    var previousR = 0;\n    var x;\n    var coeff;\n    var radius;\n    var cx;\n    var diameter = this.areaRadius * 2;\n    var horizontalAxisLabels = this.calculateAxisLabels();\n    var cy = this.circleCenterY;\n    var circleStartX = this.circleLeftX;\n    var leftX = this.circleLeftX;\n\n    for (var i = 0; i < horizontalAxisLabels.length; i++) {\n      x = horizontalAxisLabels[i];\n      coeff = 1 / (x + 1);\n      radius = diameter * coeff / 2;\n\n      if (smithchart.renderType === 'Impedance') {\n        leftX = circleStartX + diameter - radius * 2;\n      }\n\n      cx = leftX + radius;\n      this.horizontalLabelCollections.push({\n        centerX: cx,\n        centerY: cy,\n        radius: radius,\n        value: x,\n        region: null\n      });\n    }\n  };\n\n  AxisRender.prototype.calculateRAxisRange = function (smithchart) {\n    var arcCy;\n    var arcRadius;\n    var diameter = this.areaRadius * 2;\n    var y;\n    var point = new Point();\n\n    if (smithchart.renderType === 'Impedance') {\n      point.x = this.circleLeftX + diameter;\n      point.y = this.circleTopY + this.areaRadius;\n    } else {\n      point.x = this.circleLeftX;\n      point.y = this.circleTopY + this.areaRadius;\n    }\n\n    for (var i = 0; i < this.radialLabels.length; i++) {\n      y = this.radialLabels[i];\n      arcRadius = Math.abs(1 / y * diameter / 2);\n\n      if (smithchart.renderType === 'Impedance') {\n        arcCy = y > 0 ? point.y - arcRadius : point.y + arcRadius;\n      } else {\n        arcCy = y < 0 ? point.y - arcRadius : point.y + arcRadius;\n      }\n\n      this.radialLabelCollections.push({\n        centerX: point.x,\n        centerY: arcCy,\n        radius: arcRadius,\n        value: y\n      });\n    }\n  };\n\n  AxisRender.prototype.measureHMajorGridLines = function (smithchart) {\n    var arcPoints = [];\n    var startPoint;\n    var endPoint;\n    var radialPoint1;\n    var radialPoint2;\n    var size;\n    this.majorHGridArcPoints = [];\n\n    for (var i = 0; i < this.horizontalLabelCollections.length; i++) {\n      var circlePoint = new HorizontalLabelCollection();\n      circlePoint = this.horizontalLabelCollections[i];\n      arcPoints = this.calculateHMajorArcStartEndPoints(circlePoint.value);\n\n      if (smithchart.renderType === 'Impedance') {\n        radialPoint1 = arcPoints[0];\n        radialPoint2 = arcPoints[1];\n      } else {\n        radialPoint1 = arcPoints[1];\n        radialPoint2 = arcPoints[0];\n      }\n\n      size = {\n        width: circlePoint.radius,\n        height: circlePoint.radius\n      };\n\n      if (circlePoint.value !== 0.0 && circlePoint.value !== 50.0) {\n        startPoint = this.intersectingCirclePoints(radialPoint1[0].centerX, radialPoint1[0].centerY, radialPoint1[0].radius, circlePoint.centerX, circlePoint.centerY, circlePoint.radius, smithchart.renderType);\n        endPoint = this.intersectingCirclePoints(radialPoint2[0].centerX, radialPoint2[0].centerY, radialPoint2[0].radius, circlePoint.centerX, circlePoint.centerY, circlePoint.radius, smithchart.renderType);\n        this.majorHGridArcPoints.push({\n          startPoint: startPoint,\n          endPoint: endPoint,\n          rotationAngle: 2 * Math.PI,\n          sweepDirection: smithchart.renderType === 'Impedance' ? this.direction['counterclockwise'] : this.direction['clockwise'],\n          isLargeArc: true,\n          size: size\n        });\n      } else {\n        startPoint = {\n          x: circlePoint.centerX + circlePoint.radius,\n          y: circlePoint.centerY\n        };\n        endPoint = {\n          x: circlePoint.centerX + circlePoint.radius,\n          y: circlePoint.centerY - 0.05\n        };\n        this.majorHGridArcPoints.push({\n          startPoint: startPoint,\n          endPoint: endPoint,\n          rotationAngle: 2 * Math.PI,\n          sweepDirection: this.direction['clockwise'],\n          isLargeArc: true,\n          size: size\n        });\n      }\n    }\n  };\n\n  AxisRender.prototype.measureRMajorGridLines = function (smithchart) {\n    var epsilon;\n    var radialPoint;\n    var y;\n    var arcPoints = [];\n    var innerInterSectPoint;\n    var outerInterSectPoint;\n    var outterInterSectRadian;\n    var outterInterSectAngle;\n    var startPoint;\n    var endPoint;\n    var size;\n    var sweepDirection;\n    this.majorRGridArcPoints = [];\n    this.labelCollections = [];\n    epsilon = _getEpsilonValue();\n\n    for (var i = 0; i < this.radialLabelCollections.length; i++) {\n      radialPoint = this.radialLabelCollections[i];\n\n      if (radialPoint.radius <= epsilon) {\n        continue;\n      }\n\n      y = radialPoint.value;\n      arcPoints = this.calculateMajorArcStartEndPoints(radialPoint, Math.abs(y), smithchart);\n      innerInterSectPoint = arcPoints[0];\n      outerInterSectPoint = arcPoints[1];\n      outterInterSectRadian = this.circleXYRadianValue(this.circleCenterX, this.circleCenterY, outerInterSectPoint.x, outerInterSectPoint.y);\n      outterInterSectAngle = outterInterSectRadian * (180 / Math.PI);\n\n      if (y !== 0.0) {\n        startPoint = {\n          x: innerInterSectPoint.x,\n          y: innerInterSectPoint.y\n        };\n        endPoint = {\n          x: outerInterSectPoint.x,\n          y: outerInterSectPoint.y\n        };\n        size = {\n          width: radialPoint.radius,\n          height: radialPoint.radius\n        };\n        sweepDirection = y > 0 ? this.direction['clockwise'] : this.direction['counterclockwise'];\n        this.majorRGridArcPoints.push({\n          startPoint: startPoint,\n          endPoint: endPoint,\n          size: size,\n          rotationAngle: 2 * Math.PI,\n          isLargeArc: false,\n          sweepDirection: sweepDirection\n        });\n        this.labelCollections.push({\n          centerX: outerInterSectPoint.x,\n          centerY: outerInterSectPoint.y,\n          angle: outterInterSectAngle,\n          value: y,\n          radius: this.areaRadius,\n          region: null\n        });\n      } else {\n        startPoint = {\n          x: this.circleLeftX,\n          y: this.circleCenterY\n        };\n        endPoint = {\n          x: this.circleCenterX + this.areaRadius,\n          y: this.circleCenterY\n        };\n        this.majorRGridArcPoints.push({\n          startPoint: startPoint,\n          endPoint: endPoint,\n          size: null,\n          rotationAngle: null,\n          isLargeArc: null,\n          sweepDirection: null\n        });\n        this.labelCollections.push({\n          centerX: smithchart.renderType === 'Impedance' ? this.circleCenterX - this.areaRadius : this.circleCenterX + this.areaRadius,\n          centerY: this.circleCenterY,\n          angle: smithchart.renderType === 'Impedance' ? 180 : 360,\n          value: y,\n          radius: this.areaRadius,\n          region: null\n        });\n      }\n    }\n  };\n\n  AxisRender.prototype.circleXYRadianValue = function (centerX, centerY, outterX, outterY) {\n    var radian;\n    radian = Math.atan2(outterY - centerY, outterX - centerX);\n    radian = radian < 0 ? radian + 360 * Math.PI / 180 : radian;\n    return radian;\n  };\n\n  AxisRender.prototype.calculateMajorArcStartEndPoints = function (radialPoint, value, smithchart) {\n    var arcPoints = [];\n    var circlePoint = [];\n    var cx;\n    var cy;\n    cx = this.circleCenterX;\n    cy = this.circleCenterY;\n\n    if (value >= 10) {\n      arcPoints[0] = smithchart.renderType === 'Impedance' ? {\n        x: cx + this.areaRadius,\n        y: cy\n      } : {\n        x: cx - this.areaRadius,\n        y: cy\n      };\n    } else if (value >= 3) {\n      circlePoint = this.horizontalLabelCollections.filter(function (c) {\n        return c.value === 10;\n      });\n    } else if (value >= 1) {\n      circlePoint = this.horizontalLabelCollections.filter(function (c) {\n        return c.value === 5;\n      });\n    } else {\n      circlePoint = this.horizontalLabelCollections.filter(function (c) {\n        return c.value === 3;\n      });\n    }\n\n    if (circlePoint.length > 0) {\n      arcPoints[0] = this.intersectingCirclePoints(radialPoint.centerX, radialPoint.centerY, radialPoint.radius, circlePoint[0].centerX, circlePoint[0].centerY, circlePoint[0].radius, smithchart.renderType);\n    }\n\n    arcPoints[1] = this.intersectingCirclePoints(radialPoint.centerX, radialPoint.centerY, radialPoint.radius, cx, cy, this.areaRadius, smithchart.renderType);\n    return arcPoints;\n  };\n\n  AxisRender.prototype.calculateHMajorArcStartEndPoints = function (value) {\n    var arcHPoints = [];\n    var calValue1;\n    var calValue2;\n\n    if (value <= 0.3) {\n      calValue1 = 2.0;\n      calValue2 = -2.0;\n    } else if (value <= 1.0) {\n      calValue1 = 3.0;\n      calValue2 = -3.0;\n    } else if (value <= 2.0) {\n      calValue1 = 5.0;\n      calValue2 = -5.0;\n    } else if (value <= 5.0) {\n      calValue1 = 10.0;\n      calValue2 = -10.0;\n    } else {\n      calValue1 = 50.0;\n      calValue2 = -50.0;\n    }\n\n    arcHPoints[0] = this.radialLabelCollections.filter(function (c) {\n      return c.value === calValue1;\n    });\n    arcHPoints[1] = this.radialLabelCollections.filter(function (c) {\n      return c.value === calValue2;\n    });\n    return arcHPoints;\n  };\n\n  AxisRender.prototype.calculateMinorArcStartEndPoints = function (value) {\n    var calValue1;\n    var calValue2;\n    var marcHPoints = [];\n\n    if (value <= 0.1) {\n      calValue1 = 1.0;\n      calValue2 = -1.0;\n    } else if (value <= 0.2) {\n      calValue1 = 0.8;\n      calValue2 = -0.8;\n    } else if (value <= 0.3) {\n      calValue1 = 0.4;\n      calValue2 = -0.4;\n    } else if (value <= 0.6) {\n      calValue1 = 1.0;\n      calValue2 = -1.0;\n    } else if (value <= 1.0) {\n      calValue1 = 1.5;\n      calValue2 = -1.5;\n    } else if (value <= 1.5) {\n      calValue1 = 2.0;\n      calValue2 = -2.0;\n    } else if (value <= 2.0) {\n      calValue1 = 1.0;\n      calValue2 = -1.0;\n    } else if (value <= 5.0) {\n      calValue1 = 3.0;\n      calValue2 = -3.0;\n    } else {\n      calValue1 = 10.0;\n      calValue2 = -10.0;\n    }\n\n    marcHPoints[0] = this.radialLabelCollections.filter(function (c) {\n      return c['value'] === calValue1;\n    });\n    marcHPoints[1] = this.radialLabelCollections.filter(function (c) {\n      return c['value'] === calValue2;\n    });\n    return marcHPoints;\n  };\n\n  AxisRender.prototype.intersectingCirclePoints = function (x1, y1, r1, x2, y2, r2, renderType) {\n    var cx;\n    var cy;\n    var midRadius;\n    var radiusSquare;\n    var a;\n    var radiusSquare2;\n    var c;\n    var fx;\n    var gx;\n    var ix1;\n    var ix2;\n    var fy;\n    var gy;\n    var iy1;\n    var iy2;\n    var point = {\n      x: 0,\n      y: 0\n    };\n    cx = x1 - x2;\n    cy = y1 - y2;\n    midRadius = Math.sqrt(cx * cx + cy * cy);\n    radiusSquare = midRadius * midRadius;\n    a = (r1 * r1 - r2 * r2) / (2 * radiusSquare);\n    radiusSquare2 = r1 * r1 - r2 * r2;\n    c = Math.sqrt(2 * (r1 * r1 + r2 * r2) / radiusSquare - radiusSquare2 * radiusSquare2 / (radiusSquare * radiusSquare) - 1);\n    fx = (x1 + x2) / 2 + a * (x2 - x1);\n    gx = c * (y2 - y1) / 2;\n    ix1 = fx + gx;\n    ix2 = fx - gx;\n    fy = (y1 + y2) / 2 + a * (y2 - y1);\n    gy = c * (x1 - x2) / 2;\n    iy1 = fy + gy;\n    iy2 = fy - gy;\n\n    if (renderType === 'Impedance') {\n      if (ix2 < ix1) {\n        point.x = ix2;\n        point.y = iy2;\n      } else {\n        point.x = ix1;\n        point.y = iy1;\n      }\n    } else {\n      if (ix1 > ix2) {\n        point.x = ix1;\n        point.y = iy1;\n      } else {\n        point.x = ix2;\n        point.y = iy2;\n      }\n    }\n\n    return {\n      x: point.x,\n      y: point.y\n    };\n  };\n\n  AxisRender.prototype.updateHMajorGridLines = function (smithchart) {\n    var majorGridLine = smithchart.horizontalAxis.majorGridLines;\n    var groupElement;\n    var element;\n    var path;\n    groupElement = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_horizontalAxisMajorGridLines'\n    });\n    path = this.calculateGridLinesPath(this.majorHGridArcPoints);\n    var haxismgoptions = new PathOption(smithchart.element.id + '_horizontalAxisMajorGridLines', 'none', majorGridLine['width'], majorGridLine.color ? majorGridLine.color : smithchart.themeStyle.majorGridLine, majorGridLine['opacity'], majorGridLine['dashArray'], path);\n    element = smithchart.renderer.drawPath(haxismgoptions);\n    groupElement.appendChild(element);\n    smithchart.svgObject.appendChild(groupElement);\n  };\n\n  AxisRender.prototype.updateRMajorGridLines = function (smithchart) {\n    var majorGridLine = smithchart.radialAxis.majorGridLines;\n    var groupElement;\n    var element;\n    var path;\n    groupElement = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_radialAxisMajorGridLines'\n    });\n    path = this.calculateGridLinesPath(this.majorRGridArcPoints);\n    var raxismgoptions = new PathOption(smithchart.element.id + '_radialAxisMajorGridLines', 'none', majorGridLine['width'], majorGridLine.color ? majorGridLine.color : smithchart.themeStyle.majorGridLine, majorGridLine['opacity'], majorGridLine['dashArray'], path);\n    element = smithchart.renderer.drawPath(raxismgoptions);\n    groupElement.appendChild(element);\n    smithchart.svgObject.appendChild(groupElement);\n  };\n\n  AxisRender.prototype.updateHAxisLine = function (smithchart) {\n    var radius = this.areaRadius;\n    var point1;\n    var point2;\n    var size;\n    var sweep;\n    var isLargeArc;\n    var angle;\n    var axisLine = smithchart.horizontalAxis.axisLine;\n    var direction;\n    var groupElement = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_hAxisLine'\n    });\n    point1 = {\n      x: this.circleCenterX + radius,\n      y: this.circleCenterY\n    };\n    point2 = {\n      x: this.circleCenterX + radius,\n      y: this.circleCenterY - 0.05\n    };\n    size = {\n      width: radius,\n      height: radius\n    };\n    sweep = this.direction['clockwise'];\n    isLargeArc = 1;\n    angle = Math.PI * 2;\n    direction = 'M' + '' + point1.x + ' ' + point1.y + ' ' + 'A' + ' ' + size.width + ' ' + size.height + ' ' + angle + ' ' + isLargeArc + ' ' + sweep + ' ' + point2.x + ' ' + point2.y + '';\n    var options = new PathOption(smithchart.element.id + '_horizontalAxisLine', 'none', axisLine.width, axisLine.color ? axisLine.color : smithchart.themeStyle.axisLine, 1, axisLine.dashArray, direction);\n    var element = smithchart.renderer.drawPath(options);\n    groupElement.appendChild(element);\n    smithchart.svgObject.appendChild(groupElement);\n  };\n\n  AxisRender.prototype.updateRAxisLine = function (smithchart) {\n    var radius = this.areaRadius;\n    var point1;\n    var point2;\n    var size;\n    var sweep;\n    var isLargeArc;\n    var angle;\n    var axisLine = smithchart.radialAxis.axisLine;\n    var direction;\n    point1 = {\n      x: this.circleCenterX - radius,\n      y: this.circleCenterY\n    };\n    point2 = {\n      x: this.circleCenterX + radius,\n      y: this.circleCenterY\n    };\n    size = {\n      width: 0,\n      height: 0\n    };\n    sweep = this.direction['counterclockwise'];\n    isLargeArc = 0;\n    angle = 0;\n    direction = 'M' + ' ' + point1.x + ' ' + point1.y + ' ' + 'A' + ' ' + size.width + ' ' + size.height + ' ' + angle + ' ' + isLargeArc + ' ' + sweep + ' ' + point2.x + ' ' + point2.y + '';\n    var options = new PathOption(smithchart.element.id + '_radialAxisLine', 'none', axisLine.width, axisLine.color ? axisLine.color : smithchart.themeStyle.axisLine, 1, axisLine.dashArray, direction);\n    var groupElement = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_rAxisLine'\n    });\n    var element = smithchart.renderer.drawPath(options);\n    groupElement.appendChild(element);\n    smithchart.svgObject.appendChild(groupElement);\n  };\n\n  AxisRender.prototype.drawHAxisLabels = function (smithchart) {\n    var hAxis = smithchart.horizontalAxis;\n    smithchart.radialAxis.labelStyle.fontFamily = smithchart.themeStyle.fontFamily || smithchart.radialAxis.labelStyle.fontFamily;\n    var font = smithchart.horizontalAxis.labelStyle;\n    var circleAxis;\n    var label;\n    var x;\n    var y;\n    var textSize;\n    var curLabel;\n    var curLabelBounds;\n    var curWidth;\n    var curX;\n    var preLabel;\n    var preLabelBounds;\n    var preWidth;\n    var preX;\n    var groupEle = smithchart.renderer.createGroup({\n      id: smithchart.element.id + '_HAxisLabels'\n    });\n\n    var _loop_1 = function _loop_1(i) {\n      circleAxis = this_1.horizontalLabelCollections[i];\n      label = this_1.horizontalLabelCollections[i].value.toString();\n\n      if (circleAxis.value !== 0.0) {\n        x = smithchart.renderType === 'Impedance' ? circleAxis.centerX - circleAxis.radius : circleAxis.centerX + circleAxis.radius;\n        y = circleAxis.centerY;\n        textSize = measureText(label, font);\n        x = smithchart.renderType === 'Impedance' ? x - textSize.width : x;\n\n        if (hAxis.labelPosition === 'Outside') {\n          y -= textSize.height / 4;\n        } else {\n          y += textSize.height;\n        }\n\n        this_1.horizontalLabelCollections[i].region = this_1.calculateRegion(label, textSize, x, y);\n\n        if (hAxis.labelIntersectAction === 'Hide') {\n          curLabel = this_1.horizontalLabelCollections[i];\n          curLabelBounds = curLabel.region.bounds;\n          curWidth = curLabelBounds.width;\n          curX = curLabelBounds.x;\n\n          for (var j = 1; j < i; j++) {\n            preLabel = this_1.horizontalLabelCollections[j];\n            preLabelBounds = preLabel.region.bounds;\n            preWidth = preLabelBounds.width;\n            preX = preLabelBounds.x;\n\n            if (smithchart.renderType === 'Impedance' && preX + preWidth > curX) {\n              label = '';\n            }\n\n            if (smithchart.renderType === 'Admittance' && preX < curX + curWidth) {\n              label = '';\n            }\n          }\n        }\n\n        var axisLabelRenderEventArgs_1 = {\n          text: label.toString(),\n          x: x,\n          y: y,\n          name: axisLabelRender,\n          cancel: false\n        };\n\n        var axisLabelRenderSuccess = function axisLabelRenderSuccess(args) {\n          if (!args.cancel) {\n            var options = new TextOption(smithchart.element.id + '_HLabel_' + i, axisLabelRenderEventArgs_1.x, axisLabelRenderEventArgs_1.y, 'none', axisLabelRenderEventArgs_1.text);\n            var color = font.color ? font.color : smithchart.themeStyle.axisLabel;\n            font.fontFamily = font.fontFamily || smithchart.themeStyle.labelFontFamily;\n            var element = renderTextElement(options, font, color, groupEle);\n            groupEle.appendChild(element);\n          }\n        };\n\n        axisLabelRenderSuccess.bind(this_1);\n        smithchart.trigger(axisLabelRender, axisLabelRenderEventArgs_1, axisLabelRenderSuccess);\n      }\n    };\n\n    var this_1 = this;\n\n    for (var i = 0; i < this.horizontalLabelCollections.length; i++) {\n      _loop_1(i);\n    }\n\n    smithchart.svgObject.appendChild(groupEle);\n  };\n\n  AxisRender.prototype.drawRAxisLabels = function (smithchart) {\n    var paddingRadius = 2;\n    smithchart.radialAxis.labelStyle.fontFamily = smithchart.themeStyle.fontFamily || smithchart.radialAxis.labelStyle.fontFamily;\n    var font = smithchart.radialAxis.labelStyle;\n    var interSectPoint = new RadialLabelCollections();\n    var label;\n    var textSize;\n    var angle;\n    var position;\n    var textPosition;\n    var curX;\n    var curY;\n    var curWidth;\n    var curHeight;\n    var curLabel;\n    var curLabelBounds;\n    var preX;\n    var preY;\n    var preWidth;\n    var preHeight;\n    var preLabel;\n    var preLabelBounds;\n    var rAxis = smithchart.radialAxis;\n    var groupEle = smithchart.renderer.createGroup({\n      id: smithchart.element.id + '_RAxisLabels'\n    });\n\n    var _loop_2 = function _loop_2(i) {\n      interSectPoint = this_2.labelCollections[i];\n      label = interSectPoint.value.toString();\n      textSize = measureText(label, font);\n      angle = Math.round(interSectPoint.angle * 100) / 100;\n\n      if (rAxis.labelPosition === 'Outside') {\n        position = this_2.circlePointPosition(this_2.circleCenterX, this_2.circleCenterY, interSectPoint['angle'], this_2.areaRadius + paddingRadius);\n        textPosition = this_2.setLabelsOutsidePosition(angle, position.x, position.y, textSize);\n      } else {\n        position = this_2.circlePointPosition(this_2.circleCenterX, this_2.circleCenterY, interSectPoint['angle'], this_2.areaRadius - paddingRadius);\n        textPosition = this_2.setLabelsInsidePosition(angle, position.x, position.y, textSize);\n      }\n\n      this_2.labelCollections[i]['region'] = this_2.calculateRegion(label, textSize, textPosition.x, textPosition.y);\n\n      if (rAxis.labelIntersectAction === 'Hide') {\n        curLabel = this_2.labelCollections[i];\n        curLabelBounds = curLabel['region']['bounds'];\n        curWidth = curLabelBounds['width'];\n        curHeight = curLabelBounds['height'];\n        curX = curLabelBounds['x'];\n        curY = curLabelBounds['y'];\n\n        for (var j = 0; j < i; j++) {\n          preLabel = this_2.labelCollections[j];\n          preLabelBounds = preLabel['region']['bounds'];\n          preWidth = preLabelBounds['width'];\n          preHeight = preLabelBounds['height'];\n          preX = preLabelBounds['x'];\n          preY = preLabelBounds['y'];\n\n          if (preX <= curX + curWidth && curX <= preX + preWidth && preY <= curY + curHeight && curY <= preY + preHeight) {\n            label = ' ';\n          }\n        }\n      }\n\n      var axisLabelRenderEventArgs = {\n        text: label.toString(),\n        x: textPosition.x,\n        y: textPosition.y,\n        name: axisLabelRender,\n        cancel: false\n      };\n\n      var axisLabelRenderSuccess = function axisLabelRenderSuccess(args) {\n        if (!args.cancel) {\n          var options = new TextOption(smithchart.element.id + '_RLabel_' + i, axisLabelRenderEventArgs.x, axisLabelRenderEventArgs.y, 'none', axisLabelRenderEventArgs.text);\n          var color = font.color ? font.color : smithchart.themeStyle.axisLabel;\n          font.fontFamily = smithchart.themeStyle.labelFontFamily ? smithchart.themeStyle.labelFontFamily : font.fontFamily;\n          var element = renderTextElement(options, font, color, groupEle);\n          groupEle.appendChild(element);\n        }\n      };\n\n      axisLabelRenderSuccess.bind(this_2);\n      smithchart.trigger(axisLabelRender, axisLabelRenderEventArgs, axisLabelRenderSuccess);\n    };\n\n    var this_2 = this;\n\n    for (var i = 0; i < this.labelCollections.length; i++) {\n      _loop_2(i);\n    }\n\n    smithchart.svgObject.appendChild(groupEle);\n  };\n\n  AxisRender.prototype.calculateRegion = function (label, textSize, textPositionX, textPositionY) {\n    var xAxisLabelRegions = new LabelRegion();\n    var bounds = {\n      x: textPositionX,\n      y: textPositionY,\n      width: textSize.width,\n      height: textSize.height\n    };\n    xAxisLabelRegions = {\n      bounds: bounds,\n      labelText: label\n    };\n    return xAxisLabelRegions;\n  };\n\n  AxisRender.prototype.updateHMinorGridLines = function (smithchart) {\n    var minorGridLine = smithchart.horizontalAxis.minorGridLines;\n    var groupElement;\n    var element;\n    var path;\n    groupElement = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_horizontalAxisMinorGridLines'\n    });\n    path = this.calculateGridLinesPath(this.minorHGridArcPoints);\n    var haxismioptions = new PathOption(smithchart.element.id + '_horizontalAxisMinorGridLines', 'none', minorGridLine['width'], minorGridLine.color ? minorGridLine.color : smithchart.themeStyle.minorGridLine, minorGridLine['opacity'], minorGridLine['dashArray'], path);\n    element = smithchart.renderer.drawPath(haxismioptions);\n    groupElement.appendChild(element);\n    smithchart.svgObject.appendChild(groupElement);\n  };\n\n  AxisRender.prototype.updateRMinorGridLines = function (smithchart) {\n    var minorGridLine = smithchart.radialAxis.minorGridLines;\n    var groupElement;\n    var element;\n    var path;\n    groupElement = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_radialAxisMinorGridLines'\n    });\n    path = this.calculateGridLinesPath(this.minorGridArcPoints);\n    var raxismioptions = new PathOption(smithchart.element.id + '_radialAxisMinorGridLines', 'none', minorGridLine['width'], minorGridLine.color ? minorGridLine.color : smithchart.themeStyle.minorGridLine, minorGridLine['opacity'], minorGridLine['dashArray'], path);\n    element = smithchart.renderer.drawPath(raxismioptions);\n    groupElement.appendChild(element);\n    smithchart.svgObject.appendChild(groupElement);\n  };\n\n  AxisRender.prototype.calculateGridLinesPath = function (points) {\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    var r1;\n    var r2;\n    var pathSegment = new GridArcPoints();\n    var angle;\n    var isLargeArc;\n    var sweep;\n    var sb = '';\n    var path;\n\n    for (var i = 0; i < points.length; i++) {\n      pathSegment = points[i];\n      x1 = pathSegment.startPoint.x;\n      y1 = pathSegment.startPoint.y;\n      x2 = pathSegment.endPoint.x;\n      y2 = pathSegment.endPoint.y;\n      r1 = pathSegment.size ? pathSegment.size.width : 0;\n      r2 = pathSegment.size ? pathSegment.size.height : 0;\n      angle = pathSegment.rotationAngle ? pathSegment.rotationAngle : 0;\n      isLargeArc = pathSegment.isLargeArc ? 1 : 0;\n      sweep = pathSegment.sweepDirection ? pathSegment.sweepDirection : 0;\n      sb = sb + ('M' + ' ' + x1 + ' ' + y1 + ' ' + 'A' + ' ' + r1 + ' ' + r2 + ' ' + angle + ' ' + isLargeArc + ' ' + sweep + ' ' + x2 + ' ' + y2 + ' ');\n    }\n\n    path = sb.toString();\n    return path;\n  };\n\n  AxisRender.prototype.measureHMinorGridLines = function (smithchart) {\n    var radialPoint1;\n    var radialPoint2;\n    var k = 0;\n    var arcPoints = [];\n    var isLargeArc;\n    var startPoint;\n    var endPoint;\n    var size;\n    var cx;\n    var maxCount = smithchart.horizontalAxis.minorGridLines.count;\n    var diameter;\n    var previous;\n    var next;\n    var space;\n    var count;\n    var interval;\n    var radius;\n    var leftX;\n    this.minorHGridArcPoints = [];\n    diameter = this.areaRadius * 2;\n\n    for (var i = 0; i < this.horizontalLabelCollections.length - 3; i++) {\n      previous = this.horizontalLabelCollections[i];\n      next = this.horizontalLabelCollections[i + 1];\n      space = (previous['radius'] - next['radius']) * 2;\n      count = Math.floor(maxCount / 100 * space);\n      interval = space / count;\n\n      for (var j = 0; j < count; j++) {\n        radius = next['radius'] + j * interval / 2;\n        leftX = smithchart.renderType === 'Impedance' ? this.circleLeftX + diameter - radius * 2 : this.circleLeftX;\n        cx = leftX + radius;\n        isLargeArc = next['value'] > 5;\n        arcPoints = this.calculateMinorArcStartEndPoints(next['value']);\n\n        if (smithchart.renderType === 'Impedance') {\n          radialPoint1 = arcPoints[0];\n          radialPoint2 = arcPoints[1];\n        } else {\n          radialPoint1 = arcPoints[1];\n          radialPoint2 = arcPoints[0];\n        }\n\n        startPoint = this.intersectingCirclePoints(radialPoint1[0].centerX, radialPoint1[0].centerY, radialPoint1[0].radius, cx, previous['centerY'], radius, smithchart.renderType);\n        endPoint = this.intersectingCirclePoints(radialPoint2[0].centerX, radialPoint2[0].centerY, radialPoint2[0].radius, cx, previous['centerY'], radius, smithchart.renderType);\n        size = {\n          width: radius,\n          height: radius\n        };\n        this.minorHGridArcPoints.push({\n          startPoint: startPoint,\n          endPoint: endPoint,\n          rotationAngle: 2 * Math.PI,\n          sweepDirection: smithchart.renderType === 'Impedance' ? this.direction['counterclockwise'] : this.direction['clockwise'],\n          isLargeArc: isLargeArc,\n          size: size\n        });\n        k++;\n      }\n    }\n  };\n\n  AxisRender.prototype.measureRMinorGridLines = function (smithchart) {\n    var maxCount = smithchart.radialAxis.minorGridLines.count;\n    var arcCx;\n    var nextAngle;\n    var k = 0;\n    var betweenAngle;\n    var circlePoint;\n    var circumference;\n    var arcStartX;\n    var arcStartY;\n    var arcStartPoint;\n    var previous;\n    var next;\n    var size;\n    var distance;\n    var count;\n    var interval;\n    var centerValue;\n    circumference = Math.PI * (this.areaRadius * 2);\n    arcStartX = arcCx = smithchart.renderType === 'Impedance' ? this.circleCenterX + this.areaRadius : this.circleCenterX - this.areaRadius;\n    arcStartY = this.circleCenterY;\n    this.minorGridArcPoints = [];\n    arcStartPoint = {\n      x: arcStartX,\n      y: arcStartY\n    };\n\n    for (var i = 2; i < this.labelCollections.length - 3; i++) {\n      previous = this.labelCollections[i];\n      next = this.labelCollections[i + 1];\n\n      if (smithchart.renderType === 'Impedance') {\n        nextAngle = next['angle'] === 360 ? 0 : next['angle'];\n        betweenAngle = Math.abs(nextAngle - previous['angle']);\n      } else {\n        nextAngle = previous['angle'] === 360 ? 0 : previous['angle'];\n        betweenAngle = Math.abs(nextAngle - next['angle']);\n      }\n\n      distance = circumference / 360 * betweenAngle;\n      count = Math.floor(maxCount / 100 * distance);\n      interval = betweenAngle / count;\n      centerValue = next['value'] > 0 ? next['value'] : previous['value'];\n      circlePoint = this.minorGridLineArcIntersectCircle(Math.abs(centerValue));\n\n      for (var j = 1; j < count; j++) {\n        var outterInterSectAngle = interval * j + (previous['angle'] === 360 ? nextAngle : previous['angle']);\n        var outerInterSectPoint = this.circlePointPosition(this.circleCenterX, this.circleCenterY, outterInterSectAngle, this.areaRadius);\n        var radius = this.arcRadius(arcStartPoint, outerInterSectPoint, outterInterSectAngle);\n        var arcCy = outterInterSectAngle > 180 ? this.circleCenterY - radius : this.circleCenterY + radius;\n        var innerInterSectPoint = this.intersectingCirclePoints(arcCx, arcCy, radius, circlePoint[0].centerX, circlePoint[0].centerY, circlePoint[0].radius, smithchart.renderType);\n        var startPoint = {\n          x: innerInterSectPoint.x,\n          y: innerInterSectPoint.y\n        };\n        var endPoint = {\n          x: outerInterSectPoint.x,\n          y: outerInterSectPoint.y\n        };\n        size = {\n          width: radius,\n          height: radius\n        };\n        var sweepDirection = previous['value'] >= 0 ? this.direction['clockwise'] : this.direction['counterclockwise'];\n        this.minorGridArcPoints.push({\n          startPoint: startPoint,\n          endPoint: endPoint,\n          rotationAngle: 2 * Math.PI,\n          sweepDirection: sweepDirection,\n          isLargeArc: false,\n          size: size\n        });\n        k++;\n      }\n    }\n  };\n\n  AxisRender.prototype.minorGridLineArcIntersectCircle = function (centerValue) {\n    var circlePoint;\n    var calValue;\n\n    if (centerValue >= 3) {\n      calValue = 20;\n    } else if (centerValue >= 1.5) {\n      calValue = 10;\n    } else if (centerValue >= 0.6) {\n      calValue = 3;\n    } else {\n      calValue = 2;\n    }\n\n    circlePoint = this.horizontalLabelCollections.filter(function (c) {\n      return c['value'] === calValue;\n    });\n    return circlePoint;\n  };\n\n  AxisRender.prototype.circlePointPosition = function (cx, cy, angle, r) {\n    var pointX;\n    var pointY;\n    var radian;\n    radian = angle * (Math.PI / 180);\n    pointX = cx + r * Math.cos(radian);\n    pointY = cy + r * Math.sin(radian);\n    return {\n      x: pointX,\n      y: pointY\n    };\n  };\n\n  AxisRender.prototype.setLabelsInsidePosition = function (angle, px, py, textSize) {\n    var x = px;\n    var y = py;\n\n    if (angle === 0 || angle === 360) {\n      x -= textSize.width;\n      y -= textSize.height / 2;\n    } else if (angle === 90) {\n      x -= textSize.width;\n      y += textSize.height / 8;\n    } else if (angle === 180) {\n      y += textSize.height;\n    } else if (angle === 270) {\n      y += textSize.height / 2;\n    } else if (angle > 0 && angle <= 20) {\n      x -= textSize.width;\n    } else if (angle > 20 && angle <= 60) {\n      x -= textSize.width + textSize.width / 2;\n      y += textSize.height / 2;\n    } else if (angle > 60 && angle < 90) {\n      x -= textSize.width + textSize.width / 4;\n      y += textSize.height / 4;\n    } else if (angle > 90 && angle <= 135) {\n      x -= textSize.width / 2;\n      y += textSize.height / 16;\n    } else if (angle > 135 && angle <= 150) {\n      x += textSize.width / 2;\n      y += textSize.height / 2;\n    } else if (angle > 150 && angle < 180) {\n      x += textSize.width / 2;\n      y += textSize.height;\n    } else if (angle > 180 && angle <= 210) {\n      x += textSize.width / 6;\n      y += textSize.height / 6;\n    } else if (angle > 210 && angle < 240) {\n      y += textSize.height / 4;\n    } else if (angle > 225 && angle < 270) {\n      y += textSize.height / 3;\n    } else if (angle > 270 && angle <= 300) {\n      x -= textSize.width + textSize.width / 4;\n      y += textSize.height / 4;\n    } else if (angle > 300 && angle <= 330) {\n      x -= textSize.width + textSize.width / 3;\n      y += textSize.height / 4;\n    } else if (angle > 330 && angle <= 340) {\n      x -= textSize.width + textSize.width / 2;\n      y += textSize.height / 4;\n    } else if (angle > 340) {\n      x -= textSize.width;\n      y += textSize.height / 8;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  AxisRender.prototype.setLabelsOutsidePosition = function (angle, px, py, textSize) {\n    var x = px;\n    var y = py;\n\n    if (angle === 90) {\n      x -= textSize.width / 2;\n      y += textSize.height;\n    } else if (angle === 180) {\n      x -= textSize.width + 5;\n      y -= textSize.height / 4;\n    } else if (angle === 270) {\n      x -= textSize.width / 2;\n      y -= textSize.height / 4;\n    } else if (angle === 360) {\n      x += 5;\n      y -= textSize.height / 2;\n    } else if (angle > 0 && angle <= 30) {\n      x += textSize.width / 4;\n      y += textSize.height / 8;\n    } else if (angle > 30 && angle <= 60) {\n      x += textSize.width / 2;\n      y += textSize.height / 4;\n    } else if (angle > 60 && angle <= 90) {\n      x -= textSize.width / 2;\n      y += textSize.height;\n    } else if (angle > 90 && angle <= 135) {\n      x -= textSize.width;\n      y += textSize.height;\n    } else if (angle > 135 && angle <= 180) {\n      x -= textSize.width + textSize.width / 4;\n      y += textSize.height / 4;\n    } else if (angle > 180 && angle <= 210) {\n      x -= textSize.width + textSize.width / 4;\n      y -= textSize.height / 4;\n    } else if (angle > 210 && angle <= 270) {\n      x -= textSize.width;\n      y -= textSize.height / 4;\n    } else if (angle > 270 && angle <= 340) {\n      y -= textSize.height / 4;\n    } else if (angle > 340) {\n      y += textSize.height / 4;\n      x += textSize.width / 6;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  AxisRender.prototype.arcRadius = function (startPoint, endPoint, angle) {\n    var mx;\n    var my;\n    var u;\n    var t;\n    var cy;\n    var radius;\n    var radian;\n    radian = angle > 180 ? 90 * Math.PI / 180 : 270 * Math.PI / 180; // Angle 90 and 270 used for calculating upper and lower circle\n\n    mx = (endPoint.x - startPoint.x) / 2;\n    my = (endPoint.y - startPoint.y) / 2;\n    u = (Math.cos(radian) * my - Math.sin(radian) * mx) / (Math.cos(radian) * mx + Math.sin(radian) * my);\n    t = (my - mx * u) / Math.sin(radian);\n    cy = startPoint.y + Math.sin(radian) * t;\n    radius = Math.abs(startPoint.y - cy);\n    return radius;\n  };\n\n  return AxisRender;\n}();\n\nexport { AxisRender };","map":{"version":3,"names":["measureText","HorizontalLabelCollection","LabelRegion","Point","Direction","GridArcPoints","RadialLabelCollections","PathOption","TextOption","renderTextElement","_getEpsilonValue","axisLabelRender","AxisRender","radialLabels","radialLabelCollections","horizontalLabelCollections","labelCollections","direction","prototype","renderArea","smithchart","bounds","calculateChartArea","calculateCircleMargin","calculateXAxisRange","calculateRAxisRange","measureHorizontalAxis","measureRadialAxis","horizontalAxis","visible","updateHAxis","radialAxis","updateRAxis","drawHAxisLabels","drawRAxisLabels","majorGridLines","minorGridLines","axisLine","updateHMajorGridLines","updateHMinorGridLines","updateHAxisLine","updateRMajorGridLines","updateRMinorGridLines","updateRAxisLine","measureHMajorGridLines","measureHMinorGridLines","measureRMajorGridLines","measureRMinorGridLines","chartAreaWidth","chartAreaHeight","width","availableSize","height","x","y","Math","min","chartArea","padding","maxLabelWidth","radius","maximumLabelLength","labelMargin","labelPosition","diameter","actualRadius","circleCoefficient","areaRadius","circleLeftX","circleTopY","circleCenterX","circleCenterY","font","labelStyle","label","textSize","i","length","toString","calculateAxisLabels","spacingBetweenGridLines","previousR","j","labels","round","coeff","isOverlap1","isOverlap2","isOverlap","staticlabels","k","d","cx","horizontalAxisLabels","cy","circleStartX","leftX","renderType","push","centerX","centerY","value","region","arcCy","arcRadius","point","abs","arcPoints","startPoint","endPoint","radialPoint1","radialPoint2","size","majorHGridArcPoints","circlePoint","calculateHMajorArcStartEndPoints","intersectingCirclePoints","rotationAngle","PI","sweepDirection","isLargeArc","epsilon","radialPoint","innerInterSectPoint","outerInterSectPoint","outterInterSectRadian","outterInterSectAngle","majorRGridArcPoints","calculateMajorArcStartEndPoints","circleXYRadianValue","angle","outterX","outterY","radian","atan2","filter","c","arcHPoints","calValue1","calValue2","calculateMinorArcStartEndPoints","marcHPoints","x1","y1","r1","x2","y2","r2","midRadius","radiusSquare","a","radiusSquare2","fx","gx","ix1","ix2","fy","gy","iy1","iy2","sqrt","majorGridLine","groupElement","element","path","renderer","createGroup","id","calculateGridLinesPath","haxismgoptions","color","themeStyle","drawPath","appendChild","svgObject","raxismgoptions","point1","point2","sweep","options","dashArray","hAxis","fontFamily","circleAxis","curLabel","curLabelBounds","curWidth","curX","preLabel","preLabelBounds","preWidth","preX","groupEle","_loop_1","this_1","calculateRegion","labelIntersectAction","axisLabelRenderEventArgs_1","text","name","cancel","axisLabelRenderSuccess","args","axisLabel","labelFontFamily","bind","trigger","paddingRadius","interSectPoint","position","textPosition","curY","curHeight","preY","preHeight","rAxis","_loop_2","this_2","circlePointPosition","setLabelsOutsidePosition","setLabelsInsidePosition","axisLabelRenderEventArgs","textPositionX","textPositionY","xAxisLabelRegions","labelText","minorGridLine","minorHGridArcPoints","haxismioptions","minorGridArcPoints","raxismioptions","points","pathSegment","sb","maxCount","count","previous","next","space","interval","floor","arcCx","nextAngle","betweenAngle","circumference","arcStartX","arcStartY","arcStartPoint","distance","centerValue","minorGridLineArcIntersectCircle","calValue","r","pointX","pointY","cos","sin","px","py","mx","my","u","t"],"sources":["D:/Theme/package/node_modules/@syncfusion/ej2-charts/src/smithchart/axis/axisrender.js"],"sourcesContent":["import { measureText } from '../../smithchart/utils/helper';\nimport { HorizontalLabelCollection, LabelRegion, Point, Direction } from '../../smithchart/utils/utils';\nimport { GridArcPoints, RadialLabelCollections } from '../../smithchart/utils/utils';\nimport { PathOption, TextOption, renderTextElement, _getEpsilonValue } from '../../smithchart/utils/helper';\nimport { axisLabelRender } from '../model/constant';\n/* tslint:disable:no-string-literal */\nvar AxisRender = /** @class */ (function () {\n    function AxisRender() {\n        this.radialLabels = [-50, -20, -10, -5, -4, -3, -2, -1.5, -1, -0.8, -0.6, -0.4, -0.2,\n            0, 0.2, 0.4, 0.6, 0.8, 1, 1.5, 2, 3, 4, 5, 10, 20, 50];\n        this.radialLabelCollections = [];\n        this.horizontalLabelCollections = [];\n        this.labelCollections = [];\n        this.direction = new Direction();\n    }\n    AxisRender.prototype.renderArea = function (smithchart, bounds) {\n        this.calculateChartArea(smithchart, bounds);\n        this.calculateCircleMargin(smithchart, bounds);\n        this.calculateXAxisRange(smithchart);\n        this.calculateRAxisRange(smithchart);\n        this.measureHorizontalAxis(smithchart);\n        this.measureRadialAxis(smithchart);\n        if (smithchart.horizontalAxis.visible) {\n            this.updateHAxis(smithchart);\n        }\n        if (smithchart.radialAxis.visible) {\n            this.updateRAxis(smithchart);\n        }\n        if (smithchart.horizontalAxis.visible) {\n            this.drawHAxisLabels(smithchart);\n        }\n        if (smithchart.radialAxis.visible) {\n            this.drawRAxisLabels(smithchart);\n        }\n    };\n    AxisRender.prototype.updateHAxis = function (smithchart) {\n        var majorGridLines = smithchart.horizontalAxis.majorGridLines;\n        var minorGridLines = smithchart.horizontalAxis.minorGridLines;\n        var axisLine = smithchart.horizontalAxis.axisLine;\n        if (majorGridLines.visible) {\n            this.updateHMajorGridLines(smithchart);\n        }\n        if (minorGridLines.visible) {\n            this.updateHMinorGridLines(smithchart);\n        }\n        if (axisLine.visible) {\n            this.updateHAxisLine(smithchart);\n        }\n    };\n    AxisRender.prototype.updateRAxis = function (smithchart) {\n        var majorGridLines = smithchart.radialAxis.majorGridLines;\n        var minorGridLines = smithchart.radialAxis.minorGridLines;\n        var axisLine = smithchart.radialAxis.axisLine;\n        if (majorGridLines.visible) {\n            this.updateRMajorGridLines(smithchart);\n        }\n        if (minorGridLines.visible) {\n            this.updateRMinorGridLines(smithchart);\n        }\n        if (axisLine.visible) {\n            this.updateRAxisLine(smithchart);\n        }\n    };\n    AxisRender.prototype.measureHorizontalAxis = function (smithchart) {\n        var majorGridLines = smithchart.horizontalAxis.majorGridLines;\n        var minorGridLines = smithchart.horizontalAxis.minorGridLines;\n        this.measureHMajorGridLines(smithchart);\n        if (minorGridLines.visible) {\n            this.measureHMinorGridLines(smithchart);\n        }\n    };\n    AxisRender.prototype.measureRadialAxis = function (smithchart) {\n        var majorGridLines = smithchart.radialAxis.majorGridLines;\n        var minorGridLines = smithchart.radialAxis.minorGridLines;\n        this.measureRMajorGridLines(smithchart);\n        if (minorGridLines.visible) {\n            this.measureRMinorGridLines(smithchart);\n        }\n    };\n    AxisRender.prototype.calculateChartArea = function (smithchart, bounds) {\n        var chartAreaWidth;\n        var chartAreaHeight;\n        var width = smithchart.availableSize.width;\n        var height = smithchart.availableSize.height;\n        var x;\n        var y;\n        width = bounds.width;\n        height = bounds.height;\n        chartAreaWidth = Math.min(width, height);\n        chartAreaHeight = Math.min(width, height);\n        x = bounds.x + (bounds.width / 2 - chartAreaWidth / 2);\n        y = bounds.y + ((height - chartAreaHeight) / 2 > 0 ? (height - chartAreaHeight) / 2 : 0);\n        smithchart.chartArea = { x: x, y: y, width: chartAreaWidth, height: chartAreaHeight };\n    };\n    AxisRender.prototype.calculateCircleMargin = function (smithchart, bounds) {\n        var padding = 10;\n        var maxLabelWidth = 0;\n        var width = smithchart.chartArea.width;\n        var radius = smithchart.radius;\n        maxLabelWidth = this.maximumLabelLength(smithchart);\n        var labelMargin = (smithchart.radialAxis.labelPosition === 'Outside') ? (maxLabelWidth + padding) : padding;\n        var diameter = width - labelMargin * 2 > 0 ? width - labelMargin * 2 : 0;\n        var actualRadius = diameter / 2;\n        var circleCoefficient = radius > 1 ? 1 : (radius < 0.1 ? 0.1 : radius);\n        this.areaRadius = actualRadius * circleCoefficient;\n        this.circleLeftX = smithchart.chartArea.x + labelMargin + (actualRadius * (1 - circleCoefficient));\n        this.circleTopY = smithchart.chartArea.y + labelMargin + (actualRadius * (1 - circleCoefficient));\n        this.circleCenterX = this.circleLeftX + this.areaRadius;\n        this.circleCenterY = bounds.y + bounds.height / 2;\n    };\n    AxisRender.prototype.maximumLabelLength = function (smithchart) {\n        var maximumLabelLength = 0;\n        var font = smithchart.horizontalAxis.labelStyle;\n        var label;\n        var textSize;\n        for (var i = 0; i < this.radialLabels.length; i++) {\n            label = this.radialLabels[i].toString();\n            textSize = measureText(label, font);\n            if (maximumLabelLength < textSize.width) {\n                maximumLabelLength = textSize.width;\n            }\n        }\n        return maximumLabelLength;\n    };\n    AxisRender.prototype.calculateAxisLabels = function () {\n        var spacingBetweenGridLines = 30;\n        var previousR = 0;\n        var j = 0;\n        var labels = [];\n        var diameter = this.areaRadius * 2;\n        for (var i = 0; i < 2; i = i + 0.1) {\n            i = Math.round(i * 10) / 10;\n            var coeff = 1 / (i + 1);\n            var isOverlap1 = false;\n            var isOverlap2 = false;\n            var radius = ((diameter * coeff) / 2) * 2;\n            if (previousR === 0.0 || i === 1) {\n                previousR = radius;\n                labels[j] = i;\n                j++;\n                continue;\n            }\n            if (i < 1) {\n                isOverlap1 = this.isOverlap(1, diameter, radius, spacingBetweenGridLines);\n            }\n            if (i > 1) {\n                isOverlap2 = this.isOverlap(2, diameter, radius, spacingBetweenGridLines);\n            }\n            if (isOverlap1 || isOverlap2) {\n                continue;\n            }\n            if (previousR - radius >= spacingBetweenGridLines) {\n                labels[j] = i;\n                j++;\n                previousR = radius;\n            }\n        }\n        var staticlabels = [2, 3, 4, 5, 10, 20, 50];\n        for (var k = 0; k < staticlabels.length; k++) {\n            labels[j] = staticlabels[k];\n            j++;\n        }\n        return labels;\n    };\n    AxisRender.prototype.isOverlap = function (x, d, previousR, spacingBetweenGridLines) {\n        var coeff;\n        var radius;\n        coeff = 1 / (x + 1); // (1 / 1+r) find the radius for the x value\n        radius = ((d * coeff) / 2) * 2;\n        return previousR - radius < spacingBetweenGridLines;\n    };\n    AxisRender.prototype.calculateXAxisRange = function (smithchart) {\n        var previousR = 0;\n        var x;\n        var coeff;\n        var radius;\n        var cx;\n        var diameter = this.areaRadius * 2;\n        var horizontalAxisLabels = this.calculateAxisLabels();\n        var cy = this.circleCenterY;\n        var circleStartX = this.circleLeftX;\n        var leftX = this.circleLeftX;\n        for (var i = 0; i < horizontalAxisLabels.length; i++) {\n            x = horizontalAxisLabels[i];\n            coeff = 1 / (x + 1);\n            radius = (diameter * coeff) / 2;\n            if (smithchart.renderType === 'Impedance') {\n                leftX = circleStartX + diameter - (radius * 2);\n            }\n            cx = leftX + radius;\n            this.horizontalLabelCollections.push({\n                centerX: cx, centerY: cy, radius: radius, value: x, region: null\n            });\n        }\n    };\n    AxisRender.prototype.calculateRAxisRange = function (smithchart) {\n        var arcCy;\n        var arcRadius;\n        var diameter = this.areaRadius * 2;\n        var y;\n        var point = new Point();\n        if (smithchart.renderType === 'Impedance') {\n            point.x = this.circleLeftX + diameter;\n            point.y = this.circleTopY + this.areaRadius;\n        }\n        else {\n            point.x = this.circleLeftX;\n            point.y = this.circleTopY + this.areaRadius;\n        }\n        for (var i = 0; i < this.radialLabels.length; i++) {\n            y = this.radialLabels[i];\n            arcRadius = Math.abs(((1 / y) * diameter) / 2);\n            if (smithchart.renderType === 'Impedance') {\n                arcCy = y > 0 ? point.y - arcRadius : point.y + arcRadius;\n            }\n            else {\n                arcCy = y < 0 ? point.y - arcRadius : point.y + arcRadius;\n            }\n            this.radialLabelCollections.push({\n                centerX: point.x, centerY: arcCy, radius: arcRadius, value: y\n            });\n        }\n    };\n    AxisRender.prototype.measureHMajorGridLines = function (smithchart) {\n        var arcPoints = [];\n        var startPoint;\n        var endPoint;\n        var radialPoint1;\n        var radialPoint2;\n        var size;\n        this.majorHGridArcPoints = [];\n        for (var i = 0; i < this.horizontalLabelCollections.length; i++) {\n            var circlePoint = new HorizontalLabelCollection();\n            circlePoint = this.horizontalLabelCollections[i];\n            arcPoints = this.calculateHMajorArcStartEndPoints(circlePoint.value);\n            if (smithchart.renderType === 'Impedance') {\n                radialPoint1 = arcPoints[0];\n                radialPoint2 = arcPoints[1];\n            }\n            else {\n                radialPoint1 = arcPoints[1];\n                radialPoint2 = arcPoints[0];\n            }\n            size = { width: circlePoint.radius, height: circlePoint.radius };\n            if (circlePoint.value !== 0.0 && circlePoint.value !== 50.0) {\n                startPoint = this.intersectingCirclePoints(radialPoint1[0].centerX, radialPoint1[0].centerY, radialPoint1[0].radius, circlePoint.centerX, circlePoint.centerY, circlePoint.radius, smithchart.renderType);\n                endPoint = this.intersectingCirclePoints(radialPoint2[0].centerX, radialPoint2[0].centerY, radialPoint2[0].radius, circlePoint.centerX, circlePoint.centerY, circlePoint.radius, smithchart.renderType);\n                this.majorHGridArcPoints.push({\n                    startPoint: startPoint,\n                    endPoint: endPoint,\n                    rotationAngle: 2 * Math.PI,\n                    sweepDirection: (smithchart.renderType === 'Impedance') ?\n                        this.direction['counterclockwise'] : this.direction['clockwise'],\n                    isLargeArc: true,\n                    size: size\n                });\n            }\n            else {\n                startPoint = { x: circlePoint.centerX + circlePoint.radius, y: circlePoint.centerY };\n                endPoint = { x: circlePoint.centerX + circlePoint.radius, y: circlePoint.centerY - 0.05 };\n                this.majorHGridArcPoints.push({\n                    startPoint: startPoint,\n                    endPoint: endPoint,\n                    rotationAngle: 2 * Math.PI,\n                    sweepDirection: this.direction['clockwise'],\n                    isLargeArc: true,\n                    size: size\n                });\n            }\n        }\n    };\n    AxisRender.prototype.measureRMajorGridLines = function (smithchart) {\n        var epsilon;\n        var radialPoint;\n        var y;\n        var arcPoints = [];\n        var innerInterSectPoint;\n        var outerInterSectPoint;\n        var outterInterSectRadian;\n        var outterInterSectAngle;\n        var startPoint;\n        var endPoint;\n        var size;\n        var sweepDirection;\n        this.majorRGridArcPoints = [];\n        this.labelCollections = [];\n        epsilon = _getEpsilonValue();\n        for (var i = 0; i < this.radialLabelCollections.length; i++) {\n            radialPoint = this.radialLabelCollections[i];\n            if (radialPoint.radius <= epsilon) {\n                continue;\n            }\n            y = radialPoint.value;\n            arcPoints = this.calculateMajorArcStartEndPoints(radialPoint, Math.abs(y), smithchart);\n            innerInterSectPoint = arcPoints[0];\n            outerInterSectPoint = arcPoints[1];\n            outterInterSectRadian = this.circleXYRadianValue(this.circleCenterX, this.circleCenterY, outerInterSectPoint.x, outerInterSectPoint.y);\n            outterInterSectAngle = outterInterSectRadian * (180 / Math.PI);\n            if (y !== 0.0) {\n                startPoint = { x: innerInterSectPoint.x, y: innerInterSectPoint.y };\n                endPoint = { x: outerInterSectPoint.x, y: outerInterSectPoint.y };\n                size = { width: radialPoint.radius, height: radialPoint.radius };\n                sweepDirection = y > 0 ? this.direction['clockwise'] : this.direction['counterclockwise'];\n                this.majorRGridArcPoints.push({\n                    startPoint: startPoint,\n                    endPoint: endPoint,\n                    size: size,\n                    rotationAngle: 2 * Math.PI,\n                    isLargeArc: false,\n                    sweepDirection: sweepDirection\n                });\n                this.labelCollections.push({\n                    centerX: outerInterSectPoint.x,\n                    centerY: outerInterSectPoint.y,\n                    angle: outterInterSectAngle,\n                    value: y,\n                    radius: this.areaRadius,\n                    region: null\n                });\n            }\n            else {\n                startPoint = { x: this.circleLeftX, y: this.circleCenterY };\n                endPoint = { x: this.circleCenterX + this.areaRadius, y: this.circleCenterY };\n                this.majorRGridArcPoints.push({\n                    startPoint: startPoint,\n                    endPoint: endPoint,\n                    size: null,\n                    rotationAngle: null,\n                    isLargeArc: null,\n                    sweepDirection: null\n                });\n                this.labelCollections.push({\n                    centerX: (smithchart.renderType === 'Impedance') ?\n                        (this.circleCenterX - this.areaRadius) : (this.circleCenterX + this.areaRadius),\n                    centerY: this.circleCenterY,\n                    angle: (smithchart.renderType === 'Impedance') ?\n                        180 : 360,\n                    value: y,\n                    radius: this.areaRadius,\n                    region: null\n                });\n            }\n        }\n    };\n    AxisRender.prototype.circleXYRadianValue = function (centerX, centerY, outterX, outterY) {\n        var radian;\n        radian = Math.atan2(outterY - centerY, outterX - centerX);\n        radian = radian < 0 ? (radian + (360 * Math.PI / 180)) : radian;\n        return radian;\n    };\n    AxisRender.prototype.calculateMajorArcStartEndPoints = function (radialPoint, value, smithchart) {\n        var arcPoints = [];\n        var circlePoint = [];\n        var cx;\n        var cy;\n        cx = this.circleCenterX;\n        cy = this.circleCenterY;\n        if (value >= 10) {\n            arcPoints[0] = (smithchart.renderType === 'Impedance') ?\n                { x: cx + this.areaRadius, y: cy } : { x: cx - this.areaRadius, y: cy };\n        }\n        else if (value >= 3) {\n            circlePoint = this.horizontalLabelCollections.filter(function (c) { return c.value === 10; });\n        }\n        else if (value >= 1) {\n            circlePoint = this.horizontalLabelCollections.filter(function (c) { return c.value === 5; });\n        }\n        else {\n            circlePoint = this.horizontalLabelCollections.filter(function (c) { return c.value === 3; });\n        }\n        if (circlePoint.length > 0) {\n            arcPoints[0] = this.intersectingCirclePoints(radialPoint.centerX, radialPoint.centerY, radialPoint.radius, circlePoint[0].centerX, circlePoint[0].centerY, circlePoint[0].radius, smithchart.renderType);\n        }\n        arcPoints[1] = this.intersectingCirclePoints(radialPoint.centerX, radialPoint.centerY, radialPoint.radius, cx, cy, this.areaRadius, smithchart.renderType);\n        return arcPoints;\n    };\n    AxisRender.prototype.calculateHMajorArcStartEndPoints = function (value) {\n        var arcHPoints = [];\n        var calValue1;\n        var calValue2;\n        if (value <= 0.3) {\n            calValue1 = 2.0;\n            calValue2 = -2.0;\n        }\n        else if (value <= 1.0) {\n            calValue1 = 3.0;\n            calValue2 = -3.0;\n        }\n        else if (value <= 2.0) {\n            calValue1 = 5.0;\n            calValue2 = -5.0;\n        }\n        else if (value <= 5.0) {\n            calValue1 = 10.0;\n            calValue2 = -10.0;\n        }\n        else {\n            calValue1 = 50.0;\n            calValue2 = -50.0;\n        }\n        arcHPoints[0] = this.radialLabelCollections.filter(function (c) { return c.value === calValue1; });\n        arcHPoints[1] = this.radialLabelCollections.filter(function (c) { return c.value === calValue2; });\n        return arcHPoints;\n    };\n    AxisRender.prototype.calculateMinorArcStartEndPoints = function (value) {\n        var calValue1;\n        var calValue2;\n        var marcHPoints = [];\n        if (value <= 0.1) {\n            calValue1 = 1.0;\n            calValue2 = -1.0;\n        }\n        else if (value <= 0.2) {\n            calValue1 = 0.8;\n            calValue2 = -0.8;\n        }\n        else if (value <= 0.3) {\n            calValue1 = 0.4;\n            calValue2 = -0.4;\n        }\n        else if (value <= 0.6) {\n            calValue1 = 1.0;\n            calValue2 = -1.0;\n        }\n        else if (value <= 1.0) {\n            calValue1 = 1.5;\n            calValue2 = -1.5;\n        }\n        else if (value <= 1.5) {\n            calValue1 = 2.0;\n            calValue2 = -2.0;\n        }\n        else if (value <= 2.0) {\n            calValue1 = 1.0;\n            calValue2 = -1.0;\n        }\n        else if (value <= 5.0) {\n            calValue1 = 3.0;\n            calValue2 = -3.0;\n        }\n        else {\n            calValue1 = 10.0;\n            calValue2 = -10.0;\n        }\n        marcHPoints[0] = this.radialLabelCollections.filter(function (c) { return c['value'] === calValue1; });\n        marcHPoints[1] = this.radialLabelCollections.filter(function (c) { return c['value'] === calValue2; });\n        return marcHPoints;\n    };\n    AxisRender.prototype.intersectingCirclePoints = function (x1, y1, r1, x2, y2, r2, renderType) {\n        var cx;\n        var cy;\n        var midRadius;\n        var radiusSquare;\n        var a;\n        var radiusSquare2;\n        var c;\n        var fx;\n        var gx;\n        var ix1;\n        var ix2;\n        var fy;\n        var gy;\n        var iy1;\n        var iy2;\n        var point = { x: 0, y: 0 };\n        cx = x1 - x2;\n        cy = y1 - y2;\n        midRadius = Math.sqrt(cx * cx + cy * cy);\n        radiusSquare = midRadius * midRadius;\n        a = (r1 * r1 - r2 * r2) / (2 * radiusSquare);\n        radiusSquare2 = (r1 * r1 - r2 * r2);\n        c = Math.sqrt(2 * (r1 * r1 + r2 * r2) / radiusSquare - (radiusSquare2 * radiusSquare2) / (radiusSquare * radiusSquare) - 1);\n        fx = (x1 + x2) / 2 + a * (x2 - x1);\n        gx = c * (y2 - y1) / 2;\n        ix1 = fx + gx;\n        ix2 = fx - gx;\n        fy = (y1 + y2) / 2 + a * (y2 - y1);\n        gy = c * (x1 - x2) / 2;\n        iy1 = fy + gy;\n        iy2 = fy - gy;\n        if (renderType === 'Impedance') {\n            if (ix2 < ix1) {\n                point.x = ix2;\n                point.y = iy2;\n            }\n            else {\n                point.x = ix1;\n                point.y = iy1;\n            }\n        }\n        else {\n            if (ix1 > ix2) {\n                point.x = ix1;\n                point.y = iy1;\n            }\n            else {\n                point.x = ix2;\n                point.y = iy2;\n            }\n        }\n        return { x: point.x, y: point.y };\n    };\n    AxisRender.prototype.updateHMajorGridLines = function (smithchart) {\n        var majorGridLine = smithchart.horizontalAxis.majorGridLines;\n        var groupElement;\n        var element;\n        var path;\n        groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_horizontalAxisMajorGridLines' });\n        path = this.calculateGridLinesPath(this.majorHGridArcPoints);\n        var haxismgoptions = new PathOption(smithchart.element.id + '_horizontalAxisMajorGridLines', 'none', majorGridLine['width'], majorGridLine.color ? majorGridLine.color : smithchart.themeStyle.majorGridLine, majorGridLine['opacity'], majorGridLine['dashArray'], path);\n        element = smithchart.renderer.drawPath(haxismgoptions);\n        groupElement.appendChild(element);\n        smithchart.svgObject.appendChild(groupElement);\n    };\n    AxisRender.prototype.updateRMajorGridLines = function (smithchart) {\n        var majorGridLine = smithchart.radialAxis.majorGridLines;\n        var groupElement;\n        var element;\n        var path;\n        groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_radialAxisMajorGridLines' });\n        path = this.calculateGridLinesPath(this.majorRGridArcPoints);\n        var raxismgoptions = new PathOption(smithchart.element.id + '_radialAxisMajorGridLines', 'none', majorGridLine['width'], majorGridLine.color ? majorGridLine.color : smithchart.themeStyle.majorGridLine, majorGridLine['opacity'], majorGridLine['dashArray'], path);\n        element = smithchart.renderer.drawPath(raxismgoptions);\n        groupElement.appendChild(element);\n        smithchart.svgObject.appendChild(groupElement);\n    };\n    AxisRender.prototype.updateHAxisLine = function (smithchart) {\n        var radius = this.areaRadius;\n        var point1;\n        var point2;\n        var size;\n        var sweep;\n        var isLargeArc;\n        var angle;\n        var axisLine = smithchart.horizontalAxis.axisLine;\n        var direction;\n        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_hAxisLine' });\n        point1 = { x: this.circleCenterX + radius, y: this.circleCenterY };\n        point2 = { x: this.circleCenterX + radius, y: (this.circleCenterY - 0.05) };\n        size = { width: radius, height: radius };\n        sweep = this.direction['clockwise'];\n        isLargeArc = 1;\n        angle = Math.PI * 2;\n        direction = 'M' + '' + point1.x + ' ' + point1.y + ' ' + 'A' + ' ' + size.width +\n            ' ' + size.height + ' ' + angle + ' ' + isLargeArc + ' ' + sweep + ' ' + point2.x + ' ' + point2.y + '';\n        var options = new PathOption(smithchart.element.id + '_horizontalAxisLine', 'none', axisLine.width, axisLine.color ? axisLine.color : smithchart.themeStyle.axisLine, 1, axisLine.dashArray, direction);\n        var element = smithchart.renderer.drawPath(options);\n        groupElement.appendChild(element);\n        smithchart.svgObject.appendChild(groupElement);\n    };\n    AxisRender.prototype.updateRAxisLine = function (smithchart) {\n        var radius = this.areaRadius;\n        var point1;\n        var point2;\n        var size;\n        var sweep;\n        var isLargeArc;\n        var angle;\n        var axisLine = smithchart.radialAxis.axisLine;\n        var direction;\n        point1 = { x: this.circleCenterX - radius, y: this.circleCenterY };\n        point2 = { x: this.circleCenterX + radius, y: this.circleCenterY };\n        size = { width: 0, height: 0 };\n        sweep = this.direction['counterclockwise'];\n        isLargeArc = 0;\n        angle = 0;\n        direction = 'M' + ' ' + point1.x + ' ' + point1.y + ' ' + 'A' + ' ' +\n            size.width + ' ' + size.height + ' ' + angle + ' ' + isLargeArc + ' ' + sweep + ' ' +\n            point2.x + ' ' + point2.y + '';\n        var options = new PathOption(smithchart.element.id + '_radialAxisLine', 'none', axisLine.width, axisLine.color ? axisLine.color : smithchart.themeStyle.axisLine, 1, axisLine.dashArray, direction);\n        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_rAxisLine' });\n        var element = smithchart.renderer.drawPath(options);\n        groupElement.appendChild(element);\n        smithchart.svgObject.appendChild(groupElement);\n    };\n    AxisRender.prototype.drawHAxisLabels = function (smithchart) {\n        var hAxis = smithchart.horizontalAxis;\n        smithchart.radialAxis.labelStyle.fontFamily = smithchart.themeStyle.fontFamily || smithchart.radialAxis.labelStyle.fontFamily;\n        var font = smithchart.horizontalAxis.labelStyle;\n        var circleAxis;\n        var label;\n        var x;\n        var y;\n        var textSize;\n        var curLabel;\n        var curLabelBounds;\n        var curWidth;\n        var curX;\n        var preLabel;\n        var preLabelBounds;\n        var preWidth;\n        var preX;\n        var groupEle = smithchart.renderer.createGroup({ id: smithchart.element.id + '_HAxisLabels' });\n        var _loop_1 = function (i) {\n            circleAxis = this_1.horizontalLabelCollections[i];\n            label = this_1.horizontalLabelCollections[i].value.toString();\n            if (circleAxis.value !== 0.0) {\n                x = (smithchart.renderType === 'Impedance') ?\n                    circleAxis.centerX - circleAxis.radius : circleAxis.centerX + circleAxis.radius;\n                y = circleAxis.centerY;\n                textSize = measureText(label, font);\n                x = (smithchart.renderType === 'Impedance') ? x - textSize.width : x;\n                if (hAxis.labelPosition === 'Outside') {\n                    y -= textSize.height / 4;\n                }\n                else {\n                    y += textSize.height;\n                }\n                this_1.horizontalLabelCollections[i].region = this_1.calculateRegion(label, textSize, x, y);\n                if (hAxis.labelIntersectAction === 'Hide') {\n                    curLabel = this_1.horizontalLabelCollections[i];\n                    curLabelBounds = curLabel.region.bounds;\n                    curWidth = curLabelBounds.width;\n                    curX = curLabelBounds.x;\n                    for (var j = 1; j < i; j++) {\n                        preLabel = this_1.horizontalLabelCollections[j];\n                        preLabelBounds = preLabel.region.bounds;\n                        preWidth = preLabelBounds.width;\n                        preX = preLabelBounds.x;\n                        if ((smithchart.renderType === 'Impedance') &&\n                            (preX + preWidth) > (curX)) {\n                            label = '';\n                        }\n                        if ((smithchart.renderType === 'Admittance') &&\n                            (preX) < curX + curWidth) {\n                            label = '';\n                        }\n                    }\n                }\n                var axisLabelRenderEventArgs_1 = {\n                    text: label.toString(),\n                    x: x,\n                    y: y,\n                    name: axisLabelRender,\n                    cancel: false\n                };\n                var axisLabelRenderSuccess = function (args) {\n                    if (!args.cancel) {\n                        var options = new TextOption(smithchart.element.id + '_HLabel_' + i, axisLabelRenderEventArgs_1.x, axisLabelRenderEventArgs_1.y, 'none', axisLabelRenderEventArgs_1.text);\n                        var color = font.color ? font.color : smithchart.themeStyle.axisLabel;\n                        font.fontFamily = font.fontFamily || smithchart.themeStyle.labelFontFamily;\n                        var element = renderTextElement(options, font, color, groupEle);\n                        groupEle.appendChild(element);\n                    }\n                };\n                axisLabelRenderSuccess.bind(this_1);\n                smithchart.trigger(axisLabelRender, axisLabelRenderEventArgs_1, axisLabelRenderSuccess);\n            }\n        };\n        var this_1 = this;\n        for (var i = 0; i < this.horizontalLabelCollections.length; i++) {\n            _loop_1(i);\n        }\n        smithchart.svgObject.appendChild(groupEle);\n    };\n    AxisRender.prototype.drawRAxisLabels = function (smithchart) {\n        var paddingRadius = 2;\n        smithchart.radialAxis.labelStyle.fontFamily = smithchart.themeStyle.fontFamily || smithchart.radialAxis.labelStyle.fontFamily;\n        var font = smithchart.radialAxis.labelStyle;\n        var interSectPoint = new RadialLabelCollections();\n        var label;\n        var textSize;\n        var angle;\n        var position;\n        var textPosition;\n        var curX;\n        var curY;\n        var curWidth;\n        var curHeight;\n        var curLabel;\n        var curLabelBounds;\n        var preX;\n        var preY;\n        var preWidth;\n        var preHeight;\n        var preLabel;\n        var preLabelBounds;\n        var rAxis = smithchart.radialAxis;\n        var groupEle = smithchart.renderer.createGroup({ id: smithchart.element.id + '_RAxisLabels' });\n        var _loop_2 = function (i) {\n            interSectPoint = this_2.labelCollections[i];\n            label = interSectPoint.value.toString();\n            textSize = measureText(label, font);\n            angle = Math.round(interSectPoint.angle * 100) / 100;\n            if (rAxis.labelPosition === 'Outside') {\n                position = this_2.circlePointPosition(this_2.circleCenterX, this_2.circleCenterY, interSectPoint['angle'], this_2.areaRadius + paddingRadius);\n                textPosition = this_2.setLabelsOutsidePosition(angle, position.x, position.y, textSize);\n            }\n            else {\n                position = this_2.circlePointPosition(this_2.circleCenterX, this_2.circleCenterY, interSectPoint['angle'], this_2.areaRadius - paddingRadius);\n                textPosition = this_2.setLabelsInsidePosition(angle, position.x, position.y, textSize);\n            }\n            this_2.labelCollections[i]['region'] = this_2.calculateRegion(label, textSize, textPosition.x, textPosition.y);\n            if (rAxis.labelIntersectAction === 'Hide') {\n                curLabel = this_2.labelCollections[i];\n                curLabelBounds = curLabel['region']['bounds'];\n                curWidth = curLabelBounds['width'];\n                curHeight = curLabelBounds['height'];\n                curX = curLabelBounds['x'];\n                curY = curLabelBounds['y'];\n                for (var j = 0; j < i; j++) {\n                    preLabel = this_2.labelCollections[j];\n                    preLabelBounds = preLabel['region']['bounds'];\n                    preWidth = preLabelBounds['width'];\n                    preHeight = preLabelBounds['height'];\n                    preX = preLabelBounds['x'];\n                    preY = preLabelBounds['y'];\n                    if ((preX <= curX + curWidth) && (curX <= preX + preWidth) && (preY <= curY + curHeight)\n                        && (curY <= preY + preHeight)) {\n                        label = ' ';\n                    }\n                }\n            }\n            var axisLabelRenderEventArgs = {\n                text: label.toString(),\n                x: textPosition.x,\n                y: textPosition.y,\n                name: axisLabelRender,\n                cancel: false\n            };\n            var axisLabelRenderSuccess = function (args) {\n                if (!args.cancel) {\n                    var options = new TextOption(smithchart.element.id + '_RLabel_' + i, axisLabelRenderEventArgs.x, axisLabelRenderEventArgs.y, 'none', axisLabelRenderEventArgs.text);\n                    var color = font.color ? font.color : smithchart.themeStyle.axisLabel;\n                    font.fontFamily = smithchart.themeStyle.labelFontFamily ? smithchart.themeStyle.labelFontFamily : font.fontFamily;\n                    var element = renderTextElement(options, font, color, groupEle);\n                    groupEle.appendChild(element);\n                }\n            };\n            axisLabelRenderSuccess.bind(this_2);\n            smithchart.trigger(axisLabelRender, axisLabelRenderEventArgs, axisLabelRenderSuccess);\n        };\n        var this_2 = this;\n        for (var i = 0; i < this.labelCollections.length; i++) {\n            _loop_2(i);\n        }\n        smithchart.svgObject.appendChild(groupEle);\n    };\n    AxisRender.prototype.calculateRegion = function (label, textSize, textPositionX, textPositionY) {\n        var xAxisLabelRegions = new LabelRegion();\n        var bounds = { x: textPositionX, y: textPositionY, width: textSize.width, height: textSize.height };\n        xAxisLabelRegions = { bounds: bounds, labelText: label };\n        return xAxisLabelRegions;\n    };\n    AxisRender.prototype.updateHMinorGridLines = function (smithchart) {\n        var minorGridLine = smithchart.horizontalAxis.minorGridLines;\n        var groupElement;\n        var element;\n        var path;\n        groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_horizontalAxisMinorGridLines' });\n        path = this.calculateGridLinesPath(this.minorHGridArcPoints);\n        var haxismioptions = new PathOption(smithchart.element.id + '_horizontalAxisMinorGridLines', 'none', minorGridLine['width'], minorGridLine.color ? minorGridLine.color : smithchart.themeStyle.minorGridLine, minorGridLine['opacity'], minorGridLine['dashArray'], path);\n        element = smithchart.renderer.drawPath(haxismioptions);\n        groupElement.appendChild(element);\n        smithchart.svgObject.appendChild(groupElement);\n    };\n    AxisRender.prototype.updateRMinorGridLines = function (smithchart) {\n        var minorGridLine = smithchart.radialAxis.minorGridLines;\n        var groupElement;\n        var element;\n        var path;\n        groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_radialAxisMinorGridLines' });\n        path = this.calculateGridLinesPath(this.minorGridArcPoints);\n        var raxismioptions = new PathOption(smithchart.element.id + '_radialAxisMinorGridLines', 'none', minorGridLine['width'], minorGridLine.color ? minorGridLine.color : smithchart.themeStyle.minorGridLine, minorGridLine['opacity'], minorGridLine['dashArray'], path);\n        element = smithchart.renderer.drawPath(raxismioptions);\n        groupElement.appendChild(element);\n        smithchart.svgObject.appendChild(groupElement);\n    };\n    AxisRender.prototype.calculateGridLinesPath = function (points) {\n        var x1;\n        var y1;\n        var x2;\n        var y2;\n        var r1;\n        var r2;\n        var pathSegment = new GridArcPoints();\n        var angle;\n        var isLargeArc;\n        var sweep;\n        var sb = '';\n        var path;\n        for (var i = 0; i < points.length; i++) {\n            pathSegment = points[i];\n            x1 = pathSegment.startPoint.x;\n            y1 = pathSegment.startPoint.y;\n            x2 = pathSegment.endPoint.x;\n            y2 = pathSegment.endPoint.y;\n            r1 = pathSegment.size ? pathSegment.size.width : 0;\n            r2 = pathSegment.size ? pathSegment.size.height : 0;\n            angle = pathSegment.rotationAngle ? pathSegment.rotationAngle : 0;\n            isLargeArc = pathSegment.isLargeArc ? 1 : 0;\n            sweep = pathSegment.sweepDirection ? pathSegment.sweepDirection : 0;\n            sb = sb + ('M' + ' ' + x1 + ' ' + y1 + ' ' + 'A' + ' ' + r1 + ' ' + r2 + ' ' +\n                angle + ' ' + isLargeArc + ' ' + sweep + ' ' + x2 + ' ' + y2 + ' ');\n        }\n        path = sb.toString();\n        return path;\n    };\n    AxisRender.prototype.measureHMinorGridLines = function (smithchart) {\n        var radialPoint1;\n        var radialPoint2;\n        var k = 0;\n        var arcPoints = [];\n        var isLargeArc;\n        var startPoint;\n        var endPoint;\n        var size;\n        var cx;\n        var maxCount = smithchart.horizontalAxis.minorGridLines.count;\n        var diameter;\n        var previous;\n        var next;\n        var space;\n        var count;\n        var interval;\n        var radius;\n        var leftX;\n        this.minorHGridArcPoints = [];\n        diameter = this.areaRadius * 2;\n        for (var i = 0; i < this.horizontalLabelCollections.length - 3; i++) {\n            previous = this.horizontalLabelCollections[i];\n            next = this.horizontalLabelCollections[i + 1];\n            space = (previous['radius'] - next['radius']) * 2;\n            count = Math.floor((maxCount / 100) * space);\n            interval = space / count;\n            for (var j = 0; j < count; j++) {\n                radius = next['radius'] + (j * interval) / 2;\n                leftX = (smithchart.renderType === 'Impedance') ?\n                    (this.circleLeftX + diameter) - (radius * 2) : this.circleLeftX;\n                cx = leftX + radius;\n                isLargeArc = next['value'] > 5;\n                arcPoints = this.calculateMinorArcStartEndPoints(next['value']);\n                if (smithchart.renderType === 'Impedance') {\n                    radialPoint1 = arcPoints[0];\n                    radialPoint2 = arcPoints[1];\n                }\n                else {\n                    radialPoint1 = arcPoints[1];\n                    radialPoint2 = arcPoints[0];\n                }\n                startPoint = this.intersectingCirclePoints(radialPoint1[0].centerX, radialPoint1[0].centerY, radialPoint1[0].radius, cx, previous['centerY'], radius, smithchart.renderType);\n                endPoint = this.intersectingCirclePoints(radialPoint2[0].centerX, radialPoint2[0].centerY, radialPoint2[0].radius, cx, previous['centerY'], radius, smithchart.renderType);\n                size = { width: radius, height: radius };\n                this.minorHGridArcPoints.push({\n                    startPoint: startPoint,\n                    endPoint: endPoint,\n                    rotationAngle: 2 * Math.PI,\n                    sweepDirection: (smithchart.renderType === 'Impedance') ?\n                        this.direction['counterclockwise'] : this.direction['clockwise'],\n                    isLargeArc: isLargeArc,\n                    size: size\n                });\n                k++;\n            }\n        }\n    };\n    AxisRender.prototype.measureRMinorGridLines = function (smithchart) {\n        var maxCount = smithchart.radialAxis.minorGridLines.count;\n        var arcCx;\n        var nextAngle;\n        var k = 0;\n        var betweenAngle;\n        var circlePoint;\n        var circumference;\n        var arcStartX;\n        var arcStartY;\n        var arcStartPoint;\n        var previous;\n        var next;\n        var size;\n        var distance;\n        var count;\n        var interval;\n        var centerValue;\n        circumference = Math.PI * (this.areaRadius * 2);\n        arcStartX = arcCx = (smithchart.renderType === 'Impedance') ?\n            this.circleCenterX + this.areaRadius : this.circleCenterX - this.areaRadius;\n        arcStartY = this.circleCenterY;\n        this.minorGridArcPoints = [];\n        arcStartPoint = { x: arcStartX, y: arcStartY };\n        for (var i = 2; i < this.labelCollections.length - 3; i++) {\n            previous = this.labelCollections[i];\n            next = this.labelCollections[i + 1];\n            if (smithchart.renderType === 'Impedance') {\n                nextAngle = next['angle'] === 360 ? 0 : next['angle'];\n                betweenAngle = Math.abs(nextAngle - previous['angle']);\n            }\n            else {\n                nextAngle = previous['angle'] === 360 ? 0 : previous['angle'];\n                betweenAngle = Math.abs(nextAngle - next['angle']);\n            }\n            distance = (circumference / 360) * betweenAngle;\n            count = Math.floor((maxCount / 100) * distance);\n            interval = betweenAngle / count;\n            centerValue = next['value'] > 0 ? next['value'] : previous['value'];\n            circlePoint = this.minorGridLineArcIntersectCircle(Math.abs(centerValue));\n            for (var j = 1; j < count; j++) {\n                var outterInterSectAngle = (interval * j) + (previous['angle'] === 360 ? nextAngle : previous['angle']);\n                var outerInterSectPoint = this.circlePointPosition(this.circleCenterX, this.circleCenterY, outterInterSectAngle, this.areaRadius);\n                var radius = this.arcRadius(arcStartPoint, outerInterSectPoint, outterInterSectAngle);\n                var arcCy = outterInterSectAngle > 180 ? this.circleCenterY - radius : this.circleCenterY + radius;\n                var innerInterSectPoint = this.intersectingCirclePoints(arcCx, arcCy, radius, circlePoint[0].centerX, circlePoint[0].centerY, circlePoint[0].radius, smithchart.renderType);\n                var startPoint = { x: innerInterSectPoint.x, y: innerInterSectPoint.y };\n                var endPoint = { x: outerInterSectPoint.x, y: outerInterSectPoint.y };\n                size = { width: radius, height: radius };\n                var sweepDirection = previous['value'] >= 0 ? this.direction['clockwise'] : this.direction['counterclockwise'];\n                this.minorGridArcPoints.push({\n                    startPoint: startPoint,\n                    endPoint: endPoint,\n                    rotationAngle: 2 * Math.PI,\n                    sweepDirection: sweepDirection,\n                    isLargeArc: false,\n                    size: size\n                });\n                k++;\n            }\n        }\n    };\n    AxisRender.prototype.minorGridLineArcIntersectCircle = function (centerValue) {\n        var circlePoint;\n        var calValue;\n        if (centerValue >= 3) {\n            calValue = 20;\n        }\n        else if (centerValue >= 1.5) {\n            calValue = 10;\n        }\n        else if (centerValue >= 0.6) {\n            calValue = 3;\n        }\n        else {\n            calValue = 2;\n        }\n        circlePoint = this.horizontalLabelCollections.filter(function (c) { return c['value'] === calValue; });\n        return circlePoint;\n    };\n    AxisRender.prototype.circlePointPosition = function (cx, cy, angle, r) {\n        var pointX;\n        var pointY;\n        var radian;\n        radian = angle * (Math.PI / 180);\n        pointX = cx + r * Math.cos(radian);\n        pointY = cy + r * Math.sin(radian);\n        return { x: pointX, y: pointY };\n    };\n    AxisRender.prototype.setLabelsInsidePosition = function (angle, px, py, textSize) {\n        var x = px;\n        var y = py;\n        if (angle === 0 || angle === 360) {\n            x -= textSize.width;\n            y -= textSize.height / 2;\n        }\n        else if (angle === 90) {\n            x -= textSize.width;\n            y += textSize.height / 8;\n        }\n        else if (angle === 180) {\n            y += textSize.height;\n        }\n        else if (angle === 270) {\n            y += textSize.height / 2;\n        }\n        else if (angle > 0 && angle <= 20) {\n            x -= (textSize.width);\n        }\n        else if (angle > 20 && angle <= 60) {\n            x -= (textSize.width + textSize.width / 2);\n            y += textSize.height / 2;\n        }\n        else if (angle > 60 && angle < 90) {\n            x -= (textSize.width + textSize.width / 4);\n            y += textSize.height / 4;\n        }\n        else if (angle > 90 && angle <= 135) {\n            x -= (textSize.width / 2);\n            y += (textSize.height) / 16;\n        }\n        else if (angle > 135 && angle <= 150) {\n            x += (textSize.width / 2);\n            y += (textSize.height / 2);\n        }\n        else if (angle > 150 && angle < 180) {\n            x += (textSize.width / 2);\n            y += (textSize.height);\n        }\n        else if (angle > 180 && angle <= 210) {\n            x += (textSize.width / 6);\n            y += (textSize.height / 6);\n        }\n        else if (angle > 210 && angle < 240) {\n            y += (textSize.height / 4);\n        }\n        else if (angle > 225 && angle < 270) {\n            y += (textSize.height / 3);\n        }\n        else if (angle > 270 && angle <= 300) {\n            x -= (textSize.width + textSize.width / 4);\n            y += (textSize.height / 4);\n        }\n        else if (angle > 300 && angle <= 330) {\n            x -= (textSize.width + textSize.width / 3);\n            y += (textSize.height / 4);\n        }\n        else if (angle > 330 && angle <= 340) {\n            x -= (textSize.width + textSize.width / 2);\n            y += textSize.height / 4;\n        }\n        else if (angle > 340) {\n            x -= textSize.width;\n            y += textSize.height / 8;\n        }\n        return { x: x, y: y };\n    };\n    AxisRender.prototype.setLabelsOutsidePosition = function (angle, px, py, textSize) {\n        var x = px;\n        var y = py;\n        if (angle === 90) {\n            x -= textSize.width / 2;\n            y += textSize.height;\n        }\n        else if (angle === 180) {\n            x -= (textSize.width + 5);\n            y -= textSize.height / 4;\n        }\n        else if (angle === 270) {\n            x -= textSize.width / 2;\n            y -= textSize.height / 4;\n        }\n        else if (angle === 360) {\n            x += 5;\n            y -= textSize.height / 2;\n        }\n        else if (angle > 0 && angle <= 30) {\n            x += textSize.width / 4;\n            y += textSize.height / 8;\n        }\n        else if (angle > 30 && angle <= 60) {\n            x += textSize.width / 2;\n            y += textSize.height / 4;\n        }\n        else if (angle > 60 && angle <= 90) {\n            x -= textSize.width / 2;\n            y += textSize.height;\n        }\n        else if (angle > 90 && angle <= 135) {\n            x -= textSize.width;\n            y += textSize.height;\n        }\n        else if (angle > 135 && angle <= 180) {\n            x -= (textSize.width + textSize.width / 4);\n            y += textSize.height / 4;\n        }\n        else if (angle > 180 && angle <= 210) {\n            x -= textSize.width + textSize.width / 4;\n            y -= textSize.height / 4;\n        }\n        else if (angle > 210 && angle <= 270) {\n            x -= textSize.width;\n            y -= textSize.height / 4;\n        }\n        else if (angle > 270 && angle <= 340) {\n            y -= textSize.height / 4;\n        }\n        else if (angle > 340) {\n            y += textSize.height / 4;\n            x += textSize.width / 6;\n        }\n        return { x: x, y: y };\n    };\n    AxisRender.prototype.arcRadius = function (startPoint, endPoint, angle) {\n        var mx;\n        var my;\n        var u;\n        var t;\n        var cy;\n        var radius;\n        var radian;\n        radian = angle > 180 ? (90 * Math.PI / 180) : (270 * Math.PI / 180); // Angle 90 and 270 used for calculating upper and lower circle\n        mx = (endPoint.x - startPoint.x) / 2;\n        my = (endPoint.y - startPoint.y) / 2;\n        u = (Math.cos(radian) * my - Math.sin(radian) * mx) / (Math.cos(radian) * mx + Math.sin(radian) * my);\n        t = (my - mx * u) / Math.sin(radian);\n        cy = startPoint.y + Math.sin(radian) * t;\n        radius = Math.abs(startPoint.y - cy);\n        return radius;\n    };\n    return AxisRender;\n}());\nexport { AxisRender };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}