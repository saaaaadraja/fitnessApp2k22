{"ast":null,"code":"/**\n * StripLine src\n */\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { valueToCoefficient, textElement, RectOption, appendChildElement, appendClipElement, withIn, getElement } from '../../common/utils/helper';\nimport { measureText, TextOption, PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\n * `StripLine` module is used to render the stripLine in chart.\n */\n\nvar StripLine =\n/** @class */\nfunction () {\n  function StripLine() {}\n  /**\n   * Finding x, y, width and height of the strip line\n   *\n   * @param {Axis} axis axis\n   * @param {StripLineSettingsModel} stripline stripline\n   * @param {Rect} seriesClipRect seriesClipRect\n   * @param {number} startValue startValue\n   * @param {Axis} segmentAxis segmentAxis\n   * @param {Chart} chart chart instance\n   */\n\n\n  StripLine.prototype.measureStripLine = function (axis, stripline, seriesClipRect, startValue, segmentAxis, chart) {\n    var actualStart;\n    var actualEnd;\n    var orientation = axis.orientation;\n    var isDateTimeAxis = axis.valueType === 'DateTime';\n\n    if (stripline.isRepeat && stripline.size !== null) {\n      actualStart = startValue;\n      actualEnd = null;\n    } else {\n      if (axis.valueType === 'DateTimeCategory') {\n        var start = stripline.start;\n        var end = stripline.end;\n        actualStart = start != null && typeof start !== 'number' ? axis.labels.indexOf(this.dateToMilliSeconds(start, chart).toString()) : start;\n        actualEnd = end != null && typeof end !== 'number' ? axis.labels.indexOf(this.dateToMilliSeconds(end, chart).toString()) : end;\n      } else {\n        actualStart = stripline.start === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ? this.dateToMilliSeconds(stripline.start, chart) : +stripline.start;\n        actualEnd = stripline.end === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ? this.dateToMilliSeconds(stripline.end, chart) : +stripline.end;\n      }\n    }\n\n    var rect = this.getFromTovalue(actualStart, actualEnd, stripline.size, stripline.startFromAxis, axis, stripline);\n    var height = orientation === 'Vertical' ? (rect.to - rect.from) * axis.rect.height : seriesClipRect.height;\n    var width = orientation === 'Horizontal' ? (rect.to - rect.from) * axis.rect.width : seriesClipRect.width;\n    var x = orientation === 'Vertical' ? seriesClipRect.x : rect.from * axis.rect.width + axis.rect.x;\n    var y = orientation === 'Horizontal' ? seriesClipRect.y : axis.rect.y + axis.rect.height - (stripline.sizeType === 'Pixel' ? rect.from : rect.to) * axis.rect.height;\n\n    if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null && stripline.sizeType !== 'Pixel') {\n      var start = isDateTimeAxis && this.isCoreDate(stripline.segmentStart) ? this.dateToMilliSeconds(stripline.segmentStart, chart) : +stripline.segmentStart;\n      var end = isDateTimeAxis && this.isCoreDate(stripline.segmentEnd) ? this.dateToMilliSeconds(stripline.segmentEnd, chart) : +stripline.segmentEnd;\n      var segRect = this.getFromTovalue(start, end, null, null, segmentAxis, stripline);\n\n      if (segmentAxis.orientation === 'Vertical') {\n        y = segmentAxis.rect.y + segmentAxis.rect.height - segRect.to * segmentAxis.rect.height;\n        height = (segRect.to - segRect.from) * segmentAxis.rect.height;\n      } else {\n        x = segRect.from * segmentAxis.rect.width + segmentAxis.rect.x;\n        width = (segRect.to - segRect.from) * segmentAxis.rect.width;\n      }\n    }\n\n    if (height !== 0 && width !== 0 || stripline.sizeType === 'Pixel' && (stripline.start !== null || stripline.startFromAxis)) {\n      return new Rect(x, y, width, height);\n    }\n\n    return new Rect(0, 0, 0, 0);\n  };\n  /**\n   * To get from to value from start, end, size, start from axis\n   *\n   * @param {number} start start\n   * @param {number} end end\n   * @param {number} size size\n   * @param {boolean} startFromAxis startFromAxis\n   * @param {Axis} axis axis\n   * @param {StripLineSettingsModel} stripline stripline\n   */\n\n\n  StripLine.prototype.getFromTovalue = function (start, end, size, startFromAxis, axis, stripline) {\n    var from = !stripline.isRepeat && startFromAxis ? axis.visibleRange.min : start;\n    var to = this.getToValue(Math.max(start, isNullOrUndefined(end) ? start : end), from, size, axis, end, stripline);\n    from = this.findValue(from, axis);\n    to = this.findValue(to, axis);\n    return {\n      from: valueToCoefficient(axis.isInversed ? to : from, axis),\n      to: valueToCoefficient(axis.isInversed ? from : to, axis)\n    };\n  };\n  /**\n   * Finding end value of the strip line\n   *\n   * @param {number} to to\n   * @param {number} from from\n   * @param {number} size size\n   * @param {Axis} axis axis\n   * @param {number} end end\n   * @param {StripLineSettingsModel} stripline stripline\n   */\n\n\n  StripLine.prototype.getToValue = function (to, from, size, axis, end, stripline) {\n    var sizeType = stripline.sizeType;\n    var isEnd = end === null;\n\n    if (axis.valueType === 'DateTime') {\n      var fromValue = new Date(from);\n\n      if (sizeType === 'Auto') {\n        sizeType = axis.actualIntervalType;\n        size *= axis.visibleRange.interval;\n      }\n\n      switch (sizeType) {\n        case 'Years':\n          return isEnd ? new Date(fromValue.setFullYear(fromValue.getFullYear() + size)) : to;\n\n        case 'Months':\n          return isEnd ? new Date(fromValue.setMonth(fromValue.getMonth() + size)) : to;\n\n        case 'Days':\n          return isEnd ? new Date(fromValue.setDate(fromValue.getDate() + size)) : to;\n\n        case 'Hours':\n          return isEnd ? new Date(fromValue.setHours(fromValue.getHours() + size)) : to;\n\n        case 'Minutes':\n          return isEnd ? new Date(fromValue.setMinutes(fromValue.getMinutes() + size)) : to;\n\n        case 'Seconds':\n          return isEnd ? new Date(fromValue.setSeconds(fromValue.getSeconds() + size)) : to;\n\n        default:\n          return from;\n      }\n    } else {\n      return stripline.sizeType === 'Pixel' ? from : isEnd ? from + size : to;\n    }\n  };\n  /**\n   * To check the strip line values within range\n   *\n   * @param {number} value value\n   * @param {Axis} axis axis\n   */\n\n\n  StripLine.prototype.findValue = function (value, axis) {\n    if (value < axis.visibleRange.min) {\n      value = axis.visibleRange.min;\n    } else if (value > axis.visibleRange.max) {\n      value = axis.visibleRange.max;\n    }\n\n    return value;\n  };\n  /**\n   * Date parse\n   *\n   * @param {Date} value date\n   * @param {Chart} chart chart instance\n   * @returns {Date} parsed date\n   */\n\n\n  StripLine.prototype.dateParse = function (value, chart) {\n    var dateParser = chart.intl.getDateParser({\n      skeleton: 'full',\n      type: 'dateTime'\n    });\n    var dateFormatter = chart.intl.getDateFormat({\n      skeleton: 'full',\n      type: 'dateTime'\n    });\n    return new Date(Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({\n      val: value\n    }).val)))));\n  };\n  /**\n   * To render strip lines based start and end.\n   *\n   * @param {Chart} chart chart\n   * @param {ZIndex} position position\n   * @param {Axis[]} axes axes\n   * @private\n   */\n\n\n  StripLine.prototype.renderStripLine = function (chart, position, axes) {\n    var id = chart.element.id + '_stripline_' + position + '_';\n    var seriesClipRect = chart.chartAxisLayoutPanel.seriesClipRect;\n    var end = 0;\n    var limit = 0;\n    var startValue = 0;\n    var segmentAxis = null;\n    var range;\n    var options = new RectOption(id + 'ClipRect', 'transparent', {\n      width: 1,\n      color: 'Gray'\n    }, 1, {\n      x: chart.initialClipRect.x,\n      y: chart.initialClipRect.y,\n      width: chart.initialClipRect.width,\n      height: chart.initialClipRect.height\n    });\n    var striplineGroup = chart.renderer.createGroup({\n      id: id + 'collections',\n      'clip-path': 'url(#' + id + 'ClipRect' + ')'\n    });\n\n    if (!chart.enableCanvas) {\n      striplineGroup.appendChild(appendClipElement(chart.redraw, options, chart.renderer));\n    }\n\n    for (var _i = 0, axes_1 = axes; _i < axes_1.length; _i++) {\n      var axis = axes_1[_i];\n      var count = 0;\n\n      for (var _a = 0, _b = axis.stripLines; _a < _b.length; _a++) {\n        var stripline = _b[_a];\n\n        if (stripline.visible && stripline.zIndex === position) {\n          if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null && stripline.sizeType !== 'Pixel') {\n            segmentAxis = this.getSegmentAxis(axes, axis, stripline);\n          }\n\n          if (stripline.isRepeat && stripline.repeatEvery != null && stripline.size !== null && stripline.sizeType !== 'Pixel') {\n            limit = stripline.repeatUntil != null ? axis.valueType === 'DateTime' ? this.dateToMilliSeconds(stripline.repeatUntil, chart) : +stripline.repeatUntil : axis.actualRange.max;\n            startValue = axis.valueType === 'DateTime' && this.isCoreDate(stripline.start) ? this.dateToMilliSeconds(stripline.start, chart) : stripline.start;\n\n            if (stripline.startFromAxis && axis.valueType === 'DateTime' && stripline.sizeType === 'Auto' || stripline.start < axis.visibleRange.min) {\n              startValue = axis.visibleLabels[0].value === axis.visibleRange.min ? axis.visibleRange.min : axis.visibleLabels[0].value - (axis.valueType === 'DateTime' ? axis.dateTimeInterval : axis.visibleRange.interval);\n            }\n\n            startValue = stripline.startFromAxis && axis.valueType !== 'DateTime' ? axis.visibleRange.min : startValue;\n\n            while (startValue < limit) {\n              end = startValue + (axis.valueType === 'DateTime' ? axis.dateTimeInterval * +stripline.size : stripline.size);\n              range = withIn(end, axis.visibleRange);\n\n              if (startValue >= axis.visibleRange.min && startValue < axis.visibleRange.max || range) {\n                this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count);\n              }\n\n              count++;\n              startValue = this.getStartValue(axis, stripline, startValue, chart);\n            }\n          } else {\n            this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, null, segmentAxis, count);\n            count++;\n          }\n        }\n      }\n    }\n\n    appendChildElement(chart.enableCanvas, chart.svgObject, striplineGroup, chart.redraw);\n  };\n  /**\n   * To convert the C# date to js date\n   *\n   * @param {string | number | Object} value date value\n   * @returns {boolean} returns true if datetime value type is string(for asp platform)\n   */\n\n\n  StripLine.prototype.isCoreDate = function (value) {\n    return typeof value === 'string' ? true : false;\n  };\n  /**\n   * To get the total milli seconds\n   *\n   * @param {Date | number | Object} value date value\n   * @param {Chart} chart chart instance\n   * @returns {number} returns milliseconds\n   */\n\n\n  StripLine.prototype.dateToMilliSeconds = function (value, chart) {\n    return this.dateParse(value, chart).getTime();\n  };\n  /**\n   * To draw the single line strip line\n   *\n   * @param {StripLineSettingsModel} stripline stripline\n   * @param {Rect} rect rect\n   * @param {string} id id\n   * @param {Element} parent parent\n   * @param {Chart} chart chart\n   * @param {Axis} axis axis\n   */\n\n\n  StripLine.prototype.renderPath = function (stripline, rect, id, parent, chart, axis) {\n    var element = getElement(id);\n    var direction = element ? element.getAttribute('d') : '';\n    var d = axis.orientation === 'Vertical' ? 'M' + rect.x + ' ' + rect.y + ' ' + 'L' + (rect.x + rect.width) + ' ' + rect.y : 'M' + rect.x + ' ' + rect.y + ' ' + 'L' + rect.x + ' ' + (rect.y + rect.height);\n    appendChildElement(chart.enableCanvas, parent, chart.renderer.drawPath(new PathOption(id, '', stripline.size, stripline.color, stripline.opacity, stripline.dashArray, d)), chart.redraw, true, 'x', 'y', null, direction, true);\n  };\n  /**\n   * To draw the rectangle\n   *\n   * @param {StripLineSettingsModel} stripline stripline\n   * @param {Rect} rect rect\n   * @param {string} id id\n   * @param {Element} parent parent\n   * @param {Chart} chart chart\n   */\n\n\n  StripLine.prototype.renderRectangle = function (stripline, rect, id, parent, chart) {\n    var element = getElement(id);\n    var previousRect = element ? new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')) : null;\n    appendChildElement(chart.enableCanvas, parent, chart.renderer.drawRectangle(new RectOption(id, stripline.color, stripline.border, stripline.opacity, rect, 0, 0, '', stripline.dashArray)), chart.redraw, true, 'x', 'y', null, null, true, true, previousRect);\n  };\n  /**\n   * To create the text on strip line\n   *\n   * @param {StripLineSettingsModel} stripline stripline\n   * @param {Rect} rect rect\n   * @param {string} id id\n   * @param {Element} parent parent\n   * @param {Chart} chart chart\n   * @param {Axis} axis axis\n   */\n\n\n  StripLine.prototype.renderText = function (stripline, rect, id, parent, chart, axis) {\n    var textSize = measureText(stripline.text, stripline.textStyle);\n    var isRotationNull = stripline.rotation === null;\n    var textMid = isRotationNull ? 3 * (textSize.height / 8) : 0;\n    var ty = rect.y + rect.height / 2 + textMid;\n    var rotation = isRotationNull ? axis.orientation === 'Vertical' ? 0 : -90 : stripline.rotation;\n    var tx = rect.x + rect.width / 2;\n    var anchor;\n    var padding = 5;\n\n    if (axis.orientation === 'Horizontal') {\n      tx = this.getTextStart(tx + textMid * this.factor(stripline.horizontalAlignment), rect.width, stripline.horizontalAlignment);\n      ty = this.getTextStart(ty - textMid, rect.height, stripline.verticalAlignment) + (stripline.verticalAlignment === 'Start' && !isRotationNull ? textSize.height / 4 : 0);\n      anchor = isRotationNull ? this.invertAlignment(stripline.verticalAlignment) : stripline.horizontalAlignment;\n    } else {\n      tx = this.getTextStart(tx, rect.width, stripline.horizontalAlignment);\n      ty = this.getTextStart(ty + textMid * this.factor(stripline.verticalAlignment) - padding, rect.height, stripline.verticalAlignment);\n      anchor = stripline.horizontalAlignment;\n    }\n\n    textElement(chart.renderer, new TextOption(id, tx, ty, anchor, stripline.text, 'rotate(' + rotation + ' ' + tx + ',' + ty + ')', 'middle'), stripline.textStyle, stripline.textStyle.color, parent);\n  };\n\n  StripLine.prototype.invertAlignment = function (anchor) {\n    switch (anchor) {\n      case 'Start':\n        anchor = 'End';\n        break;\n\n      case 'End':\n        anchor = 'Start';\n        break;\n    }\n\n    return anchor;\n  };\n  /**\n   * To find the next value of the recurrence strip line\n   *\n   * @param {Axis} axis axis\n   * @param {StripLineSettingsModel} stripline stripline\n   * @param {number} startValue startValue\n   * @param {Chart} chart chart instance\n   * @returns {number} next start value of the recurrence strip line\n   */\n\n\n  StripLine.prototype.getStartValue = function (axis, stripline, startValue, chart) {\n    if (axis.valueType === 'DateTime') {\n      return this.getToValue(null, startValue, this.isCoreDate(stripline.repeatEvery) ? this.dateToMilliSeconds(stripline.repeatEvery, chart) : +stripline.repeatEvery, axis, null, stripline);\n    } else {\n      return startValue + +stripline.repeatEvery;\n    }\n  };\n  /**\n   * Finding segment axis for segmented strip line\n   *\n   * @param {Axis[]} axes axes collection\n   * @param {Axis} axis axis\n   * @param {StripLineSettingsModel} stripline stripline\n   */\n\n\n  StripLine.prototype.getSegmentAxis = function (axes, axis, stripline) {\n    var segment;\n\n    if (stripline.segmentAxisName == null) {\n      return axis.orientation === 'Horizontal' ? axes[1] : axes[0];\n    } else {\n      for (var i = 0; i < axes.length; i++) {\n        if (stripline.segmentAxisName === axes[i].name) {\n          segment = axes[i];\n        }\n      }\n\n      return segment;\n    }\n  };\n  /**\n   * To render strip line on chart\n   *\n   * @param {Axis} axis axis\n   * @param {StripLineSettingsModel} stripline stripline\n   * @param {Rect} seriesClipRect seriesClipRect\n   * @param {string} id id\n   * @param {Element} striplineGroup striplineGroup\n   * @param {Chart} chart chart\n   * @param {number} startValue startValue\n   * @param {Axis} segmentAxis segmentAxis\n   * @param {number} count count\n   */\n\n\n  StripLine.prototype.renderStripLineElement = function (axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count) {\n    var rect = this.measureStripLine(axis, stripline, seriesClipRect, startValue, segmentAxis, chart);\n\n    if (stripline.sizeType === 'Pixel') {\n      this.renderPath(stripline, rect, id + 'path_' + axis.name + '_' + count, striplineGroup, chart, axis);\n    } else {\n      if (rect.height !== 0 && rect.width !== 0) {\n        this.renderRectangle(stripline, rect, id + 'rect_' + axis.name + '_' + count, striplineGroup, chart);\n      }\n    }\n\n    if (stripline.text !== '') {\n      this.renderText(stripline, rect, id + 'text_' + axis.name + '_' + count, striplineGroup, chart, axis);\n    }\n  };\n  /**\n   * To find the factor of the text\n   *\n   * @param {Anchor} anchor text anchor\n   */\n\n\n  StripLine.prototype.factor = function (anchor) {\n    var factor = 0;\n\n    switch (anchor) {\n      case 'Start':\n        factor = 1;\n        break;\n\n      case 'End':\n        factor = -1;\n        break;\n    }\n\n    return factor;\n  };\n  /**\n   * To find the start value of the text\n   *\n   * @param {number} xy xy values\n   * @param {number} size text size\n   * @param {Anchor} textAlignment text alignment\n   */\n\n\n  StripLine.prototype.getTextStart = function (xy, size, textAlignment) {\n    var padding = 5;\n\n    switch (textAlignment) {\n      case 'Start':\n        xy = xy - size / 2 + padding;\n        break;\n\n      case 'End':\n        xy = xy + size / 2 - padding;\n        break;\n    }\n\n    return xy;\n  };\n  /**\n   * To get the module name for `StripLine`.\n   *\n   * @private\n   */\n\n\n  StripLine.prototype.getModuleName = function () {\n    return 'StripLine';\n  };\n  /**\n   * To destroy the `StripLine` module.\n   *\n   * @private\n   */\n\n\n  StripLine.prototype.destroy = function () {// destroy peform here\n  };\n\n  return StripLine;\n}();\n\nexport { StripLine };","map":{"version":3,"names":["isNullOrUndefined","valueToCoefficient","textElement","RectOption","appendChildElement","appendClipElement","withIn","getElement","measureText","TextOption","PathOption","Rect","DataUtil","StripLine","prototype","measureStripLine","axis","stripline","seriesClipRect","startValue","segmentAxis","chart","actualStart","actualEnd","orientation","isDateTimeAxis","valueType","isRepeat","size","start","end","labels","indexOf","dateToMilliSeconds","toString","isCoreDate","rect","getFromTovalue","startFromAxis","height","to","from","width","x","y","sizeType","isSegmented","segmentStart","segmentEnd","segRect","visibleRange","min","getToValue","Math","max","findValue","isInversed","isEnd","fromValue","Date","actualIntervalType","interval","setFullYear","getFullYear","setMonth","getMonth","setDate","getDate","setHours","getHours","setMinutes","getMinutes","setSeconds","getSeconds","value","dateParse","dateParser","intl","getDateParser","skeleton","type","dateFormatter","getDateFormat","parse","parseJson","val","renderStripLine","position","axes","id","element","chartAxisLayoutPanel","limit","range","options","color","initialClipRect","striplineGroup","renderer","createGroup","enableCanvas","appendChild","redraw","_i","axes_1","length","count","_a","_b","stripLines","visible","zIndex","getSegmentAxis","repeatEvery","repeatUntil","actualRange","visibleLabels","dateTimeInterval","renderStripLineElement","getStartValue","svgObject","getTime","renderPath","parent","direction","getAttribute","d","drawPath","opacity","dashArray","renderRectangle","previousRect","drawRectangle","border","renderText","textSize","text","textStyle","isRotationNull","rotation","textMid","ty","tx","anchor","padding","getTextStart","factor","horizontalAlignment","verticalAlignment","invertAlignment","segment","segmentAxisName","i","name","xy","textAlignment","getModuleName","destroy"],"sources":["D:/Theme/package/node_modules/@syncfusion/ej2-charts/src/chart/axis/strip-line.js"],"sourcesContent":["/**\n * StripLine src\n */\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { valueToCoefficient, textElement, RectOption, appendChildElement, appendClipElement, withIn, getElement } from '../../common/utils/helper';\nimport { measureText, TextOption, PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\n * `StripLine` module is used to render the stripLine in chart.\n */\nvar StripLine = /** @class */ (function () {\n    function StripLine() {\n    }\n    /**\n     * Finding x, y, width and height of the strip line\n     *\n     * @param {Axis} axis axis\n     * @param {StripLineSettingsModel} stripline stripline\n     * @param {Rect} seriesClipRect seriesClipRect\n     * @param {number} startValue startValue\n     * @param {Axis} segmentAxis segmentAxis\n     * @param {Chart} chart chart instance\n     */\n    StripLine.prototype.measureStripLine = function (axis, stripline, seriesClipRect, startValue, segmentAxis, chart) {\n        var actualStart;\n        var actualEnd;\n        var orientation = axis.orientation;\n        var isDateTimeAxis = axis.valueType === 'DateTime';\n        if (stripline.isRepeat && stripline.size !== null) {\n            actualStart = startValue;\n            actualEnd = null;\n        }\n        else {\n            if (axis.valueType === 'DateTimeCategory') {\n                var start = stripline.start;\n                var end = stripline.end;\n                actualStart = (start != null && typeof start !== 'number') ?\n                    axis.labels.indexOf(this.dateToMilliSeconds(start, chart).toString()) : start;\n                actualEnd = (end != null && typeof end !== 'number') ?\n                    axis.labels.indexOf(this.dateToMilliSeconds(end, chart).toString()) : end;\n            }\n            else {\n                actualStart = stripline.start === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ?\n                    this.dateToMilliSeconds(stripline.start, chart) : +stripline.start;\n                actualEnd = stripline.end === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ?\n                    this.dateToMilliSeconds(stripline.end, chart) : +stripline.end;\n            }\n        }\n        var rect = this.getFromTovalue(actualStart, actualEnd, stripline.size, stripline.startFromAxis, axis, stripline);\n        var height = (orientation === 'Vertical') ? (rect.to - rect.from) * axis.rect.height : seriesClipRect.height;\n        var width = (orientation === 'Horizontal') ? (rect.to - rect.from) * axis.rect.width : seriesClipRect.width;\n        var x = (orientation === 'Vertical') ? seriesClipRect.x : ((rect.from * axis.rect.width) + axis.rect.x);\n        var y = (orientation === 'Horizontal') ? seriesClipRect.y : (axis.rect.y + axis.rect.height -\n            ((stripline.sizeType === 'Pixel' ? rect.from : rect.to) * axis.rect.height));\n        if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null && stripline.sizeType !== 'Pixel') {\n            var start = isDateTimeAxis && this.isCoreDate(stripline.segmentStart) ?\n                this.dateToMilliSeconds(stripline.segmentStart, chart) : +stripline.segmentStart;\n            var end = isDateTimeAxis && this.isCoreDate(stripline.segmentEnd) ?\n                this.dateToMilliSeconds(stripline.segmentEnd, chart) : +stripline.segmentEnd;\n            var segRect = this.getFromTovalue(start, end, null, null, segmentAxis, stripline);\n            if (segmentAxis.orientation === 'Vertical') {\n                y = (segmentAxis.rect.y + segmentAxis.rect.height -\n                    (segRect.to * segmentAxis.rect.height));\n                height = (segRect.to - segRect.from) * segmentAxis.rect.height;\n            }\n            else {\n                x = ((segRect.from * segmentAxis.rect.width) + segmentAxis.rect.x);\n                width = (segRect.to - segRect.from) * segmentAxis.rect.width;\n            }\n        }\n        if ((height !== 0 && width !== 0) || (stripline.sizeType === 'Pixel' && (stripline.start !== null || stripline.startFromAxis))) {\n            return new Rect(x, y, width, height);\n        }\n        return new Rect(0, 0, 0, 0);\n    };\n    /**\n     * To get from to value from start, end, size, start from axis\n     *\n     * @param {number} start start\n     * @param {number} end end\n     * @param {number} size size\n     * @param {boolean} startFromAxis startFromAxis\n     * @param {Axis} axis axis\n     * @param {StripLineSettingsModel} stripline stripline\n     */\n    StripLine.prototype.getFromTovalue = function (start, end, size, startFromAxis, axis, stripline) {\n        var from = (!stripline.isRepeat && startFromAxis) ? axis.visibleRange.min : start;\n        var to = this.getToValue(Math.max(start, isNullOrUndefined(end) ? start : end), from, size, axis, end, stripline);\n        from = this.findValue(from, axis);\n        to = this.findValue(to, axis);\n        return { from: valueToCoefficient(axis.isInversed ? to : from, axis), to: valueToCoefficient(axis.isInversed ? from : to, axis) };\n    };\n    /**\n     * Finding end value of the strip line\n     *\n     * @param {number} to to\n     * @param {number} from from\n     * @param {number} size size\n     * @param {Axis} axis axis\n     * @param {number} end end\n     * @param {StripLineSettingsModel} stripline stripline\n     */\n    StripLine.prototype.getToValue = function (to, from, size, axis, end, stripline) {\n        var sizeType = stripline.sizeType;\n        var isEnd = (end === null);\n        if (axis.valueType === 'DateTime') {\n            var fromValue = new Date(from);\n            if (sizeType === 'Auto') {\n                sizeType = axis.actualIntervalType;\n                size *= axis.visibleRange.interval;\n            }\n            switch (sizeType) {\n                case 'Years':\n                    return (isEnd ? new Date(fromValue.setFullYear(fromValue.getFullYear() + size)) : to);\n                case 'Months':\n                    return (isEnd ? new Date(fromValue.setMonth(fromValue.getMonth() + size)) : to);\n                case 'Days':\n                    return (isEnd ? new Date(fromValue.setDate(fromValue.getDate() + size)) : to);\n                case 'Hours':\n                    return (isEnd ? new Date(fromValue.setHours(fromValue.getHours() + size)) : to);\n                case 'Minutes':\n                    return (isEnd ? new Date(fromValue.setMinutes(fromValue.getMinutes() + size)) : to);\n                case 'Seconds':\n                    return (isEnd ? new Date(fromValue.setSeconds(fromValue.getSeconds() + size)) : to);\n                default:\n                    return from;\n            }\n        }\n        else {\n            return stripline.sizeType === 'Pixel' ? from : (isEnd ? (from + size) : to);\n        }\n    };\n    /**\n     * To check the strip line values within range\n     *\n     * @param {number} value value\n     * @param {Axis} axis axis\n     */\n    StripLine.prototype.findValue = function (value, axis) {\n        if (value < axis.visibleRange.min) {\n            value = axis.visibleRange.min;\n        }\n        else if (value > axis.visibleRange.max) {\n            value = axis.visibleRange.max;\n        }\n        return value;\n    };\n    /**\n     * Date parse\n     *\n     * @param {Date} value date\n     * @param {Chart} chart chart instance\n     * @returns {Date} parsed date\n     */\n    StripLine.prototype.dateParse = function (value, chart) {\n        var dateParser = chart.intl.getDateParser({ skeleton: 'full', type: 'dateTime' });\n        var dateFormatter = chart.intl.getDateFormat({ skeleton: 'full', type: 'dateTime' });\n        return new Date((Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: value }).val))))));\n    };\n    /**\n     * To render strip lines based start and end.\n     *\n     * @param {Chart} chart chart\n     * @param {ZIndex} position position\n     * @param {Axis[]} axes axes\n     * @private\n     */\n    StripLine.prototype.renderStripLine = function (chart, position, axes) {\n        var id = chart.element.id + '_stripline_' + position + '_';\n        var seriesClipRect = chart.chartAxisLayoutPanel.seriesClipRect;\n        var end = 0;\n        var limit = 0;\n        var startValue = 0;\n        var segmentAxis = null;\n        var range;\n        var options = new RectOption(id + 'ClipRect', 'transparent', { width: 1, color: 'Gray' }, 1, {\n            x: chart.initialClipRect.x, y: chart.initialClipRect.y,\n            width: chart.initialClipRect.width,\n            height: chart.initialClipRect.height\n        });\n        var striplineGroup = chart.renderer.createGroup({\n            id: id + 'collections',\n            'clip-path': 'url(#' + id + 'ClipRect' + ')'\n        });\n        if (!chart.enableCanvas) {\n            striplineGroup.appendChild(appendClipElement(chart.redraw, options, chart.renderer));\n        }\n        for (var _i = 0, axes_1 = axes; _i < axes_1.length; _i++) {\n            var axis = axes_1[_i];\n            var count = 0;\n            for (var _a = 0, _b = axis.stripLines; _a < _b.length; _a++) {\n                var stripline = _b[_a];\n                if (stripline.visible && stripline.zIndex === position) {\n                    if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null &&\n                        stripline.sizeType !== 'Pixel') {\n                        segmentAxis = this.getSegmentAxis(axes, axis, stripline);\n                    }\n                    if (stripline.isRepeat && stripline.repeatEvery != null && stripline.size !== null && stripline.sizeType !== 'Pixel') {\n                        limit = (stripline.repeatUntil != null) ? ((axis.valueType === 'DateTime') ?\n                            this.dateToMilliSeconds(stripline.repeatUntil, chart) : +stripline.repeatUntil) : axis.actualRange.max;\n                        startValue = axis.valueType === 'DateTime' && this.isCoreDate(stripline.start) ?\n                            this.dateToMilliSeconds(stripline.start, chart) : stripline.start;\n                        if ((stripline.startFromAxis && axis.valueType === 'DateTime' && stripline.sizeType === 'Auto') ||\n                            (stripline.start < axis.visibleRange.min)) {\n                            startValue = axis.visibleLabels[0].value === axis.visibleRange.min ? axis.visibleRange.min :\n                                axis.visibleLabels[0].value - (axis.valueType === 'DateTime' ? axis.dateTimeInterval :\n                                    axis.visibleRange.interval);\n                        }\n                        startValue = stripline.startFromAxis && axis.valueType !== 'DateTime' ? axis.visibleRange.min : startValue;\n                        while (startValue < limit) {\n                            end = (startValue + (axis.valueType === 'DateTime' ? axis.dateTimeInterval * +stripline.size : stripline.size));\n                            range = withIn(end, axis.visibleRange);\n                            if ((startValue >= axis.visibleRange.min && startValue < axis.visibleRange.max) || range) {\n                                this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count);\n                            }\n                            count++;\n                            startValue = this.getStartValue(axis, stripline, startValue, chart);\n                        }\n                    }\n                    else {\n                        this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, null, segmentAxis, count);\n                        count++;\n                    }\n                }\n            }\n        }\n        appendChildElement(chart.enableCanvas, chart.svgObject, striplineGroup, chart.redraw);\n    };\n    /**\n     * To convert the C# date to js date\n     *\n     * @param {string | number | Object} value date value\n     * @returns {boolean} returns true if datetime value type is string(for asp platform)\n     */\n    StripLine.prototype.isCoreDate = function (value) {\n        return typeof value === 'string' ? true : false;\n    };\n    /**\n     * To get the total milli seconds\n     *\n     * @param {Date | number | Object} value date value\n     * @param {Chart} chart chart instance\n     * @returns {number} returns milliseconds\n     */\n    StripLine.prototype.dateToMilliSeconds = function (value, chart) {\n        return this.dateParse(value, chart).getTime();\n    };\n    /**\n     * To draw the single line strip line\n     *\n     * @param {StripLineSettingsModel} stripline stripline\n     * @param {Rect} rect rect\n     * @param {string} id id\n     * @param {Element} parent parent\n     * @param {Chart} chart chart\n     * @param {Axis} axis axis\n     */\n    StripLine.prototype.renderPath = function (stripline, rect, id, parent, chart, axis) {\n        var element = getElement(id);\n        var direction = element ? element.getAttribute('d') : '';\n        var d = (axis.orientation === 'Vertical') ? ('M' + rect.x + ' ' + rect.y + ' ' + 'L' + (rect.x + rect.width)\n            + ' ' + rect.y) :\n            ('M' + rect.x + ' ' + rect.y + ' ' + 'L' + rect.x + ' ' + (rect.y + rect.height));\n        appendChildElement(chart.enableCanvas, parent, chart.renderer.drawPath(new PathOption(id, '', stripline.size, stripline.color, stripline.opacity, stripline.dashArray, d)), chart.redraw, true, 'x', 'y', null, direction, true);\n    };\n    /**\n     * To draw the rectangle\n     *\n     * @param {StripLineSettingsModel} stripline stripline\n     * @param {Rect} rect rect\n     * @param {string} id id\n     * @param {Element} parent parent\n     * @param {Chart} chart chart\n     */\n    StripLine.prototype.renderRectangle = function (stripline, rect, id, parent, chart) {\n        var element = getElement(id);\n        var previousRect = element ? new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')) : null;\n        appendChildElement(chart.enableCanvas, parent, chart.renderer.drawRectangle(new RectOption(id, stripline.color, stripline.border, stripline.opacity, rect, 0, 0, '', stripline.dashArray)), chart.redraw, true, 'x', 'y', null, null, true, true, previousRect);\n    };\n    /**\n     * To create the text on strip line\n     *\n     * @param {StripLineSettingsModel} stripline stripline\n     * @param {Rect} rect rect\n     * @param {string} id id\n     * @param {Element} parent parent\n     * @param {Chart} chart chart\n     * @param {Axis} axis axis\n     */\n    StripLine.prototype.renderText = function (stripline, rect, id, parent, chart, axis) {\n        var textSize = measureText(stripline.text, stripline.textStyle);\n        var isRotationNull = (stripline.rotation === null);\n        var textMid = isRotationNull ? 3 * (textSize.height / 8) : 0;\n        var ty = rect.y + (rect.height / 2) + textMid;\n        var rotation = isRotationNull ? ((axis.orientation === 'Vertical') ? 0 : -90) : stripline.rotation;\n        var tx = rect.x + (rect.width / 2);\n        var anchor;\n        var padding = 5;\n        if (axis.orientation === 'Horizontal') {\n            tx = this.getTextStart(tx + (textMid * this.factor(stripline.horizontalAlignment)), rect.width, stripline.horizontalAlignment);\n            ty = this.getTextStart(ty - textMid, rect.height, stripline.verticalAlignment) +\n                (stripline.verticalAlignment === 'Start' && !isRotationNull ? (textSize.height / 4) : 0);\n            anchor = isRotationNull ? this.invertAlignment(stripline.verticalAlignment) : stripline.horizontalAlignment;\n        }\n        else {\n            tx = this.getTextStart(tx, rect.width, stripline.horizontalAlignment);\n            ty = this.getTextStart(ty + (textMid * this.factor(stripline.verticalAlignment)) - padding, rect.height, stripline.verticalAlignment);\n            anchor = stripline.horizontalAlignment;\n        }\n        textElement(chart.renderer, new TextOption(id, tx, ty, anchor, stripline.text, 'rotate(' + rotation + ' ' + tx + ',' + ty + ')', 'middle'), stripline.textStyle, stripline.textStyle.color, parent);\n    };\n    StripLine.prototype.invertAlignment = function (anchor) {\n        switch (anchor) {\n            case 'Start':\n                anchor = 'End';\n                break;\n            case 'End':\n                anchor = 'Start';\n                break;\n        }\n        return anchor;\n    };\n    /**\n     * To find the next value of the recurrence strip line\n     *\n     * @param {Axis} axis axis\n     * @param {StripLineSettingsModel} stripline stripline\n     * @param {number} startValue startValue\n     * @param {Chart} chart chart instance\n     * @returns {number} next start value of the recurrence strip line\n     */\n    StripLine.prototype.getStartValue = function (axis, stripline, startValue, chart) {\n        if (axis.valueType === 'DateTime') {\n            return (this.getToValue(null, startValue, this.isCoreDate(stripline.repeatEvery) ? this.dateToMilliSeconds(stripline.repeatEvery, chart) : +stripline.repeatEvery, axis, null, stripline));\n        }\n        else {\n            return startValue + (+stripline.repeatEvery);\n        }\n    };\n    /**\n     * Finding segment axis for segmented strip line\n     *\n     * @param {Axis[]} axes axes collection\n     * @param {Axis} axis axis\n     * @param {StripLineSettingsModel} stripline stripline\n     */\n    StripLine.prototype.getSegmentAxis = function (axes, axis, stripline) {\n        var segment;\n        if (stripline.segmentAxisName == null) {\n            return (axis.orientation === 'Horizontal') ? axes[1] : axes[0];\n        }\n        else {\n            for (var i = 0; i < axes.length; i++) {\n                if (stripline.segmentAxisName === axes[i].name) {\n                    segment = axes[i];\n                }\n            }\n            return segment;\n        }\n    };\n    /**\n     * To render strip line on chart\n     *\n     * @param {Axis} axis axis\n     * @param {StripLineSettingsModel} stripline stripline\n     * @param {Rect} seriesClipRect seriesClipRect\n     * @param {string} id id\n     * @param {Element} striplineGroup striplineGroup\n     * @param {Chart} chart chart\n     * @param {number} startValue startValue\n     * @param {Axis} segmentAxis segmentAxis\n     * @param {number} count count\n     */\n    StripLine.prototype.renderStripLineElement = function (axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count) {\n        var rect = this.measureStripLine(axis, stripline, seriesClipRect, startValue, segmentAxis, chart);\n        if (stripline.sizeType === 'Pixel') {\n            this.renderPath(stripline, rect, id + 'path_' + axis.name + '_' + count, striplineGroup, chart, axis);\n        }\n        else {\n            if (rect.height !== 0 && rect.width !== 0) {\n                this.renderRectangle(stripline, rect, id + 'rect_' + axis.name + '_' + count, striplineGroup, chart);\n            }\n        }\n        if (stripline.text !== '') {\n            this.renderText(stripline, rect, id + 'text_' + axis.name + '_' + count, striplineGroup, chart, axis);\n        }\n    };\n    /**\n     * To find the factor of the text\n     *\n     * @param {Anchor} anchor text anchor\n     */\n    StripLine.prototype.factor = function (anchor) {\n        var factor = 0;\n        switch (anchor) {\n            case 'Start':\n                factor = 1;\n                break;\n            case 'End':\n                factor = -1;\n                break;\n        }\n        return factor;\n    };\n    /**\n     * To find the start value of the text\n     *\n     * @param {number} xy xy values\n     * @param {number} size text size\n     * @param {Anchor} textAlignment text alignment\n     */\n    StripLine.prototype.getTextStart = function (xy, size, textAlignment) {\n        var padding = 5;\n        switch (textAlignment) {\n            case 'Start':\n                xy = xy - (size / 2) + padding;\n                break;\n            case 'End':\n                xy = xy + (size / 2) - padding;\n                break;\n        }\n        return xy;\n    };\n    /**\n     * To get the module name for `StripLine`.\n     *\n     * @private\n     */\n    StripLine.prototype.getModuleName = function () {\n        return 'StripLine';\n    };\n    /**\n     * To destroy the `StripLine` module.\n     *\n     * @private\n     */\n    StripLine.prototype.destroy = function () {\n        // destroy peform here\n    };\n    return StripLine;\n}());\nexport { StripLine };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}