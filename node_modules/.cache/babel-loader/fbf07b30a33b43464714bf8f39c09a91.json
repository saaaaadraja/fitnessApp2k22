{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { ChartLocation, getPoint, withInRange } from '../../common/utils/helper';\nimport { PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { LineBase } from './line-base';\n/**\n * `StackingStepAreaSeries` module used to render the Stacking Step Area series.\n */\n\nvar StackingStepAreaSeries =\n/** @class */\nfunction (_super) {\n  __extends(StackingStepAreaSeries, _super);\n\n  function StackingStepAreaSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Render the Stacking step area series.\n   * @return {void}\n   * @private\n   */\n  // tslint:disable-next-line:max-func-body-length\n\n\n  StackingStepAreaSeries.prototype.render = function (stackSeries, xAxis, yAxis, isInverted) {\n    var currentPointLocation;\n    var secondPoint;\n    var start = null;\n    var direction = '';\n    var stackedvalue = stackSeries.stackedValues;\n    var visiblePoint = this.enableComplexProperty(stackSeries);\n    var origin = Math.max(stackSeries.yAxis.visibleRange.min, stackedvalue.startValues[0]);\n    var pointsLength = visiblePoint.length;\n    var options;\n    var point;\n    var point2;\n    var point3;\n    var xValue;\n    var lineLength;\n    var prevPoint = null;\n    var validIndex;\n    var startPoint = 0;\n    var pointIndex;\n\n    if (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') {\n      lineLength = 0.5;\n    } else {\n      lineLength = 0;\n    }\n\n    for (var i = 0; i < pointsLength; i++) {\n      point = visiblePoint[i];\n      xValue = point.xValue;\n      point.symbolLocations = [];\n      point.regions = [];\n      pointIndex = point.index;\n\n      if (point.visible && withInRange(visiblePoint[i - 1], point, visiblePoint[i + 1], stackSeries)) {\n        if (start === null) {\n          start = new ChartLocation(xValue, 0);\n          currentPointLocation = getPoint(xValue - lineLength, origin, xAxis, yAxis, isInverted);\n          direction += 'M' + ' ' + currentPointLocation.x + ' ' + currentPointLocation.y + ' ';\n          currentPointLocation = getPoint(xValue - lineLength, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\n          direction += 'L' + ' ' + currentPointLocation.x + ' ' + currentPointLocation.y + ' ';\n        }\n\n        if (prevPoint != null) {\n          currentPointLocation = getPoint(point.xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\n          secondPoint = getPoint(prevPoint.xValue, stackedvalue.endValues[prevPoint.index], xAxis, yAxis, isInverted);\n          direction += 'L' + ' ' + currentPointLocation.x + ' ' + secondPoint.y + ' L' + ' ' + currentPointLocation.x + ' ' + currentPointLocation.y + ' ';\n        } else if (stackSeries.emptyPointSettings.mode === 'Gap') {\n          currentPointLocation = getPoint(point.xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\n          direction += 'L' + ' ' + currentPointLocation.x + ' ' + currentPointLocation.y + ' ';\n        }\n\n        visiblePoint[i].symbolLocations.push(getPoint(visiblePoint[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted, stackSeries));\n        visiblePoint[i].regions.push(new Rect(visiblePoint[i].symbolLocations[0].x - stackSeries.marker.width, visiblePoint[i].symbolLocations[0].y - stackSeries.marker.height, 2 * stackSeries.marker.width, 2 * stackSeries.marker.height));\n        prevPoint = point;\n      } // If we set the empty point mode is Gap or next point of the current point is false, we will close the series path.\n\n\n      if (visiblePoint[i + 1] && !visiblePoint[i + 1].visible && stackSeries.emptyPointSettings.mode !== 'Drop') {\n        var previousPointIndex = void 0;\n\n        for (var j = i; j >= startPoint; j--) {\n          pointIndex = visiblePoint[j].index;\n          previousPointIndex = j === 0 ? 0 : visiblePoint[j - 1].index;\n\n          if (j !== 0 && (stackedvalue.startValues[pointIndex] < stackedvalue.startValues[previousPointIndex] || stackedvalue.startValues[pointIndex] > stackedvalue.startValues[previousPointIndex])) {\n            currentPointLocation = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted, stackSeries);\n            direction = direction.concat('L' + ' ' + currentPointLocation.x + ' ' + currentPointLocation.y + ' ');\n            currentPointLocation = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[previousPointIndex], xAxis, yAxis, isInverted, stackSeries);\n          } else {\n            currentPointLocation = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted, stackSeries);\n          }\n\n          direction = direction.concat('L' + ' ' + currentPointLocation.x + ' ' + currentPointLocation.y + ' ');\n        }\n\n        startPoint = i + 1;\n        start = null;\n        prevPoint = null;\n      }\n    }\n\n    if (direction !== '') {\n      // For category axis\n      if (pointsLength > 1) {\n        pointIndex = visiblePoint[pointsLength - 1].index;\n        start = {\n          'x': visiblePoint[pointsLength - 1].xValue + lineLength,\n          'y': stackedvalue.endValues[pointIndex]\n        };\n        secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);\n        direction += 'L' + ' ' + secondPoint.x + ' ' + secondPoint.y + ' ';\n        start = {\n          'x': visiblePoint[pointsLength - 1].xValue + lineLength,\n          'y': stackedvalue.startValues[pointIndex]\n        };\n        secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);\n        direction += 'L' + ' ' + secondPoint.x + ' ' + secondPoint.y + ' ';\n      } // To close the stacked step area series path in reverse order\n\n\n      for (var j = pointsLength - 1; j >= startPoint; j--) {\n        var index = void 0;\n\n        if (visiblePoint[j].visible) {\n          pointIndex = visiblePoint[j].index;\n          point2 = getPoint(visiblePoint[j].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted, stackSeries);\n          direction = direction.concat('L' + ' ' + point2.x + ' ' + point2.y + ' ');\n        }\n\n        if (j !== 0 && !visiblePoint[j - 1].visible) {\n          index = this.getNextVisiblePointIndex(visiblePoint, j);\n        }\n\n        if (j !== 0) {\n          validIndex = index ? index : j - 1;\n          pointIndex = index ? visiblePoint[index].index : visiblePoint[j - 1].index;\n          point3 = getPoint(visiblePoint[validIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted, stackSeries);\n          direction = direction.concat('L' + ' ' + point2.x + ' ' + point3.y + ' ');\n        }\n      }\n\n      options = new PathOption(stackSeries.chart.element.id + '_Series_' + stackSeries.index, stackSeries.interior, stackSeries.border.width, stackSeries.border.color, stackSeries.opacity, stackSeries.dashArray, direction);\n      this.appendLinePath(options, stackSeries, '');\n      this.renderMarker(stackSeries);\n    }\n  };\n  /**\n   * Animates the series.\n   * @param  {Series} series - Defines the series to animate.\n   * @return {void}\n   */\n\n\n  StackingStepAreaSeries.prototype.doAnimation = function (series) {\n    var option = series.animation;\n    this.doLinearAnimation(series, option);\n  };\n  /**\n   * To destroy the stacking step area.\n   * @return {void}\n   * @private\n   */\n\n\n  StackingStepAreaSeries.prototype.destroy = function (chart) {\n    /**\n     * Destroy method calling here\n     */\n  };\n  /**\n   * Get module name.\n   */\n\n\n  StackingStepAreaSeries.prototype.getModuleName = function () {\n    /**\n     * Returns the module name of the series\n     */\n    return 'StackingStepAreaSeries';\n  };\n  /**\n   * To get the nearest visible point\n   * @param points\n   * @param j\n   */\n\n\n  StackingStepAreaSeries.prototype.getNextVisiblePointIndex = function (points, j) {\n    var index;\n\n    for (index = j - 1; index >= 0; index--) {\n      if (!points[index].visible) {\n        continue;\n      } else {\n        return index;\n      }\n    }\n\n    return 0;\n  };\n\n  return StackingStepAreaSeries;\n}(LineBase);\n\nexport { StackingStepAreaSeries };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","ChartLocation","getPoint","withInRange","PathOption","Rect","LineBase","StackingStepAreaSeries","_super","apply","arguments","render","stackSeries","xAxis","yAxis","isInverted","currentPointLocation","secondPoint","start","direction","stackedvalue","stackedValues","visiblePoint","enableComplexProperty","origin","Math","max","visibleRange","min","startValues","pointsLength","length","options","point","point2","point3","xValue","lineLength","prevPoint","validIndex","startPoint","pointIndex","valueType","labelPlacement","i","symbolLocations","regions","index","visible","x","y","endValues","emptyPointSettings","mode","push","marker","width","height","previousPointIndex","j","concat","getNextVisiblePointIndex","chart","element","id","interior","border","color","opacity","dashArray","appendLinePath","renderMarker","doAnimation","series","option","animation","doLinearAnimation","destroy","getModuleName","points"],"sources":["D:/Theme/package/node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-step-area-series.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ChartLocation, getPoint, withInRange } from '../../common/utils/helper';\nimport { PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { LineBase } from './line-base';\n/**\n * `StackingStepAreaSeries` module used to render the Stacking Step Area series.\n */\nvar StackingStepAreaSeries = /** @class */ (function (_super) {\n    __extends(StackingStepAreaSeries, _super);\n    function StackingStepAreaSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Render the Stacking step area series.\n     * @return {void}\n     * @private\n     */\n    // tslint:disable-next-line:max-func-body-length\n    StackingStepAreaSeries.prototype.render = function (stackSeries, xAxis, yAxis, isInverted) {\n        var currentPointLocation;\n        var secondPoint;\n        var start = null;\n        var direction = '';\n        var stackedvalue = stackSeries.stackedValues;\n        var visiblePoint = this.enableComplexProperty(stackSeries);\n        var origin = Math.max(stackSeries.yAxis.visibleRange.min, stackedvalue.startValues[0]);\n        var pointsLength = visiblePoint.length;\n        var options;\n        var point;\n        var point2;\n        var point3;\n        var xValue;\n        var lineLength;\n        var prevPoint = null;\n        var validIndex;\n        var startPoint = 0;\n        var pointIndex;\n        if (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') {\n            lineLength = 0.5;\n        }\n        else {\n            lineLength = 0;\n        }\n        for (var i = 0; i < pointsLength; i++) {\n            point = visiblePoint[i];\n            xValue = point.xValue;\n            point.symbolLocations = [];\n            point.regions = [];\n            pointIndex = point.index;\n            if (point.visible && withInRange(visiblePoint[i - 1], point, visiblePoint[i + 1], stackSeries)) {\n                if (start === null) {\n                    start = new ChartLocation(xValue, 0);\n                    currentPointLocation = getPoint(xValue - lineLength, origin, xAxis, yAxis, isInverted);\n                    direction += ('M' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');\n                    currentPointLocation = getPoint(xValue - lineLength, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\n                    direction += ('L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');\n                }\n                if (prevPoint != null) {\n                    currentPointLocation = getPoint(point.xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\n                    secondPoint = getPoint(prevPoint.xValue, stackedvalue.endValues[prevPoint.index], xAxis, yAxis, isInverted);\n                    direction += ('L' + ' ' + (currentPointLocation.x) + ' ' + (secondPoint.y) +\n                        ' L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');\n                }\n                else if (stackSeries.emptyPointSettings.mode === 'Gap') {\n                    currentPointLocation = getPoint(point.xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\n                    direction += 'L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ';\n                }\n                visiblePoint[i].symbolLocations.push(getPoint(visiblePoint[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted, stackSeries));\n                visiblePoint[i].regions.push(new Rect(visiblePoint[i].symbolLocations[0].x - stackSeries.marker.width, visiblePoint[i].symbolLocations[0].y - stackSeries.marker.height, 2 * stackSeries.marker.width, 2 * stackSeries.marker.height));\n                prevPoint = point;\n            }\n            // If we set the empty point mode is Gap or next point of the current point is false, we will close the series path.\n            if (visiblePoint[i + 1] && !visiblePoint[i + 1].visible && stackSeries.emptyPointSettings.mode !== 'Drop') {\n                var previousPointIndex = void 0;\n                for (var j = i; j >= startPoint; j--) {\n                    pointIndex = visiblePoint[j].index;\n                    previousPointIndex = j === 0 ? 0 : visiblePoint[j - 1].index;\n                    if (j !== 0 && (stackedvalue.startValues[pointIndex] < stackedvalue.startValues[previousPointIndex] ||\n                        stackedvalue.startValues[pointIndex] > stackedvalue.startValues[previousPointIndex])) {\n                        currentPointLocation = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted, stackSeries);\n                        direction = direction.concat('L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');\n                        currentPointLocation = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[previousPointIndex], xAxis, yAxis, isInverted, stackSeries);\n                    }\n                    else {\n                        currentPointLocation = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted, stackSeries);\n                    }\n                    direction = direction.concat('L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');\n                }\n                startPoint = i + 1;\n                start = null;\n                prevPoint = null;\n            }\n        }\n        if (direction !== '') {\n            // For category axis\n            if (pointsLength > 1) {\n                pointIndex = visiblePoint[pointsLength - 1].index;\n                start = { 'x': visiblePoint[pointsLength - 1].xValue + lineLength, 'y': stackedvalue.endValues[pointIndex] };\n                secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);\n                direction += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');\n                start = { 'x': visiblePoint[pointsLength - 1].xValue + lineLength, 'y': stackedvalue.startValues[pointIndex] };\n                secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);\n                direction += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');\n            }\n            // To close the stacked step area series path in reverse order\n            for (var j = pointsLength - 1; j >= startPoint; j--) {\n                var index = void 0;\n                if (visiblePoint[j].visible) {\n                    pointIndex = visiblePoint[j].index;\n                    point2 = getPoint(visiblePoint[j].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted, stackSeries);\n                    direction = direction.concat('L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ');\n                }\n                if (j !== 0 && !visiblePoint[j - 1].visible) {\n                    index = this.getNextVisiblePointIndex(visiblePoint, j);\n                }\n                if (j !== 0) {\n                    validIndex = index ? index : j - 1;\n                    pointIndex = index ? visiblePoint[index].index : visiblePoint[j - 1].index;\n                    point3 = getPoint(visiblePoint[validIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted, stackSeries);\n                    direction = direction.concat('L' + ' ' + (point2.x) + ' ' + (point3.y) + ' ');\n                }\n            }\n            options = new PathOption(stackSeries.chart.element.id + '_Series_' + stackSeries.index, stackSeries.interior, stackSeries.border.width, stackSeries.border.color, stackSeries.opacity, stackSeries.dashArray, direction);\n            this.appendLinePath(options, stackSeries, '');\n            this.renderMarker(stackSeries);\n        }\n    };\n    /**\n     * Animates the series.\n     * @param  {Series} series - Defines the series to animate.\n     * @return {void}\n     */\n    StackingStepAreaSeries.prototype.doAnimation = function (series) {\n        var option = series.animation;\n        this.doLinearAnimation(series, option);\n    };\n    /**\n     * To destroy the stacking step area.\n     * @return {void}\n     * @private\n     */\n    StackingStepAreaSeries.prototype.destroy = function (chart) {\n        /**\n         * Destroy method calling here\n         */\n    };\n    /**\n     * Get module name.\n     */\n    StackingStepAreaSeries.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the series\n         */\n        return 'StackingStepAreaSeries';\n    };\n    /**\n     * To get the nearest visible point\n     * @param points\n     * @param j\n     */\n    StackingStepAreaSeries.prototype.getNextVisiblePointIndex = function (points, j) {\n        var index;\n        for (index = j - 1; index >= 0; index--) {\n            if (!points[index].visible) {\n                continue;\n            }\n            else {\n                return index;\n            }\n        }\n        return 0;\n    };\n    return StackingStepAreaSeries;\n}(LineBase));\nexport { StackingStepAreaSeries };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}